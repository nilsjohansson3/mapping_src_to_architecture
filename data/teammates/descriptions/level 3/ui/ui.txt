The UI seen by users consists of Web pages containing HTML, CSS (for styling) and JavaScript (for client-side interactions such as sorting, input validation, etc.). This UI is a single HTML page generated by Angular framework. The initial page request is sent to the server over HTTP, and requests for data are sent asynchronously with AJAX.

The entry point for the application back end logic is designed as a REST-ful controller.

The diagram below shows the object structure of the UI component.

<puml src="diagrams/UiComponent.puml"/>

Notes:

- `ui::website` is not a Java package. It is written in Angular framework and consists of HTML, SCSS, and TypeScript files. The framework will build those files into HTML, CSS and JavaScript files ready to be used by standard Web browsers.

The UI component is the first stop for 99% of all requests that are received by the application.
Such a request will go through the following steps:

1. Request received by the GAE server.
1. Custom filters are applied according to the order specified in `web.xml`, e.g. `OriginCheckFilter`.
1. Request forwarded to a `*Servlet` object as specified in `web.xml` for further processing, depending on the type of request.

There are two general types of requests: user-invoked requests and automated (GAE server-invoked) requests, which are processed differently.

User-invoked requests

User-invoked requests are all requests made by the users of the application, typically from the Web browser (i.e. by navigating to a particular URL of the application).
The request will be processed as follows:

<puml src="diagrams/UiWorkflow.puml"/>

The initial request for the web page will be processed as follows:

1. Request forwarded to `WebPageServlet`.
1. `WebPageServlet` returns the built single web page (`index.html`).
1. The browser will render the page and execute the page scripts, most of the time requiring AJAX requests to the server.

Subsequent AJAX requests sent to the server will be processed as follows:

1. Request forwarded to the `WebApiServlet`.
1. `WebApiServlet` uses the `ActionFactory` to generate the matching `Action` object, e.g. `GetFeedbackSessionsAction`.
1. `WebApiServlet` executes the action.
   1. The `Action` object checks the access rights of the user. If the action is allowed, it will be performed, interacting with the `Logic` component as necessary.
   1. The `Action` packages and processes the result into an `ActionResult` object. The most common format is `JsonResult` (requests for obtaining data or processing existing data) and other formats can be defined as necessary.
1. `WebApiServlet` sends the result back to the browser which will then process it on the front-end.

Requests for static asset files (e.g. CSS, JS files, images) are served directly without going through `web.xml` configuration at all.

The Web API is protected by two layers of access control check:

- Origin check: This mitigates [CSRF attack](https://owasp.org/www-community/attacks/csrf).
- Authentication and authorization check: This checks if the logged in user (or lack thereof) has sufficient privileges to trigger the API's actions.

Special keys (`csrf key` and `backdoor key`) can be used to bypass each of the checks, typically for testing purpose. Those keys are strings known only to the person who deployed the application (typically, the administrator).

Automated requests

Automated requests are all requests sent automatically by the GAE server during specific periods of time.
This type of request will be processed as follows:

1. The source of the request will be checked for administrator privilege. If this privilege is absent (e.g. non-administrator users trying to invoke the automated actions), the request will be dropped and a `403 Forbidden` status will be returned.
   - Requests generated by the GAE server are equipped with this privilege.
   - Administrators can manually invoke these requests; this is particularly useful in testing the actions associated with those requests.
1. Request forwarded to the `WebApiServlet` and subsequent actions are the same as user-invoked AJAX requests.

GAE server sends such automated requests through two different configurations:

- Cron jobs: These are jobs that are automatically scheduled for a specified period of time, e.g. scheduling feedback session opening reminders. It is configured in `cron.yaml`.
- Task queue workers: These are hybrids of user-invoked and GAE-invoked in that they are queued by users (i.e. users request for the tasks to be added to queue), but executed by GAE (i.e. GAE determines when and which tasks in the queue are executed at any point of time). This is typically used for tasks that may take a long time to finish and might be blocking user's interaction. It is configured in `queue.yaml` as well as the `TaskQueue` nested class of the [Const](https://github.com/TEAMMATES/teammates/blob/master/src/main/java/teammates/common/util/Const.java) class.

Template Method pattern

- Since the high-level workflow of processing a request is same for any request (differing by the two request types only), we use the [Template Method pattern](http://en.wikipedia.org/wiki/Template_method_pattern) to abstract the process flow into the `Action` classes.

Policies

On designing API endpoints (for AJAX requests):

- Design endpoints for resources. For example, `FeedbackSession` is a resource. The corresponding endpoint is `/session`. We use `GET`, `POST`, `PUT`, `DELETE` HTTP methods to get, create, update and delete the resource respectively.
- Prefer multiple REST calls over single RPC (Remote Procedure Call) calls.
  - Reason 1: REST paradigm promotes reuse of many business logic and is not dependent of the structure of the requesting web page (or any other type of requesting agent).
  - Reason 2: Multiple REST calls can be parallelized which will improve performance.
- Separate access control logic and execution logic completely.
  - In the case that an endpoint serves multiple purposes, we use `Intent` to distinguish the intent for the request. For example, instructors can access `/session` with intent `INSTRUCTOR_SUBMISSION` or `FULL_DETAIL`. Some `Intent` will naturally require stricter access rights.
- Prefer HTTP request body over URL parameters (key-value) to contain data for `POST` and `PUT` requests.
  - Reason 1: The URL parameters are used to identify a specific resource for an endpoint, not what should be done to them.
  - Reason 2: Request body is not limited to key-value format which allows proper design and validation.
  - Data Transfer Objects (DTOs) which represent different API requests and responses are defined in `request` and `output` package respectively.
- Preprocess data sent/received by the server to hide complexities. For example, timestamp is passed as UNIX epoch milliseconds in the output while it is represented as `Instant` in the back-end.
  - Some constructors in the `output` package contain logic to hide "hacks" in the backend.
  - Some getters/setters in the `request` package contain logic to cater the conventions in the backend.
  - Some fields are required be hidden in the API response, mostly for data privacy purposes. Whenever required, there should be methods in the request output objects catered for this.
- API endpoints should not be concerned with how data is presented.
  - Case study 1: some endpoint will pass timezone information via two information: timezone ID and UNIX epoch milliseconds. It is up to the front-end on how to make use of those two pieces of information.
  - Case study 2: CSV file for session result or student list is just a different way of presenting the same information in the web page. Due to this, when downloading CSV, the web page will request the same information as that used when displaying in web page and do the necessary conversion to CSV.

On data exchange between front-end and back-end:

- Back-end is the single source of truth for all data format and the code used by front-end is generated from this.
  - Some important constants (including API endpoints information) are synced to `api-const.ts`.
  - The schemas of the DTOs defined in `output` and `request` packages are synced to `api-output.ts` and `api-request.ts` in the frontend.

On handling exceptions:

- The UI component is responsible for catching all exceptions and transforming them to properly formed, user-friendly output format. It includes the status message shown to user as well as the HTTP status code.
  - As a consequence, the UI component cannot throw any exception, because there is no layer which will catch those exceptions if it does.
- In order to streamline the process, custom runtime exception classes which correspond to different HTTP status codes are used. For example, there is `EntityNotFoundException` which corresponds to HTTP 404, `UnauthorizedAccessException` which corresponds to HTTP 403, etc.
  - It is highly preferred to throw these custom exceptions instead of setting the HTTP status manually in the action class, as the API layer has been configured to automatically log the exception and assign the correct status code to the HTTP response.
- All `4XX` responses must be accompanied with logging at `warning` level or above. `5XX` responses must be accompanied with `severe` level logging.
  - `502` (Bad Gateway) responses may skip the `severe` level logging if the upstream components (where the error happened) already did the `severe` level logging.
- We use the HTTP status codes as close to their standard definition in [RFC7231](https://tools.ietf.org/html/rfc7231) as possible.

