Module,Text
barrier,A barrier can be viewed as a gate at which tasks wait until the gate is opened.
barrier,This has many analogies in the real world.  Horses and other farm animals may
barrier,"approach a closed gate and gather in front of it, waiting for someone to open"
barrier,"the gate so they may proceed.  Similarly, ticket holders gather at the gates of"
barrier,arenas before concerts or sporting events waiting for the arena personnel to
barrier,open the gates so they may enter.
barrier,Barriers are useful during application initialization.  Each application task
barrier,can perform its local initialization before waiting for the application as a
barrier,whole to be initialized.  Once all tasks have completed their independent
barrier,"initializations, the “application ready” barrier can be released."
barrier,"Just as with a real-world gate, barriers may be configured to be manually"
barrier,opened or automatically opened.  All tasks calling the rtems_barrier_wait
barrier,directive will block until a controlling task invokes
barrier,the rtems_barrier_release directive.
barrier,Automatic barriers are created with a limit to the number of tasks which may
barrier,"simultaneously block at the barrier.  Once this limit is reached, all of the"
barrier,"tasks are released.  For example, if the automatic limit is ten tasks, then the"
barrier,first nine tasks calling the rtems_barrier_wait directive will block.  When
barrier,"the tenth task calls the rtems_barrier_wait directive, the nine blocked"
barrier,tasks will be released and the tenth task returns to the caller without
barrier,blocking.
barrier,"In general, an attribute set is built by a bitwise OR of the desired attribute"
barrier,components.  The following table lists the set of valid barrier attributes:
barrier,automatically release the barrier when the configured number of tasks are
barrier,blocked
barrier,only release the barrier when the application invokes the
barrier,rtems_barrier_release directive.  (default)
barrier,Note
barrier,Barriers only support FIFO blocking order because all waiting tasks are
barrier,released as a set.  Thus the released tasks will all become ready to execute
barrier,at the same time and compete for the processor based upon their priority.
barrier,"Attribute values are specifically designed to be mutually exclusive, therefore"
barrier,bitwise OR and addition operations are equivalent as long as each attribute
barrier,appears exactly once in the component list.  An attribute listed as a default
barrier,"is not required to appear in the attribute list, although it is a good"
barrier,programming practice to specify default attributes.  If all defaults are
barrier,"desired, the attribute RTEMS_DEFAULT_ATTRIBUTES should be specified on this"
barrier,call.
barrier,This example demonstrates the attribute_set parameter needed to create a
barrier,barrier with the automatic release policy.  The attribute_set parameter
barrier,passed to the rtems_barrier_create directive will be
barrier,"RTEMS_BARRIER_AUTOMATIC_RELEASE.  In this case, the user must also specify"
barrier,the maximum_waiters parameter.
barrier,"© Copyright 1988, 2024 RTEMS Project and contributors."
barrier,The Barrier Manager provides a unique synchronization capability which can be
barrier,used to have a set of tasks block and be unblocked as a set. The directives
barrier,provided by the Barrier Manager are:
barrier,rtems_barrier_create() - Creates a barrier.
barrier,rtems_barrier_ident() - Identifies a barrier by the object name.
barrier,rtems_barrier_delete() - Deletes the barrier.
barrier,rtems_barrier_wait() - Waits at the barrier.
barrier,rtems_barrier_release() - Releases the barrier.
barrier,rtems_barrier_create() - Creates a barrier.
barrier,rtems_barrier_ident() - Identifies a barrier by the object name.
barrier,rtems_barrier_delete() - Deletes the barrier.
barrier,rtems_barrier_wait() - Waits at the barrier.
barrier,rtems_barrier_release() - Releases the barrier.
barrier,"© Copyright 1988, 2024 RTEMS Project and contributors."
cache,The Cache Manager provides functions to perform maintenance operations for data
cache,and instruction caches.
cache,The actual actions of the Cache Manager operations depend on the hardware and
cache,the implementation provided by the CPU architecture port or a board support
cache,package.  Cache implementations tend to be highly hardware dependent. The
cache,directives provided by the Cache Manager are:
cache,rtems_cache_flush_multiple_data_lines() - Flushes the data cache
cache,lines covering the memory area.
cache,rtems_cache_invalidate_multiple_data_lines() - Invalidates the data
cache,cache lines covering the memory area.
cache,rtems_cache_invalidate_multiple_instruction_lines() - Invalidates
cache,the instruction cache lines covering the memory area.
cache,rtems_cache_instruction_sync_after_code_change() - Ensures necessary
cache,synchronization required after code changes.
cache,rtems_cache_get_maximal_line_size() - Gets the maximal cache line
cache,"size in bytes of all caches (data, instruction, or unified)."
cache,rtems_cache_get_data_line_size() - Gets the data cache line size in
cache,bytes.
cache,rtems_cache_get_instruction_line_size() - Gets the instruction cache
cache,line size in bytes.
cache,rtems_cache_get_data_cache_size() - Gets the data cache size in
cache,bytes for the cache level.
cache,rtems_cache_get_instruction_cache_size() - Gets the instruction
cache,cache size in bytes for the cache level.
cache,rtems_cache_flush_entire_data() - Flushes the entire data cache.
cache,rtems_cache_invalidate_entire_data() - Invalidates the entire data
cache,cache.
cache,rtems_cache_invalidate_entire_instruction() - Invalidates the
cache,entire instruction cache.
cache,rtems_cache_enable_data() - Enables the data cache.
cache,rtems_cache_disable_data() - Disables the data cache.
cache,rtems_cache_enable_instruction() - Enables the instruction cache.
cache,rtems_cache_disable_instruction() - Disables the instruction
cache,cache.
cache,rtems_cache_aligned_malloc() - Allocates memory from the C Program
cache,Heap which begins at a cache line boundary.
cache,rtems_cache_flush_multiple_data_lines() - Flushes the data cache
cache,lines covering the memory area.
cache,rtems_cache_invalidate_multiple_data_lines() - Invalidates the data
cache,cache lines covering the memory area.
cache,rtems_cache_invalidate_multiple_instruction_lines() - Invalidates
cache,the instruction cache lines covering the memory area.
cache,rtems_cache_instruction_sync_after_code_change() - Ensures necessary
cache,synchronization required after code changes.
cache,rtems_cache_get_maximal_line_size() - Gets the maximal cache line
cache,"size in bytes of all caches (data, instruction, or unified)."
cache,rtems_cache_get_data_line_size() - Gets the data cache line size in
cache,bytes.
cache,rtems_cache_get_instruction_line_size() - Gets the instruction cache
cache,line size in bytes.
cache,rtems_cache_get_data_cache_size() - Gets the data cache size in
cache,bytes for the cache level.
cache,rtems_cache_get_instruction_cache_size() - Gets the instruction
cache,cache size in bytes for the cache level.
cache,rtems_cache_flush_entire_data() - Flushes the entire data cache.
cache,rtems_cache_invalidate_entire_data() - Invalidates the entire data
cache,cache.
cache,rtems_cache_invalidate_entire_instruction() - Invalidates the
cache,entire instruction cache.
cache,rtems_cache_enable_data() - Enables the data cache.
cache,rtems_cache_disable_data() - Disables the data cache.
cache,rtems_cache_enable_instruction() - Enables the instruction cache.
cache,rtems_cache_disable_instruction() - Disables the instruction
cache,cache.
cache,rtems_cache_aligned_malloc() - Allocates memory from the C Program
cache,Heap which begins at a cache line boundary.
cache,"© Copyright 1988, 2024 RTEMS Project and contributors."
clock,"For the features provided by the Clock Manager to be utilized, a Clock"
clock,Driver is required.  The Clock Driver usually provides a clock interrupt which
clock,is serviced on each configured processor at each clock tick.  In
clock,"addition, the Clock Driver provides three clock sources:"
clock,clock tick
clock,CLOCK_REALTIME
clock,CLOCK_MONOTONIC
clock,clock tick
clock,CLOCK_REALTIME
clock,CLOCK_MONOTONIC
clock,The time of these clock sources advances at each clock tick.  This yields the
clock,time of the clock sources in a coarse resolution.  To get the time of the
clock,"CLOCK_REALTIME or CLOCK_MONOTONIC clock sources in a higher resolution,"
clock,the Clock Driver may use a clock device to get the time between clock ticks.
clock,The clock facilities of the Clock Manager operate upon calendar time.  These
clock,directives utilize the following date and time structure for the native time
clock,and date format:
clock,The native date and time format is the only format supported when setting the
clock,system date and time using the rtems_clock_set() directive.  Some
clock,applications expect to operate on a UNIX-style date and time data structure.
clock,"For example, the rtems_clock_get_tod_timeval() returns the date and"
clock,time in struct timeval format.
clock,Some directives use data structures defined by POSIX.  The struct
clock,timeval data structure has two members: tv_sec and tv_usec which are
clock,"seconds and microseconds, respectively.  The struct timespec data structure"
clock,"has two members: tv_sec and tv_nsec which are seconds and nanoseconds,"
clock,"respectively.  For CLOCK_REALTIME time points, the tv_sec member in"
clock,these data structures is the number of seconds since the Unix epoch but
clock,will never be prior to the RTEMS epoch.
clock,The struct bintime and sbintime_t time formats used by some directives
clock,originate in FreeBSD.  The struct bintime data structure which represents
clock,time in a binary time format has two members: sec and frac which are
clock,"seconds and fractions of a second in units of \(1 / 2^{64}\) seconds,"
clock,respectively.  The sbintime_t type is a signed 64-bit integer type used to
clock,represent time in units of \(1 / 2^{32}\) seconds.
clock,Timeslicing is a task scheduling discipline in which tasks of equal priority
clock,are executed for a specific period of time before control of the CPU is passed
clock,to another task.  It is also sometimes referred to as the automatic round-robin
clock,scheduling algorithm.  The length of time allocated to each task is known as
clock,the quantum or timeslice.
clock,"The system’s timeslice is defined as an integral number of ticks, and is"
clock,specified by the CONFIGURE_TICKS_PER_TIMESLICE application configuration
clock,"option.  The timeslice is defined for the entire system of tasks, but"
clock,timeslicing is enabled and disabled on a per task basis.
clock,The clock tick directives implement timeslicing by decrementing the
clock,running task’s time-remaining counter when both timeslicing and preemption are
clock,"enabled.  If the task’s timeslice has expired, then that task will be preempted"
clock,if there exists a ready task of equal priority.
clock,A sleep timer allows a task to delay for a given interval or up until a given
clock,"time, and then wake and continue execution.  This type of timer is created"
clock,automatically by the rtems_task_wake_after() and
clock,"rtems_task_wake_when() directives and, as a result, does not have an"
clock,"object identifier.  Once activated, a sleep timer cannot be explicitly deleted."
clock,Each task may activate one and only one sleep timer at a time.
clock,Timeouts are a special type of timer automatically created when the timeout
clock,"option is used on the rtems_barrier_wait(),"
clock,"rtems_event_receive(), rtems_message_queue_receive(),"
clock,"rtems_region_get_segment(), and rtems_semaphore_obtain()"
clock,directives.  Each task may have one and only one timeout active at a time.
clock,"When a timeout expires, it unblocks the task with a timeout status code."
clock,"© Copyright 1988, 2024 RTEMS Project and contributors."
clock,The Clock Manager provides support for time of day and other time related
clock,capabilities. The directives provided by the Clock Manager are:
clock,rtems_clock_set() - Sets the CLOCK_REALTIME to the time
clock,of day.
clock,rtems_clock_get_tod() - Gets the time of day associated with the
clock,current CLOCK_REALTIME.
clock,rtems_clock_get_tod_timeval() - Gets the seconds and microseconds
clock,elapsed since the Unix epoch and the current CLOCK_REALTIME.
clock,rtems_clock_get_realtime() - Gets the time elapsed since the
clock,Unix epoch measured using CLOCK_REALTIME in seconds and
clock,nanoseconds format.
clock,rtems_clock_get_realtime_bintime() - Gets the time elapsed since
clock,the Unix epoch measured using CLOCK_REALTIME in binary time
clock,format.
clock,rtems_clock_get_realtime_timeval() - Gets the time elapsed since
clock,the Unix epoch measured using CLOCK_REALTIME in seconds and
clock,microseconds format.
clock,rtems_clock_get_realtime_coarse() - Gets the time elapsed since the
clock,Unix epoch measured using CLOCK_REALTIME in coarse resolution
clock,in seconds and nanoseconds format.
clock,rtems_clock_get_realtime_coarse_bintime() - Gets the time elapsed
clock,since the Unix epoch measured using CLOCK_REALTIME in coarse
clock,resolution in binary time format.
clock,rtems_clock_get_realtime_coarse_timeval() - Gets the time elapsed
clock,since the Unix epoch measured using CLOCK_REALTIME in coarse
clock,resolution in seconds and microseconds format.
clock,rtems_clock_get_monotonic() - Gets the time elapsed since some
clock,fixed time point in the past measured using the CLOCK_MONOTONIC in
clock,seconds and nanoseconds format.
clock,rtems_clock_get_monotonic_bintime() - Gets the time elapsed since
clock,some fixed time point in the past measured using the CLOCK_MONOTONIC
clock,in binary time format.
clock,rtems_clock_get_monotonic_sbintime() - Gets the time elapsed since
clock,some fixed time point in the past measured using the CLOCK_MONOTONIC
clock,in signed binary time format.
clock,rtems_clock_get_monotonic_timeval() - Gets the time elapsed since
clock,some fixed time point in the past measured using the CLOCK_MONOTONIC
clock,in seconds and microseconds format.
clock,rtems_clock_get_monotonic_coarse() - Gets the time elapsed since
clock,some fixed time point in the past measured using the CLOCK_MONOTONIC
clock,in coarse resolution in seconds and nanoseconds format.
clock,rtems_clock_get_monotonic_coarse_bintime() - Gets the time elapsed
clock,since some fixed time point in the past measured using the
clock,CLOCK_MONOTONIC in coarse resolution in binary time format.
clock,rtems_clock_get_monotonic_coarse_timeval() - Gets the time elapsed
clock,since some fixed time point in the past measured using the
clock,CLOCK_MONOTONIC in coarse resolution in seconds and microseconds
clock,format.
clock,rtems_clock_get_boot_time() - Gets the time elapsed since the
clock,Unix epoch at some time point during system initialization in seconds
clock,and nanoseconds format.
clock,rtems_clock_get_boot_time_bintime() - Gets the time elapsed since
clock,the Unix epoch at some time point during system initialization in
clock,binary time format.
clock,rtems_clock_get_boot_time_timeval() - Gets the time elapsed since
clock,the Unix epoch at some time point during system initialization in
clock,seconds and microseconds format.
clock,rtems_clock_get_seconds_since_epoch() - Gets the seconds elapsed
clock,since the RTEMS epoch and the current CLOCK_REALTIME.
clock,rtems_clock_get_ticks_per_second() - Gets the number of clock
clock,ticks per second configured for the application.
clock,rtems_clock_get_ticks_since_boot() - Gets the number of clock
clock,ticks since some time point during the system initialization or
clock,the last overflow of the clock tick counter.
clock,rtems_clock_get_uptime() - Gets the seconds and nanoseconds
clock,elapsed since some time point during the system initialization using
clock,CLOCK_MONOTONIC.
clock,rtems_clock_get_uptime_timeval() - Gets the seconds and
clock,microseconds elapsed since some time point during the system initialization
clock,using CLOCK_MONOTONIC.
clock,rtems_clock_get_uptime_seconds() - Gets the seconds elapsed since
clock,some time point during the system initialization using
clock,CLOCK_MONOTONIC.
clock,rtems_clock_get_uptime_nanoseconds() - Gets the nanoseconds elapsed
clock,since some time point during the system initialization using
clock,CLOCK_MONOTONIC.
clock,rtems_clock_tick_later() - Gets a clock tick value which
clock,is at least delta clock ticks in the future.
clock,rtems_clock_tick_later_usec() - Gets a clock tick value
clock,which is at least delta microseconds in the future.
clock,rtems_clock_tick_before() - Indicates if the current clock
clock,tick counter is before the ticks.
clock,rtems_clock_set() - Sets the CLOCK_REALTIME to the time
clock,of day.
clock,rtems_clock_get_tod() - Gets the time of day associated with the
clock,current CLOCK_REALTIME.
clock,rtems_clock_get_tod_timeval() - Gets the seconds and microseconds
clock,elapsed since the Unix epoch and the current CLOCK_REALTIME.
clock,rtems_clock_get_realtime() - Gets the time elapsed since the
clock,Unix epoch measured using CLOCK_REALTIME in seconds and
clock,nanoseconds format.
clock,rtems_clock_get_realtime_bintime() - Gets the time elapsed since
clock,the Unix epoch measured using CLOCK_REALTIME in binary time
clock,format.
clock,rtems_clock_get_realtime_timeval() - Gets the time elapsed since
clock,the Unix epoch measured using CLOCK_REALTIME in seconds and
clock,microseconds format.
clock,rtems_clock_get_realtime_coarse() - Gets the time elapsed since the
clock,Unix epoch measured using CLOCK_REALTIME in coarse resolution
clock,in seconds and nanoseconds format.
clock,rtems_clock_get_realtime_coarse_bintime() - Gets the time elapsed
clock,since the Unix epoch measured using CLOCK_REALTIME in coarse
clock,resolution in binary time format.
clock,rtems_clock_get_realtime_coarse_timeval() - Gets the time elapsed
clock,since the Unix epoch measured using CLOCK_REALTIME in coarse
clock,resolution in seconds and microseconds format.
clock,rtems_clock_get_monotonic() - Gets the time elapsed since some
clock,fixed time point in the past measured using the CLOCK_MONOTONIC in
clock,seconds and nanoseconds format.
clock,rtems_clock_get_monotonic_bintime() - Gets the time elapsed since
clock,some fixed time point in the past measured using the CLOCK_MONOTONIC
clock,in binary time format.
clock,rtems_clock_get_monotonic_sbintime() - Gets the time elapsed since
clock,some fixed time point in the past measured using the CLOCK_MONOTONIC
clock,in signed binary time format.
clock,rtems_clock_get_monotonic_timeval() - Gets the time elapsed since
clock,some fixed time point in the past measured using the CLOCK_MONOTONIC
clock,in seconds and microseconds format.
clock,rtems_clock_get_monotonic_coarse() - Gets the time elapsed since
clock,some fixed time point in the past measured using the CLOCK_MONOTONIC
clock,in coarse resolution in seconds and nanoseconds format.
clock,rtems_clock_get_monotonic_coarse_bintime() - Gets the time elapsed
clock,since some fixed time point in the past measured using the
clock,CLOCK_MONOTONIC in coarse resolution in binary time format.
clock,rtems_clock_get_monotonic_coarse_timeval() - Gets the time elapsed
clock,since some fixed time point in the past measured using the
clock,CLOCK_MONOTONIC in coarse resolution in seconds and microseconds
clock,format.
clock,rtems_clock_get_boot_time() - Gets the time elapsed since the
clock,Unix epoch at some time point during system initialization in seconds
clock,and nanoseconds format.
clock,rtems_clock_get_boot_time_bintime() - Gets the time elapsed since
clock,the Unix epoch at some time point during system initialization in
clock,binary time format.
clock,rtems_clock_get_boot_time_timeval() - Gets the time elapsed since
clock,the Unix epoch at some time point during system initialization in
clock,seconds and microseconds format.
clock,rtems_clock_get_seconds_since_epoch() - Gets the seconds elapsed
clock,since the RTEMS epoch and the current CLOCK_REALTIME.
clock,rtems_clock_get_ticks_per_second() - Gets the number of clock
clock,ticks per second configured for the application.
clock,rtems_clock_get_ticks_since_boot() - Gets the number of clock
clock,ticks since some time point during the system initialization or
clock,the last overflow of the clock tick counter.
clock,rtems_clock_get_uptime() - Gets the seconds and nanoseconds
clock,elapsed since some time point during the system initialization using
clock,CLOCK_MONOTONIC.
clock,rtems_clock_get_uptime_timeval() - Gets the seconds and
clock,microseconds elapsed since some time point during the system initialization
clock,using CLOCK_MONOTONIC.
clock,rtems_clock_get_uptime_seconds() - Gets the seconds elapsed since
clock,some time point during the system initialization using
clock,CLOCK_MONOTONIC.
clock,rtems_clock_get_uptime_nanoseconds() - Gets the nanoseconds elapsed
clock,since some time point during the system initialization using
clock,CLOCK_MONOTONIC.
clock,rtems_clock_tick_later() - Gets a clock tick value which
clock,is at least delta clock ticks in the future.
clock,rtems_clock_tick_later_usec() - Gets a clock tick value
clock,which is at least delta microseconds in the future.
clock,rtems_clock_tick_before() - Indicates if the current clock
clock,tick counter is before the ticks.
clock,"© Copyright 1988, 2024 RTEMS Project and contributors."
config,The application configuration information group provides an API to get the
config,configuration of an application.
config,RTEMS must be configured for an application.  This configuration encompasses a
config,"variety of information including the length of each clock tick, the maximum"
config,"number of each information RTEMS object that can be created, the application"
config,"initialization tasks, the task scheduling algorithm to be used, and the device"
config,drivers in the application.
config,Although this information is contained in data structures that are used by
config,"RTEMS at system initialization time, the data structures themselves must not be"
config,generated by hand. RTEMS provides a set of macros system which provides a
config,simple standard mechanism to automate the generation of these structures.
config,The RTEMS header file <rtems/confdefs.h> is at the core of the automatic
config,generation of system configuration. It is based on the idea of setting macros
config,which define configuration parameters of interest to the application and
config,defaulting or calculating all others. This variety of macros can automatically
config,produce all of the configuration data required for an RTEMS application.  The
config,term confdefs is shorthand for a Configuration Defaults.
config,"As a general rule, application developers only specify values for the"
config,configuration parameters of interest to them. They define what resources or
config,"features they require. In most cases, when a parameter is not specified, it"
config,"defaults to zero (0) instances, a standards compliant value, or disabled as"
config,"appropriate. For example, by default there will be 256 task priority levels but"
config,this can be lowered by the application. This number of priority levels is
config,required to be compliant with the RTEID/ORKID standards upon which the Classic
config,API is based. There are similar cases where the default is selected to be
config,compliant with the POSIX standard.
config,"For each configuration parameter in the configuration tables, the macro"
config,corresponding to that field is discussed. The RTEMS Maintainers expect that all
config,systems can be easily configured using the <rtems/confdefs.h> mechanism and
config,that using this mechanism will avoid internal RTEMS configuration changes
config,impacting applications.
config,Some application configuration settings and other system parameters can be
config,queried by the application. The directives provided by the Application
config,Configuration Information are:
config,rtems_get_build_label() - Gets the RTEMS build label.
config,rtems_get_copyright_notice() - Gets the RTEMS copyright notice.
config,rtems_get_target_hash() - Gets the RTEMS target hash.
config,rtems_get_version_string() - Gets the RTEMS version string.
config,rtems_configuration_get_do_zero_of_workspace() - Indicates if the
config,RTEMS Workspace is configured to be zeroed during system initialization for
config,this application.
config,rtems_configuration_get_idle_task_stack_size() - Gets the IDLE task
config,stack size in bytes of this application.
config,rtems_configuration_get_idle_task() - Gets the IDLE task body of
config,this application.
config,rtems_configuration_get_interrupt_stack_size() - Gets the interrupt
config,stack size in bytes of this application.
config,rtems_configuration_get_maximum_barriers() - Gets the resource
config,number of Barrier Manager objects configured for this
config,application.
config,rtems_configuration_get_maximum_extensions() - Gets the resource
config,number of User Extensions Manager objects configured for this
config,application.
config,rtems_configuration_get_maximum_message_queues() - Gets the resource
config,number of Message Manager objects configured for this
config,application.
config,rtems_configuration_get_maximum_partitions() - Gets the resource
config,number of Partition Manager objects configured for this application.
config,rtems_configuration_get_maximum_periods() - Gets the resource
config,number of Rate Monotonic Manager objects configured for this
config,application.
config,rtems_configuration_get_maximum_ports() - Gets the resource number
config,of Dual-Ported Memory Manager objects configured for this application.
config,rtems_configuration_get_maximum_processors() - Gets the maximum
config,number of processors configured for this application.
config,rtems_configuration_get_maximum_regions() - Gets the resource
config,number of Region Manager objects configured for this
config,application.
config,rtems_configuration_get_maximum_semaphores() - Gets the resource
config,number of Semaphore Manager objects configured for this application.
config,rtems_configuration_get_maximum_tasks() - Gets the resource number
config,of Task Manager objects configured for this application.
config,rtems_configuration_get_maximum_timers() - Gets the resource number
config,of Timer Manager objects configured for this application.
config,rtems_configuration_get_microseconds_per_tick() - Gets the number of
config,microseconds per clock tick configured for this application.
config,rtems_configuration_get_milliseconds_per_tick() - Gets the number of
config,milliseconds per clock tick configured for this application.
config,rtems_configuration_get_nanoseconds_per_tick() - Gets the number of
config,microseconds per clock tick configured for this application.
config,rtems_configuration_get_number_of_initial_extensions() - Gets the
config,number of initial extensions configured for this application.
config,rtems_configuration_get_stack_allocate_for_idle_hook() - Gets the task
config,stack allocator allocate hook used to allocate the stack of each IDLE
config,task configured for this application.
config,rtems_configuration_get_stack_allocate_hook() - Gets the task stack
config,allocator allocate hook configured for this application.
config,rtems_configuration_get_stack_allocate_init_hook() - Gets the task
config,stack allocator initialization hook configured for this application.
config,rtems_configuration_get_stack_allocator_avoids_work_space() -
config,Indicates if the task stack allocator is configured to avoid the RTEMS
config,Workspace for this application.
config,rtems_configuration_get_stack_free_hook() - Gets the task stack
config,allocator free hook configured for this application.
config,rtems_configuration_get_stack_space_size() - Gets the configured
config,size in bytes of the memory space used to allocate thread stacks for this
config,application.
config,rtems_configuration_get_ticks_per_timeslice() - Gets the clock ticks
config,per timeslice configured for this application.
config,rtems_configuration_get_unified_work_area() - Indicates if the RTEMS
config,Workspace and C Program Heap are configured to be unified for this
config,application.
config,rtems_configuration_get_user_extension_table() - Gets the initial
config,extensions table configured for this application.
config,rtems_configuration_get_user_multiprocessing_table() - Gets the MPCI
config,configuration table configured for this application.
config,rtems_configuration_get_work_space_size() - Gets the RTEMS Workspace
config,size in bytes configured for this application.
config,rtems_configuration_get_rtems_api_configuration() - Gets the Classic
config,API Configuration Table of this application.
config,rtems_resource_is_unlimited() - Indicates if the resource is
config,unlimited.
config,rtems_resource_maximum_per_allocation() - Gets the maximum number
config,per allocation of a resource number.
config,rtems_resource_unlimited() - Augments the resource number so that
config,it indicates an unlimited resource.
config,rtems_get_build_label() - Gets the RTEMS build label.
config,rtems_get_copyright_notice() - Gets the RTEMS copyright notice.
config,rtems_get_target_hash() - Gets the RTEMS target hash.
config,rtems_get_version_string() - Gets the RTEMS version string.
config,rtems_configuration_get_do_zero_of_workspace() - Indicates if the
config,RTEMS Workspace is configured to be zeroed during system initialization for
config,this application.
config,rtems_configuration_get_idle_task_stack_size() - Gets the IDLE task
config,stack size in bytes of this application.
config,rtems_configuration_get_idle_task() - Gets the IDLE task body of
config,this application.
config,rtems_configuration_get_interrupt_stack_size() - Gets the interrupt
config,stack size in bytes of this application.
config,rtems_configuration_get_maximum_barriers() - Gets the resource
config,number of Barrier Manager objects configured for this
config,application.
config,rtems_configuration_get_maximum_extensions() - Gets the resource
config,number of User Extensions Manager objects configured for this
config,application.
config,rtems_configuration_get_maximum_message_queues() - Gets the resource
config,number of Message Manager objects configured for this
config,application.
config,rtems_configuration_get_maximum_partitions() - Gets the resource
config,number of Partition Manager objects configured for this application.
config,rtems_configuration_get_maximum_periods() - Gets the resource
config,number of Rate Monotonic Manager objects configured for this
config,application.
config,rtems_configuration_get_maximum_ports() - Gets the resource number
config,of Dual-Ported Memory Manager objects configured for this application.
config,rtems_configuration_get_maximum_processors() - Gets the maximum
config,number of processors configured for this application.
config,rtems_configuration_get_maximum_regions() - Gets the resource
config,number of Region Manager objects configured for this
config,application.
config,rtems_configuration_get_maximum_semaphores() - Gets the resource
config,number of Semaphore Manager objects configured for this application.
config,rtems_configuration_get_maximum_tasks() - Gets the resource number
config,of Task Manager objects configured for this application.
config,rtems_configuration_get_maximum_timers() - Gets the resource number
config,of Timer Manager objects configured for this application.
config,rtems_configuration_get_microseconds_per_tick() - Gets the number of
config,microseconds per clock tick configured for this application.
config,rtems_configuration_get_milliseconds_per_tick() - Gets the number of
config,milliseconds per clock tick configured for this application.
config,rtems_configuration_get_nanoseconds_per_tick() - Gets the number of
config,microseconds per clock tick configured for this application.
config,rtems_configuration_get_number_of_initial_extensions() - Gets the
config,number of initial extensions configured for this application.
config,rtems_configuration_get_stack_allocate_for_idle_hook() - Gets the task
config,stack allocator allocate hook used to allocate the stack of each IDLE
config,task configured for this application.
config,rtems_configuration_get_stack_allocate_hook() - Gets the task stack
config,allocator allocate hook configured for this application.
config,rtems_configuration_get_stack_allocate_init_hook() - Gets the task
config,stack allocator initialization hook configured for this application.
config,rtems_configuration_get_stack_allocator_avoids_work_space() -
config,Indicates if the task stack allocator is configured to avoid the RTEMS
config,Workspace for this application.
config,rtems_configuration_get_stack_free_hook() - Gets the task stack
config,allocator free hook configured for this application.
config,rtems_configuration_get_stack_space_size() - Gets the configured
config,size in bytes of the memory space used to allocate thread stacks for this
config,application.
config,rtems_configuration_get_ticks_per_timeslice() - Gets the clock ticks
config,per timeslice configured for this application.
config,rtems_configuration_get_unified_work_area() - Indicates if the RTEMS
config,Workspace and C Program Heap are configured to be unified for this
config,application.
config,rtems_configuration_get_user_extension_table() - Gets the initial
config,extensions table configured for this application.
config,rtems_configuration_get_user_multiprocessing_table() - Gets the MPCI
config,configuration table configured for this application.
config,rtems_configuration_get_work_space_size() - Gets the RTEMS Workspace
config,size in bytes configured for this application.
config,rtems_configuration_get_rtems_api_configuration() - Gets the Classic
config,API Configuration Table of this application.
config,rtems_resource_is_unlimited() - Indicates if the resource is
config,unlimited.
config,rtems_resource_maximum_per_allocation() - Gets the maximum number
config,per allocation of a resource number.
config,rtems_resource_unlimited() - Augments the resource number so that
config,it indicates an unlimited resource.
config,"© Copyright 1988, 2024 RTEMS Project and contributors."
dual-ported-memory,A dual-ported memory area (DPMA) is an contiguous block of RAM owned by a
dual-ported-memory,particular processor but which can be accessed by other processors in the
dual-ported-memory,"system.  The owner accesses the memory using internal addresses, while other"
dual-ported-memory,processors must use external addresses.  RTEMS defines a port as a particular
dual-ported-memory,mapping of internal and external addresses.
dual-ported-memory,There are two system configurations in which dual-ported memory is commonly
dual-ported-memory,found.  The first is tightly-coupled multiprocessor computer systems where the
dual-ported-memory,dual-ported memory is shared between all nodes and is used for inter-node
dual-ported-memory,communication.  The second configuration is computer systems with intelligent
dual-ported-memory,peripheral controllers.  These controllers typically utilize the DPMA for
dual-ported-memory,high-performance data transfers.
dual-ported-memory,"© Copyright 1988, 2024 RTEMS Project and contributors."
dual-ported-memory,The Dual-Ported Memory Manager provides a mechanism for converting addresses
dual-ported-memory,between internal and external representations for multiple dual-ported memory
dual-ported-memory,areas (DPMA). The directives provided by the Dual-Ported Memory Manager are:
dual-ported-memory,rtems_port_create() - Creates a port.
dual-ported-memory,rtems_port_ident() - Identifies a port by the object name.
dual-ported-memory,rtems_port_delete() - Deletes the port.
dual-ported-memory,rtems_port_external_to_internal() - Converts the external address
dual-ported-memory,to the internal address.
dual-ported-memory,rtems_port_internal_to_external() - Converts the internal address
dual-ported-memory,to the external address.
dual-ported-memory,rtems_port_create() - Creates a port.
dual-ported-memory,rtems_port_ident() - Identifies a port by the object name.
dual-ported-memory,rtems_port_delete() - Deletes the port.
dual-ported-memory,rtems_port_external_to_internal() - Converts the external address
dual-ported-memory,to the internal address.
dual-ported-memory,rtems_port_internal_to_external() - Converts the internal address
dual-ported-memory,to the external address.
dual-ported-memory,"© Copyright 1988, 2024 RTEMS Project and contributors."
event,An event flag is used by a task (or ISR) to inform another task of the
event,occurrence of a significant situation.  Thirty-two event flags are associated
event,with each task.  A collection of one or more event flags is referred to as an
event,event set.  The data type rtems_event_set is used to manage event sets.
event,The application developer should remember the following key characteristics of
event,event operations when utilizing the event manager:
event,Events provide a simple synchronization facility.
event,Events are aimed at tasks.
event,Tasks can wait on more than one event simultaneously.
event,Events are independent of one another.
event,Events do not hold or transport data.
event,"Events are not queued.  In other words, if an event is sent more than once to"
event,"a task before being received, the second and subsequent send operations to"
event,that same task have no effect.
event,Events provide a simple synchronization facility.
event,Events are aimed at tasks.
event,Tasks can wait on more than one event simultaneously.
event,Events are independent of one another.
event,Events do not hold or transport data.
event,"Events are not queued.  In other words, if an event is sent more than once to"
event,"a task before being received, the second and subsequent send operations to"
event,that same task have no effect.
event,An event set is posted when it is directed (or sent) to a task.  A pending
event,event is an event that has been posted but not received.  An event condition is
event,used to specify the event set which the task desires to receive and the
event,algorithm which will be used to determine when the request is satisfied. An
event,event condition is satisfied based upon one of two algorithms which are
event,selected by the user.  The RTEMS_EVENT_ANY algorithm states that an event
event,condition is satisfied when at least a single requested event is posted.  The
event,RTEMS_EVENT_ALL algorithm states that an event condition is satisfied when
event,every requested event is posted.
event,An event set or condition is built by a bitwise OR of the desired events.  The
event,set of valid events is RTEMS_EVENT_0 through RTEMS_EVENT_31.  If an
event,"event is not explicitly specified in the set or condition, then it is not"
event,"present.  Events are specifically designed to be mutually exclusive, therefore"
event,bitwise OR and addition operations are equivalent as long as each event appears
event,exactly once in the event set list.
event,"For example, when sending the event set consisting of RTEMS_EVENT_6,"
event,"RTEMS_EVENT_15, and RTEMS_EVENT_31, the event parameter to the"
event,rtems_event_send directive should be RTEMS_EVENT_6 | RTEMS_EVENT_15 |
event,RTEMS_EVENT_31.
event,"In general, an option is built by a bitwise OR of the desired option"
event,components.  The set of valid options for the rtems_event_receive directive
event,are listed in the following table:
event,RTEMS_WAIT
event,task will wait for event (default)
event,RTEMS_NO_WAIT
event,task should not wait
event,RTEMS_EVENT_ALL
event,return after all events (default)
event,RTEMS_EVENT_ANY
event,return after any events
event,RTEMS_WAIT
event,task will wait for event (default)
event,RTEMS_NO_WAIT
event,task should not wait
event,RTEMS_EVENT_ALL
event,return after all events (default)
event,RTEMS_EVENT_ANY
event,return after any events
event,"Option values are specifically designed to be mutually exclusive, therefore"
event,bitwise OR and addition operations are equivalent as long as each option
event,appears exactly once in the component list.  An option listed as a default is
event,"not required to appear in the option list, although it is a good programming"
event,"practice to specify default options.  If all defaults are desired, the option"
event,RTEMS_DEFAULT_OPTIONS should be specified on this call.
event,This example demonstrates the option parameter needed to poll for all events in
event,a particular event condition to arrive.  The option parameter passed to the
event,rtems_event_receive directive should be either RTEMS_EVENT_ALL |
event,RTEMS_NO_WAIT or RTEMS_NO_WAIT.  The option parameter can be set to
event,RTEMS_NO_WAIT because RTEMS_EVENT_ALL is the default condition for
event,rtems_event_receive.
event,"© Copyright 1988, 2024 RTEMS Project and contributors."
event,The Event Manager provides a high performance method of inter-task
event,communication and synchronization. The directives provided by the Event Manager
event,are:
event,rtems_event_send() - Sends the event set to the task.
event,rtems_event_receive() - Receives or gets an event set from the
event,calling task.
event,rtems_event_send() - Sends the event set to the task.
event,rtems_event_receive() - Receives or gets an event set from the
event,calling task.
event,"© Copyright 1988, 2024 RTEMS Project and contributors."
fatal-error,The fatal error manager is called upon detection of an irrecoverable error
fatal-error,condition by either RTEMS or the application software.  Fatal errors are also
fatal-error,used in case it is difficult or impossible to return an error condition by
fatal-error,"other means, e.g. a return value of a directive call.  Fatal errors can be"
fatal-error,"detected from various sources, for example"
fatal-error,"the executive (RTEMS),"
fatal-error,"support libraries,"
fatal-error,"user system code,"
fatal-error,"user application code, and"
fatal-error,"processor interrupts and exceptions (data abort, instruction prefetch errors,"
fatal-error,"ECC errors, spurious interrupts, etc.)."
fatal-error,"the executive (RTEMS),"
fatal-error,"support libraries,"
fatal-error,"user system code,"
fatal-error,"user application code, and"
fatal-error,"processor interrupts and exceptions (data abort, instruction prefetch errors,"
fatal-error,"ECC errors, spurious interrupts, etc.)."
fatal-error,RTEMS automatically invokes the fatal error manager upon detection of an error
fatal-error,"it considers to be fatal.  Similarly, the user should invoke the fatal error"
fatal-error,manager upon detection of a fatal error.
fatal-error,Each user extensions set may include a fatal error handler.  The fatal
fatal-error,error handler in the initial extension sets can be used to provide
fatal-error,access to debuggers and monitors which may be present on the target hardware.
fatal-error,"If any user-supplied fatal error handlers are installed, the fatal error"
fatal-error,"manager will invoke them.  Usually, the board support package provides a fatal"
fatal-error,error extension which resets the board.  If no user handlers are configured or
fatal-error,"if all the user handler return control to the fatal error manager, then"
fatal-error,the CPU port provided idle loop executes.
fatal-error,The _Terminate() handler is invoked to terminate the system.  It is
fatal-error,called by all services which determine that a system termination is required.
fatal-error,"For example, it is called by all higher level directives which announce a fatal"
fatal-error,"error, see Announcing a Fatal Error."
fatal-error,The first action of the system termination handler is to disable maskable
fatal-error,interrupts.  This ensures that interrupts on this processor do not interfere
fatal-error,with the system termination procedure.  This reduces the likelihood to end up
fatal-error,in a recursive system termination procedure.
fatal-error,The second action of the system termination handler is to call the fatal
fatal-error,extensions of the user extensions.
fatal-error,The fatal extensions are called with three parameters:
fatal-error,"the fatal source,"
fatal-error,"a legacy parameter which is always set to false, and"
fatal-error,an error code with a fatal source dependent content.
fatal-error,"the fatal source,"
fatal-error,"a legacy parameter which is always set to false, and"
fatal-error,an error code with a fatal source dependent content.
fatal-error,The fatal extensions of the initial extension sets are invoked first.
fatal-error,"For them, the following execution environment is required"
fatal-error,"a valid stack pointer and enough stack space,"
fatal-error,"a valid code memory, and"
fatal-error,valid read-only data.
fatal-error,"a valid stack pointer and enough stack space,"
fatal-error,"a valid code memory, and"
fatal-error,valid read-only data.
fatal-error,"In uniprocessor configurations, the read-write data (including .bss"
fatal-error,"segment) is not required.  In SMP configurations, however, the read-write data"
fatal-error,must have been initialized to determine the state of the other processors and
fatal-error,request them to shut-down if necessary.  The board support package (BSP) may
fatal-error,install an initial extension that performs a system reset.  See the BSP
fatal-error,documentation in the RTEMS User Manual for more information how the system
fatal-error,reset is done.  The BSP provided fatal extension can be disabled by the
fatal-error,CONFIGURE_DISABLE_BSP_SETTINGS application configuration option.  It is
fatal-error,recommended to provide an application-specific fatal extension using the
fatal-error,CONFIGURE_INITIAL_EXTENSIONS application configuration option.
fatal-error,"In certain error conditions, it may be unreliable to carry out the following"
fatal-error,steps of the termination procedure since the read-write data may be corrupt.
fatal-error,One of the fatal extensions of the initial extension set should reset the
fatal-error,system to stop the system termination procedure.
fatal-error,"After invoking the fatal extensions of the initial extension sets, the"
fatal-error,fatal extensions of the dynamic extension sets are invoked.  For this
fatal-error,procedure valid read-write data is required.
fatal-error,The last action of the system termination handler is to execute the CPU port
fatal-error,"provided idle loop with maskable interrupts disabled.  Please note, that"
fatal-error,properly configured applications should not reach this point.
fatal-error,The following fatal sources are defined for RTEMS via the
fatal-error,rtems_fatal_source enumeration.  Each symbolic name has the
fatal-error,corresponding numeric fatal source in parenthesis.
fatal-error,Errors of the core operating system.  See Internal Error Codes.
fatal-error,Errors of the Classic API.
fatal-error,Errors of the POSIX API.
fatal-error,Fatal source for the block device cache.  See
fatal-error,rtems_bdbuf_fatal_code.
fatal-error,Fatal source for application-specific errors.  The fatal code is
fatal-error,application-specific.
fatal-error,Fatal source of exit().  The fatal code is the exit()
fatal-error,status code.
fatal-error,Fatal source for BSP errors.  The fatal codes are defined in
fatal-error,<bsp/fatal.h>.  Examples are interrupt and exception
fatal-error,initialization.  See bsp_fatal_code and bsp_fatal().
fatal-error,Fatal source of assert().  The fatal code is the pointer value
fatal-error,of the assert context.  See rtems_assert_context.
fatal-error,Fatal source of the stack checker.  The fatal code is the object name of
fatal-error,the executing task.
fatal-error,Fatal source of the exceptions.  The fatal code is the pointer value of the
fatal-error,exception frame pointer.  See rtems_exception_frame and
fatal-error,rtems_exception_frame_print.
fatal-error,Fatal source of SMP domain.  See SMP_Fatal_code.
fatal-error,"Fatal source of rtems_panic(), see rtems_panic."
fatal-error,Fatal source for invalid C program heap frees via free().  The
fatal-error,fatal code is the bad pointer.
fatal-error,Fatal source for heap errors.  The fatal code is the address to a heap error
fatal-error,context.  See Heap_Error_context.
fatal-error,The following error codes are defined for the INTERNAL_ERROR_CORE
fatal-error,fatal source.  Each symbolic name has the corresponding numeric error code in
fatal-error,parenthesis.
fatal-error,There is not enough memory for the workspace.  This fatal error may occur
fatal-error,during system initialization.  It is an application configuration error.
fatal-error,A non-POSIX thread entry function returned.  This is an API usage error.
fatal-error,An example code to provoke this fatal error is:
fatal-error,This fatal error can only occur on MPCI configurations.  The MPCI nodes or
fatal-error,global objects configuration is inconsistent.  This fatal error may occur
fatal-error,during system initialization.  It is an application configuration error.
fatal-error,This fatal error can only occur on MPCI configurations.  The own MPCI node
fatal-error,number is invalid.  This fatal error may occur during system
fatal-error,initialization.  It is an application configuration error.
fatal-error,This fatal error can only occur on MPCI configurations.  There is no MPCI
fatal-error,configuration table.  This fatal error may occur during system
fatal-error,initialization.  It is an application configuration error.
fatal-error,This fatal error can only occur on MPCI configurations.  The MPCI server
fatal-error,thread received a bad packet.
fatal-error,This fatal error can only occur on MPCI configurations.  The MPCI packet
fatal-error,pool is empty.  It is an application configuration error.
fatal-error,This fatal error can only occur on MPCI configurations.  The MPCI global
fatal-error,objects pool is empty.  It is an application configuration error.
fatal-error,This fatal error can only occur on MPCI configurations.  The MPCI thread
fatal-error,proxy pool is empty.  It is an application configuration error.
fatal-error,This fatal error can only occur on MPCI configurations.  The system cannot
fatal-error,find the global object for a specific object identifier.  In case this
fatal-error,"happens, then this is probably an operating system bug."
fatal-error,There is not enough memory for the C program heap.  This fatal error may
fatal-error,occur during system initialization.  It is an application configuration
fatal-error,error.
fatal-error,The use of _CPU_ISR_install_vector() is illegal on this system.
fatal-error,This fatal error can only occur on debug configurations.  It happens in
fatal-error,case a thread which owns mutexes is deleted.  Mutexes owned by a deleted
fatal-error,thread are in an inconsistent state.
fatal-error,An RTEMS initialization task entry function is NULL.  This fatal error may
fatal-error,occur during system initialization.  It is an application configuration
fatal-error,error.
fatal-error,A deadlock was detected during a thread queue enqueue operation.
fatal-error,This fatal error can only happen in SMP configurations.  It is not allowed
fatal-error,"to obtain MrsP semaphores in a context with thread dispatching disabled,"
fatal-error,for example interrupt context.
fatal-error,An example code to provoke this fatal error is:
fatal-error,It is illegal to call blocking operating system services with thread
fatal-error,"dispatching disabled, for example in interrupt context."
fatal-error,An example code to provoke this fatal error is:
fatal-error,"In SMP configurations, it is a fatal error to call blocking operating"
fatal-error,"system with interrupts disabled, since this prevents delivery of"
fatal-error,inter-processor interrupts.  This could lead to executing threads which are
fatal-error,not allowed to execute resulting in undefined system behaviour.
fatal-error,"Some CPU ports, for example the ARM Cortex-M port, have a similar problem,"
fatal-error,since the interrupt state is not a part of the thread context.
fatal-error,This fatal error is detected in the operating system core function
fatal-error,_Thread_Do_dispatch() responsible to carry out a thread dispatch.
fatal-error,An example code to provoke this fatal error is:
fatal-error,The creation of the RTEMS initialization task failed.  This fatal error may
fatal-error,occur during system initialization.  It is an application configuration
fatal-error,error.
fatal-error,The creation of the POSIX initialization thread failed.  This fatal error
fatal-error,may occur during system initialization.  It is an application configuration
fatal-error,error.
fatal-error,Open of the standard output file descriptor failed or resulted in an
fatal-error,unexpected file descriptor number.  This fatal error may occur during
fatal-error,system initialization.  It is an application configuration error.
fatal-error,Open of the standard error file descriptor failed or resulted in an
fatal-error,unexpected file descriptor number.  This fatal error may occur during
fatal-error,system initialization.  It is an application configuration error.
fatal-error,"The floating point unit was used illegally, for example in interrupt"
fatal-error,context on some architectures.
fatal-error,A getentropy() system call failed in one of the ARC4RANDOM(3) functions.  This fatal error can
fatal-error,only be fixed with a different implementation of getentropy().
fatal-error,This fatal error may happen during workspace initialization.  There is not
fatal-error,"enough memory available to populate the per-CPU data areas, see"
fatal-error,<rtems/score/percpudata.h>.
fatal-error,This fatal error may happen during system initialization.  The actual
fatal-error,thread-local storage (TLS) size of the application exceeds the configured
fatal-error,"maximum, see"
fatal-error,CONFIGURE_MAXIMUM_THREAD_LOCAL_STORAGE_SIZE.
fatal-error,You can get the thread-local storage size of an application using the RTEMS
fatal-error,tool rtems-execinfo.
fatal-error,The construction of the RTEMS initialization task failed.  This fatal error
fatal-error,may occur during system initialization.  It is an application configuration
fatal-error,error.
fatal-error,The creation of an IDLE task failed.  This fatal error may occur during
fatal-error,system initialization.  It happens if a task create extension fails for an
fatal-error,IDLE task.
fatal-error,There was not enough memory available to allocate an IDLE task stack.  This
fatal-error,fatal error may occur during system initialization.  It is an application
fatal-error,configuration error.
fatal-error,The task stack size of an IDLE task would have been less than the
fatal-error,"configured stack size for IDLE tasks, see"
fatal-error,CONFIGURE_IDLE_TASK_STACK_SIZE.
fatal-error,This fatal error may occur during system initialization.  It is an
fatal-error,application configuration error.
fatal-error,This fatal error may be caused by rtems_cache_disable_data() if
fatal-error,the data cache cannot be disabled for a particular target or
fatal-error,configuration.  The data cache may be necessary to provide atomic
fatal-error,"operations.  In SMP configurations, the data cache may be required to"
fatal-error,ensure data coherency.  See the BSP documentation in the RTEMS User
fatal-error,Manual for more information.
fatal-error,"© Copyright 1988, 2024 RTEMS Project and contributors."
fatal-error,The Fatal Error Manager processes all fatal or irrecoverable errors and other
fatal-error,sources of system termination (for example after exit()).  Fatal errors
fatal-error,are identified by the fatal source and code pair. The directives provided by
fatal-error,the Fatal Error Manager are:
fatal-error,rtems_fatal() - Invokes the fatal error handler.
fatal-error,rtems_panic() - Prints the message and invokes the fatal error
fatal-error,handler.
fatal-error,rtems_shutdown_executive() - Invokes the fatal error handler.
fatal-error,rtems_exception_frame_print() - Prints the exception frame.
fatal-error,rtems_fatal_source_text() - Returns a descriptive text for the
fatal-error,fatal source.
fatal-error,rtems_internal_error_text() - Returns a descriptive text for the
fatal-error,internal error code.
fatal-error,rtems_fatal_error_occurred() - Invokes the fatal error handler.
fatal-error,rtems_fatal() - Invokes the fatal error handler.
fatal-error,rtems_panic() - Prints the message and invokes the fatal error
fatal-error,handler.
fatal-error,rtems_shutdown_executive() - Invokes the fatal error handler.
fatal-error,rtems_exception_frame_print() - Prints the exception frame.
fatal-error,rtems_fatal_source_text() - Returns a descriptive text for the
fatal-error,fatal source.
fatal-error,rtems_internal_error_text() - Returns a descriptive text for the
fatal-error,internal error code.
fatal-error,rtems_fatal_error_occurred() - Invokes the fatal error handler.
fatal-error,"© Copyright 1988, 2024 RTEMS Project and contributors."
initialization,Initialization task(s) are the mechanism by which RTEMS transfers initial
initialization,control to the user’s application.  Initialization tasks differ from other
initialization,application tasks in that they are defined in the User Initialization Tasks
initialization,Table and automatically created and started by RTEMS as part of its
initialization,initialization sequence.  Since the initialization tasks are scheduled using
initialization,"the same algorithm as all other RTEMS tasks, they must be configured at a"
initialization,priority and mode which will ensure that they will complete execution before
initialization,other application tasks execute.  Although there is no upper limit on the
initialization,"number of initialization tasks, an application is required to define at least"
initialization,one.
initialization,A typical initialization task will create and start the static set of
initialization,application tasks.  It may also create any other objects used by the
initialization,application.  Initialization tasks which only perform initialization should
initialization,delete themselves upon completion to free resources for other tasks.
initialization,Initialization tasks may transform themselves into a “normal” application task.
initialization,This transformation typically involves changing priority and execution mode.
initialization,RTEMS does not automatically delete the initialization tasks.
initialization,The Idle Task is the lowest priority task in a system and executes only when no
initialization,other task is ready to execute.  The default implementation of this task
initialization,consists of an infinite loop. RTEMS allows the Idle Task body to be replaced by
initialization,"a CPU specific implementation, a BSP specific implementation or an application"
initialization,specific implementation.
initialization,The Idle Task is preemptible and WILL be preempted when any other task is
initialization,made ready to execute.  This characteristic is critical to the overall behavior
initialization,of any application.
initialization,System initialization errors are fatal.  See Internal Error Codes.
initialization,"© Copyright 1988, 2024 RTEMS Project and contributors."
initialization,The Initialization Manager is responsible for initializing the system.
initialization,The system initialization includes the initialization of the Board Support
initialization,"Package, RTEMS, device drivers, the root filesystem, and the application. The"
initialization,Fatal Error Manager is responsible for the system shutdown. The
initialization,directives provided by the Initialization Manager are:
initialization,rtems_initialize_executive() - Initializes the system and starts
initialization,multitasking.
initialization,rtems_initialize_executive() - Initializes the system and starts
initialization,multitasking.
initialization,"© Copyright 1988, 2024 RTEMS Project and contributors."
interrupt,The interrupt manager allows the application to connect a function to a
interrupt,"hardware interrupt vector.  When an interrupt occurs, the processor will"
interrupt,automatically vector to RTEMS.  RTEMS saves and restores all registers which
interrupt,are not preserved by the normal C calling convention for the target processor
interrupt,and invokes the user’s ISR.  The user’s ISR is responsible for processing the
interrupt,"interrupt, clearing the interrupt if necessary, and device specific"
interrupt,manipulation.
interrupt,The rtems_interrupt_catch directive connects a procedure to an interrupt
interrupt,vector.  The vector number is managed using the rtems_vector_number data
interrupt,type.
interrupt,The interrupt service routine is assumed to abide by these conventions and have
interrupt,a prototype similar to the following:
interrupt,The vector number argument is provided by RTEMS to allow the application to
interrupt,identify the interrupt source.  This could be used to allow a single routine to
interrupt,"service interrupts from multiple instances of the same device.  For example, a"
interrupt,single routine could service interrupts from multiple serial ports and use the
interrupt,vector number to identify which port requires servicing.
interrupt,"To minimize the masking of lower or equal priority level interrupts, the ISR"
interrupt,should perform the minimum actions required to service the interrupt.  Other
interrupt,non-essential actions should be handled by application tasks.  Once the user’s
interrupt,"ISR has completed, it returns control to the RTEMS interrupt manager which will"
interrupt,perform task dispatching and restore the registers saved before the ISR was
interrupt,invoked.
interrupt,The RTEMS interrupt manager guarantees that proper task scheduling and
interrupt,dispatching are performed at the conclusion of an ISR.  A system call made by
interrupt,the ISR may have readied a task of higher priority than the interrupted task.
interrupt,"Therefore, when the ISR completes, the postponed dispatch processing must be"
interrupt,performed.  No dispatch processing is performed as part of directives which
interrupt,have been invoked by an ISR.
interrupt,Applications must adhere to the following rule if proper task scheduling and
interrupt,dispatching is to be performed:
interrupt,Note
interrupt,The interrupt manager must be used for all ISRs which may be interrupted by
interrupt,the highest priority ISR which invokes an RTEMS directive.
interrupt,Consider a processor which allows a numerically low interrupt level to
interrupt,"interrupt a numerically greater interrupt level.  In this example, if an RTEMS"
interrupt,"directive is used in a level 4 ISR, then all ISRs which execute at levels 0"
interrupt,through 4 must use the interrupt manager.
interrupt,Interrupts are nested whenever an interrupt occurs during the execution of
interrupt,another ISR.  RTEMS supports efficient interrupt nesting by allowing the nested
interrupt,ISRs to terminate without performing any dispatch processing.  Only when the
interrupt,outermost ISR terminates will the postponed dispatching occur.
interrupt,Many processors support multiple interrupt levels or priorities.  The exact
interrupt,number of interrupt levels is processor dependent.  RTEMS internally supports
interrupt,256 interrupt levels which are mapped to the processor’s interrupt levels.  For
interrupt,specific information on the mapping between RTEMS and the target processor’s
interrupt,"interrupt levels, refer to the Interrupt Processing chapter of the Applications"
interrupt,Supplement document for a specific target processor.
interrupt,"During the execution of directive calls, critical sections of code may be"
interrupt,"executed.  When these sections are encountered, RTEMS disables all maskable"
interrupt,interrupts before the execution of the section and restores them to the
interrupt,previous level upon completion of the section.  RTEMS has been optimized to
interrupt,ensure that interrupts are disabled for a minimum length of time.  The maximum
interrupt,length of time interrupts are disabled by RTEMS is processor dependent and is
interrupt,detailed in the Timing Specification chapter of the Applications Supplement
interrupt,document for a specific target processor.
interrupt,"Non-maskable interrupts (NMI) cannot be disabled, and ISRs which execute at"
interrupt,"this level MUST NEVER issue RTEMS system calls.  If a directive is invoked,"
interrupt,unpredictable results may occur due to the inability of RTEMS to protect its
interrupt,"critical sections.  However, ISRs that make no system calls may safely execute"
interrupt,as non-maskable interrupts.
interrupt,"© Copyright 1988, 2024 RTEMS Project and contributors."
interrupt,Any real-time executive must provide a mechanism for quick response to
interrupt,externally generated interrupts to satisfy the critical time constraints of the
interrupt,application.  The Interrupt Manager provides this mechanism for RTEMS. This
interrupt,manager permits quick interrupt response times by providing the critical
interrupt,ability to alter task execution which allows a task to be preempted upon exit
interrupt,from an ISR. The directives provided by the Interrupt Manager are:
interrupt,rtems_interrupt_catch() - Establishes an interrupt service
interrupt,routine.
interrupt,rtems_interrupt_disable() - Disables the maskable interrupts on
interrupt,the current processor.
interrupt,rtems_interrupt_enable() - Restores the previous interrupt level
interrupt,on the current processor.
interrupt,rtems_interrupt_flash() - Flashes interrupts on the current
interrupt,processor.
interrupt,rtems_interrupt_local_disable() - Disables the maskable interrupts
interrupt,on the current processor.
interrupt,rtems_interrupt_local_enable() - Restores the previous interrupt
interrupt,level on the current processor.
interrupt,rtems_interrupt_is_in_progress() - Checks if an ISR is in progress
interrupt,on the current processor.
interrupt,rtems_interrupt_lock_initialize() - Initializes the ISR lock.
interrupt,rtems_interrupt_lock_destroy() - Destroys the ISR lock.
interrupt,rtems_interrupt_lock_acquire() - Acquires the ISR lock.
interrupt,rtems_interrupt_lock_release() - Releases the ISR lock.
interrupt,rtems_interrupt_lock_acquire_isr() - Acquires the ISR lock from
interrupt,within an ISR.
interrupt,rtems_interrupt_lock_release_isr() - Releases the ISR lock from
interrupt,within an ISR.
interrupt,rtems_interrupt_lock_interrupt_disable() - Disables maskable
interrupt,interrupts on the current processor.
interrupt,RTEMS_INTERRUPT_LOCK_DECLARE() - Declares an ISR lock object.
interrupt,RTEMS_INTERRUPT_LOCK_DEFINE() - Defines an ISR lock object.
interrupt,RTEMS_INTERRUPT_LOCK_INITIALIZER() - Statically initializes an ISR
interrupt,lock object.
interrupt,RTEMS_INTERRUPT_LOCK_MEMBER() - Defines an ISR lock member.
interrupt,RTEMS_INTERRUPT_LOCK_REFERENCE() - Defines an ISR lock object
interrupt,reference.
interrupt,RTEMS_INTERRUPT_ENTRY_INITIALIZER() - Statically initializes an
interrupt,interrupt entry object.
interrupt,rtems_interrupt_entry_initialize() - Initializes the interrupt
interrupt,entry.
interrupt,rtems_interrupt_entry_install() - Installs the interrupt entry at
interrupt,the interrupt vector.
interrupt,rtems_interrupt_entry_remove() - Removes the interrupt entry from
interrupt,the interrupt vector.
interrupt,rtems_interrupt_handler_install() - Installs the interrupt handler
interrupt,routine and argument at the interrupt vector.
interrupt,rtems_interrupt_handler_remove() - Removes the interrupt handler
interrupt,routine and argument from the interrupt vector.
interrupt,rtems_interrupt_vector_is_enabled() - Checks if the interrupt
interrupt,vector is enabled.
interrupt,rtems_interrupt_vector_enable() - Enables the interrupt vector.
interrupt,rtems_interrupt_vector_disable() - Disables the interrupt vector.
interrupt,rtems_interrupt_is_pending() - Checks if the interrupt is pending.
interrupt,rtems_interrupt_raise() - Raises the interrupt vector.
interrupt,rtems_interrupt_raise_on() - Raises the interrupt vector on the
interrupt,processor.
interrupt,rtems_interrupt_clear() - Clears the interrupt vector.
interrupt,rtems_interrupt_get_priority() - Gets the priority of the
interrupt,interrupt vector.
interrupt,rtems_interrupt_set_priority() - Sets the priority of the
interrupt,interrupt vector.
interrupt,rtems_interrupt_get_affinity() - Gets the processor affinity set
interrupt,of the interrupt vector.
interrupt,rtems_interrupt_set_affinity() - Sets the processor affinity set
interrupt,of the interrupt vector.
interrupt,rtems_interrupt_get_attributes() - Gets the attributes of the
interrupt,interrupt vector.
interrupt,rtems_interrupt_handler_iterate() - Iterates over all interrupt
interrupt,handler installed at the interrupt vector.
interrupt,rtems_interrupt_server_initialize() - Initializes the interrupt
interrupt,server tasks.
interrupt,rtems_interrupt_server_create() - Creates an interrupt server.
interrupt,rtems_interrupt_server_handler_install() - Installs the interrupt
interrupt,handler routine and argument at the interrupt vector on the interrupt server.
interrupt,rtems_interrupt_server_handler_remove() - Removes the interrupt
interrupt,handler routine and argument from the interrupt vector and the interrupt
interrupt,server.
interrupt,rtems_interrupt_server_set_affinity() - Sets the processor affinity
interrupt,of the interrupt server.
interrupt,rtems_interrupt_server_delete() - Deletes the interrupt server.
interrupt,rtems_interrupt_server_suspend() - Suspends the interrupt server.
interrupt,rtems_interrupt_server_resume() - Resumes the interrupt server.
interrupt,rtems_interrupt_server_move() - Moves the interrupt handlers
interrupt,installed at the interrupt vector and the source interrupt server to the
interrupt,destination interrupt server.
interrupt,rtems_interrupt_server_handler_iterate() - Iterates over all
interrupt,interrupt handler installed at the interrupt vector and interrupt server.
interrupt,rtems_interrupt_server_entry_initialize() - Initializes the
interrupt,interrupt server entry.
interrupt,rtems_interrupt_server_action_prepend() - Prepends the interrupt
interrupt,server action to the list of actions of the interrupt server entry.
interrupt,rtems_interrupt_server_entry_destroy() - Destroys the interrupt
interrupt,server entry.
interrupt,rtems_interrupt_server_entry_submit() - Submits the interrupt
interrupt,server entry to be serviced by the interrupt server.
interrupt,rtems_interrupt_server_entry_move() - Moves the interrupt server
interrupt,entry to the interrupt server.
interrupt,rtems_interrupt_server_request_initialize() - Initializes the
interrupt,interrupt server request.
interrupt,rtems_interrupt_server_request_set_vector() - Sets the interrupt
interrupt,vector in the interrupt server request.
interrupt,rtems_interrupt_server_request_destroy() - Destroys the interrupt
interrupt,server request.
interrupt,rtems_interrupt_server_request_submit() - Submits the interrupt
interrupt,server request to be serviced by the interrupt server.
interrupt,rtems_interrupt_catch() - Establishes an interrupt service
interrupt,routine.
interrupt,rtems_interrupt_disable() - Disables the maskable interrupts on
interrupt,the current processor.
interrupt,rtems_interrupt_enable() - Restores the previous interrupt level
interrupt,on the current processor.
interrupt,rtems_interrupt_flash() - Flashes interrupts on the current
interrupt,processor.
interrupt,rtems_interrupt_local_disable() - Disables the maskable interrupts
interrupt,on the current processor.
interrupt,rtems_interrupt_local_enable() - Restores the previous interrupt
interrupt,level on the current processor.
interrupt,rtems_interrupt_is_in_progress() - Checks if an ISR is in progress
interrupt,on the current processor.
interrupt,rtems_interrupt_lock_initialize() - Initializes the ISR lock.
interrupt,rtems_interrupt_lock_destroy() - Destroys the ISR lock.
interrupt,rtems_interrupt_lock_acquire() - Acquires the ISR lock.
interrupt,rtems_interrupt_lock_release() - Releases the ISR lock.
interrupt,rtems_interrupt_lock_acquire_isr() - Acquires the ISR lock from
interrupt,within an ISR.
interrupt,rtems_interrupt_lock_release_isr() - Releases the ISR lock from
interrupt,within an ISR.
interrupt,rtems_interrupt_lock_interrupt_disable() - Disables maskable
interrupt,interrupts on the current processor.
interrupt,RTEMS_INTERRUPT_LOCK_DECLARE() - Declares an ISR lock object.
interrupt,RTEMS_INTERRUPT_LOCK_DEFINE() - Defines an ISR lock object.
interrupt,RTEMS_INTERRUPT_LOCK_INITIALIZER() - Statically initializes an ISR
interrupt,lock object.
interrupt,RTEMS_INTERRUPT_LOCK_MEMBER() - Defines an ISR lock member.
interrupt,RTEMS_INTERRUPT_LOCK_REFERENCE() - Defines an ISR lock object
interrupt,reference.
interrupt,RTEMS_INTERRUPT_ENTRY_INITIALIZER() - Statically initializes an
interrupt,interrupt entry object.
interrupt,rtems_interrupt_entry_initialize() - Initializes the interrupt
interrupt,entry.
interrupt,rtems_interrupt_entry_install() - Installs the interrupt entry at
interrupt,the interrupt vector.
interrupt,rtems_interrupt_entry_remove() - Removes the interrupt entry from
interrupt,the interrupt vector.
interrupt,rtems_interrupt_handler_install() - Installs the interrupt handler
interrupt,routine and argument at the interrupt vector.
interrupt,rtems_interrupt_handler_remove() - Removes the interrupt handler
interrupt,routine and argument from the interrupt vector.
interrupt,rtems_interrupt_vector_is_enabled() - Checks if the interrupt
interrupt,vector is enabled.
interrupt,rtems_interrupt_vector_enable() - Enables the interrupt vector.
interrupt,rtems_interrupt_vector_disable() - Disables the interrupt vector.
interrupt,rtems_interrupt_is_pending() - Checks if the interrupt is pending.
interrupt,rtems_interrupt_raise() - Raises the interrupt vector.
interrupt,rtems_interrupt_raise_on() - Raises the interrupt vector on the
interrupt,processor.
interrupt,rtems_interrupt_clear() - Clears the interrupt vector.
interrupt,rtems_interrupt_get_priority() - Gets the priority of the
interrupt,interrupt vector.
interrupt,rtems_interrupt_set_priority() - Sets the priority of the
interrupt,interrupt vector.
interrupt,rtems_interrupt_get_affinity() - Gets the processor affinity set
interrupt,of the interrupt vector.
interrupt,rtems_interrupt_set_affinity() - Sets the processor affinity set
interrupt,of the interrupt vector.
interrupt,rtems_interrupt_get_attributes() - Gets the attributes of the
interrupt,interrupt vector.
interrupt,rtems_interrupt_handler_iterate() - Iterates over all interrupt
interrupt,handler installed at the interrupt vector.
interrupt,rtems_interrupt_server_initialize() - Initializes the interrupt
interrupt,server tasks.
interrupt,rtems_interrupt_server_create() - Creates an interrupt server.
interrupt,rtems_interrupt_server_handler_install() - Installs the interrupt
interrupt,handler routine and argument at the interrupt vector on the interrupt server.
interrupt,rtems_interrupt_server_handler_remove() - Removes the interrupt
interrupt,handler routine and argument from the interrupt vector and the interrupt
interrupt,server.
interrupt,rtems_interrupt_server_set_affinity() - Sets the processor affinity
interrupt,of the interrupt server.
interrupt,rtems_interrupt_server_delete() - Deletes the interrupt server.
interrupt,rtems_interrupt_server_suspend() - Suspends the interrupt server.
interrupt,rtems_interrupt_server_resume() - Resumes the interrupt server.
interrupt,rtems_interrupt_server_move() - Moves the interrupt handlers
interrupt,installed at the interrupt vector and the source interrupt server to the
interrupt,destination interrupt server.
interrupt,rtems_interrupt_server_handler_iterate() - Iterates over all
interrupt,interrupt handler installed at the interrupt vector and interrupt server.
interrupt,rtems_interrupt_server_entry_initialize() - Initializes the
interrupt,interrupt server entry.
interrupt,rtems_interrupt_server_action_prepend() - Prepends the interrupt
interrupt,server action to the list of actions of the interrupt server entry.
interrupt,rtems_interrupt_server_entry_destroy() - Destroys the interrupt
interrupt,server entry.
interrupt,rtems_interrupt_server_entry_submit() - Submits the interrupt
interrupt,server entry to be serviced by the interrupt server.
interrupt,rtems_interrupt_server_entry_move() - Moves the interrupt server
interrupt,entry to the interrupt server.
interrupt,rtems_interrupt_server_request_initialize() - Initializes the
interrupt,interrupt server request.
interrupt,rtems_interrupt_server_request_set_vector() - Sets the interrupt
interrupt,vector in the interrupt server request.
interrupt,rtems_interrupt_server_request_destroy() - Destroys the interrupt
interrupt,server request.
interrupt,rtems_interrupt_server_request_submit() - Submits the interrupt
interrupt,server request to be serviced by the interrupt server.
interrupt,"© Copyright 1988, 2024 RTEMS Project and contributors."
io,Each application utilizing the RTEMS I/O manager must specify the address of a
io,Device Driver Table in its Configuration Table. This table contains each device
io,driver’s entry points that is to be initialised by RTEMS during initialization.
io,Each device driver may contain the following entry points:
io,Initialization
io,Open
io,Close
io,Read
io,Write
io,Control
io,Initialization
io,Open
io,Close
io,Read
io,Write
io,Control
io,"If the device driver does not support a particular entry point, then that entry"
io,in the Configuration Table should be NULL.  RTEMS will return
io,RTEMS_SUCCESSFUL as the executive’s and zero (0) as the device driver’s
io,return code for these device driver entry points.
io,Applications can register and unregister drivers with the RTEMS I/O manager
io,avoiding the need to have all drivers statically defined and linked into this
io,table.
io,The confdefs.h entry CONFIGURE_MAXIMUM_DRIVERS configures the
io,number of driver slots available to the application.
io,Each call to the I/O manager must provide a device’s major and minor numbers as
io,arguments.  The major number is the index of the requested driver’s entry
io,"points in the Device Driver Table, and is used to select a specific device"
io,"driver.  The exact usage of the minor number is driver specific, but is"
io,commonly used to distinguish between a number of devices controlled by the same
io,driver.
io,The data types rtems_device_major_number and rtems_device_minor_number
io,"are used to manipulate device major and minor numbers, respectively."
io,The I/O Manager provides facilities to associate a name with a particular
io,device.  Directives are provided to register the name of a device and to look
io,up the major/minor number pair associated with a device name.
io,"Application developers, as well as device driver developers, must be aware of"
io,the following regarding the RTEMS I/O Manager:
io,A device driver routine executes in the context of the invoking task.  Thus
io,"if the driver blocks, the invoking task blocks."
io,"The device driver is free to change the modes of the invoking task, although"
io,the driver should restore them to their original values.
io,Device drivers may be invoked from ISRs.
io,Only local device drivers are accessible through the I/O manager.
io,"A device driver routine may invoke all other RTEMS directives, including I/O"
io,"directives, on both local and global objects."
io,A device driver routine executes in the context of the invoking task.  Thus
io,"if the driver blocks, the invoking task blocks."
io,"The device driver is free to change the modes of the invoking task, although"
io,the driver should restore them to their original values.
io,Device drivers may be invoked from ISRs.
io,Only local device drivers are accessible through the I/O manager.
io,"A device driver routine may invoke all other RTEMS directives, including I/O"
io,"directives, on both local and global objects."
io,"Although the RTEMS I/O manager provides a framework for device drivers, it"
io,makes no assumptions regarding the construction or operation of a device
io,driver.
io,Board support package and application developers can select wether a device
io,driver is statically entered into the default device table or registered at
io,runtime.
io,Dynamic registration helps applications where:
io,The BSP and kernel libraries are common to a range of applications for a
io,specific target platform. An application may be built upon a common library
io,with all drivers. The application selects and registers the drivers. Uniform
io,driver name lookup protects the application.
io,The type and range of drivers may vary as the application probes a bus during
io,initialization.
io,Support for hot swap bus system such as Compact PCI.
io,Support for runtime loadable driver modules.
io,The BSP and kernel libraries are common to a range of applications for a
io,specific target platform. An application may be built upon a common library
io,with all drivers. The application selects and registers the drivers. Uniform
io,driver name lookup protects the application.
io,The type and range of drivers may vary as the application probes a bus during
io,initialization.
io,Support for hot swap bus system such as Compact PCI.
io,Support for runtime loadable driver modules.
io,"When an application invokes an I/O manager directive, RTEMS determines which"
io,device driver entry point must be invoked.  The information passed by the
io,application to RTEMS is then passed to the correct device driver entry point.
io,RTEMS will invoke each device driver entry point assuming it is compatible with
io,the following prototype:
io,The format and contents of the parameter block are device driver and entry
io,point dependent.
io,It is recommended that a device driver avoid generating error codes which
io,conflict with those used by application components.  A common technique used to
io,generate driver specific error codes is to make the most significant part of
io,the status indicate a driver specific code.
io,RTEMS automatically initializes all device drivers when multitasking is
io,initiated via the rtems_initialize_executive directive.  RTEMS initializes
io,the device drivers by invoking each device driver initialization entry point
io,with the following parameters:
io,the major device number for this device driver.
io,zero.
io,will point to  the Configuration Table.
io,The returned status will be ignored by RTEMS.  If the driver cannot
io,"successfully initialize the device, then it should invoke the"
io,fatal_error_occurred directive.
io,"© Copyright 1988, 2024 RTEMS Project and contributors."
io,The Input/Output (I/O) Manager provides a well-defined mechanism for accessing
io,device drivers and a structured methodology for organizing device drivers. The
io,directives provided by the I/O Manager are:
io,rtems_io_register_driver() - Registers and initializes the device
io,with the specified device driver address table and device major number in the
io,Device Driver Table.
io,rtems_io_unregister_driver() - Removes a device driver specified
io,by the device major number from the Device Driver Table.
io,rtems_io_initialize() - Initializes the device specified by the
io,device major and minor numbers.
io,rtems_io_register_name() - Registers the device specified by the
io,device major and minor numbers in the file system under the specified name.
io,rtems_io_open() - Opens the device specified by the device major
io,and minor numbers.
io,rtems_io_close() - Closes the device specified by the device
io,major and minor numbers.
io,rtems_io_read() - Reads from the device specified by the device
io,major and minor numbers.
io,rtems_io_write() - Writes to the device specified by the device
io,major and minor numbers.
io,rtems_io_control() - Controls the device specified by the device
io,major and minor numbers.
io,rtems_io_register_driver() - Registers and initializes the device
io,with the specified device driver address table and device major number in the
io,Device Driver Table.
io,rtems_io_unregister_driver() - Removes a device driver specified
io,by the device major number from the Device Driver Table.
io,rtems_io_initialize() - Initializes the device specified by the
io,device major and minor numbers.
io,rtems_io_register_name() - Registers the device specified by the
io,device major and minor numbers in the file system under the specified name.
io,rtems_io_open() - Opens the device specified by the device major
io,and minor numbers.
io,rtems_io_close() - Closes the device specified by the device
io,major and minor numbers.
io,rtems_io_read() - Reads from the device specified by the device
io,major and minor numbers.
io,rtems_io_write() - Writes to the device specified by the device
io,major and minor numbers.
io,rtems_io_control() - Controls the device specified by the device
io,major and minor numbers.
io,"© Copyright 1988, 2024 RTEMS Project and contributors."
kernel-character-io,The kernel character input/output support is an extension of the
kernel-character-io,I/O Manager to output characters to the kernel character output
kernel-character-io,device and receive characters from the kernel character input device using a
kernel-character-io,polled and non-blocking implementation.
kernel-character-io,The directives may be used to print debug and test information.  The kernel
kernel-character-io,character input/output support should work even if no Console Driver is
kernel-character-io,"configured, see CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER.  The kernel"
kernel-character-io,character input and output device is provided by the BSP. Applications
kernel-character-io,may change the device. The directives provided by the Kernel Character I/O
kernel-character-io,Support are:
kernel-character-io,rtems_putc() - Outputs the character to the kernel character
kernel-character-io,output device.
kernel-character-io,rtems_put_char() - Puts the character using
kernel-character-io,rtems_putc()
kernel-character-io,putk() - Outputs the characters of the string and a newline
kernel-character-io,character to the kernel character output device.
kernel-character-io,printk() - Outputs the characters defined by the format string
kernel-character-io,and the arguments to the kernel character output device.
kernel-character-io,vprintk() - Outputs the characters defined by the format string
kernel-character-io,and the variable argument list to the kernel character output device.
kernel-character-io,rtems_printk_printer() - Outputs the characters defined by the
kernel-character-io,format string and the variable argument list to the kernel character output
kernel-character-io,device.
kernel-character-io,getchark() - Tries to dequeue a character from the kernel
kernel-character-io,character input device.
kernel-character-io,rtems_putc() - Outputs the character to the kernel character
kernel-character-io,output device.
kernel-character-io,rtems_put_char() - Puts the character using
kernel-character-io,rtems_putc()
kernel-character-io,putk() - Outputs the characters of the string and a newline
kernel-character-io,character to the kernel character output device.
kernel-character-io,printk() - Outputs the characters defined by the format string
kernel-character-io,and the arguments to the kernel character output device.
kernel-character-io,vprintk() - Outputs the characters defined by the format string
kernel-character-io,and the variable argument list to the kernel character output device.
kernel-character-io,rtems_printk_printer() - Outputs the characters defined by the
kernel-character-io,format string and the variable argument list to the kernel character output
kernel-character-io,device.
kernel-character-io,getchark() - Tries to dequeue a character from the kernel
kernel-character-io,character input device.
kernel-character-io,"© Copyright 1988, 2024 RTEMS Project and contributors."
message,A message is a variable length buffer where information can be stored to
message,support communication.  The length of the message and the information stored in
message,"that message are user-defined and can be actual data, pointer(s), or empty."
message,A message queue permits the passing of messages among tasks and ISRs.  Message
message,queues can contain a variable number of messages.  Normally messages are sent
message,to and received from the queue in FIFO order using the
message,"rtems_message_queue_send directive.  However, the"
message,rtems_message_queue_urgent directive can be used to place messages at the
message,head of a queue in LIFO order.
message,Synchronization can be accomplished when a task can wait for a message to
message,"arrive at a queue.  Also, a task may poll a queue for the arrival of a message."
message,The maximum length message which can be sent is set on a per message queue
message,basis.  The message content must be copied in general to/from an internal
message,buffer of the message queue or directly to a peer in certain cases.  This copy
message,operation is performed with interrupts disabled.  So it is advisable to keep
message,the messages as short as possible.
message,"In general, an attribute set is built by a bitwise OR of the desired attribute"
message,components.  The set of valid message queue attributes is provided in the
message,following table:
message,RTEMS_FIFO
message,tasks wait by FIFO (default)
message,RTEMS_PRIORITY
message,tasks wait by priority
message,RTEMS_LOCAL
message,local message queue (default)
message,RTEMS_GLOBAL
message,global message queue
message,RTEMS_FIFO
message,tasks wait by FIFO (default)
message,RTEMS_PRIORITY
message,tasks wait by priority
message,RTEMS_LOCAL
message,local message queue (default)
message,RTEMS_GLOBAL
message,global message queue
message,An attribute listed as a default is not required to appear in the attribute
message,"list, although it is a good programming practice to specify default attributes."
message,"If all defaults are desired, the attribute RTEMS_DEFAULT_ATTRIBUTES should"
message,be specified on this call.
message,This example demonstrates the attribute_set parameter needed to create a local
message,message queue with the task priority waiting queue discipline.  The
message,attribute_set parameter to the rtems_message_queue_create directive could
message,be either RTEMS_PRIORITY or RTEMS_LOCAL | RTEMS_PRIORITY.  The
message,attribute_set parameter can be set to RTEMS_PRIORITY because
message,RTEMS_LOCAL is the default for all created message queues.  If a similar
message,"message queue were to be known globally, then the attribute_set parameter would"
message,be RTEMS_GLOBAL | RTEMS_PRIORITY.
message,"In general, an option is built by a bitwise OR of the desired option"
message,components.  The set of valid options for the rtems_message_queue_receive
message,directive are listed in the following table:
message,RTEMS_WAIT
message,task will wait for a message (default)
message,RTEMS_NO_WAIT
message,task should not wait
message,RTEMS_WAIT
message,task will wait for a message (default)
message,RTEMS_NO_WAIT
message,task should not wait
message,"An option listed as a default is not required to appear in the option OR list,"
message,although it is a good programming practice to specify default options.  If all
message,"defaults are desired, the option RTEMS_DEFAULT_OPTIONS should be specified"
message,on this call.
message,This example demonstrates the option parameter needed to poll for a message to
message,arrive.  The option parameter passed to the rtems_message_queue_receive
message,directive should be RTEMS_NO_WAIT.
message,"© Copyright 1988, 2024 RTEMS Project and contributors."
message,The Message Manager provides communication and synchronization capabilities
message,using RTEMS message queues. The directives provided by the Message Manager are:
message,rtems_message_queue_create() - Creates a message queue.
message,rtems_message_queue_construct() - Constructs a message queue from
message,the specified the message queue configuration.
message,rtems_message_queue_ident() - Identifies a message queue by the
message,object name.
message,rtems_message_queue_delete() - Deletes the message queue.
message,rtems_message_queue_send() - Puts the message at the rear of the
message,queue.
message,rtems_message_queue_urgent() - Puts the message at the front of
message,the queue.
message,rtems_message_queue_broadcast() - Broadcasts the messages to the
message,tasks waiting at the queue.
message,rtems_message_queue_receive() - Receives a message from the queue.
message,rtems_message_queue_get_number_pending() - Gets the number of
message,messages pending on the queue.
message,rtems_message_queue_flush() - Flushes all messages on the queue.
message,RTEMS_MESSAGE_QUEUE_BUFFER() - Defines a structure which can be
message,used as a message queue buffer for messages of the specified maximum size.
message,rtems_message_queue_create() - Creates a message queue.
message,rtems_message_queue_construct() - Constructs a message queue from
message,the specified the message queue configuration.
message,rtems_message_queue_ident() - Identifies a message queue by the
message,object name.
message,rtems_message_queue_delete() - Deletes the message queue.
message,rtems_message_queue_send() - Puts the message at the rear of the
message,queue.
message,rtems_message_queue_urgent() - Puts the message at the front of
message,the queue.
message,rtems_message_queue_broadcast() - Broadcasts the messages to the
message,tasks waiting at the queue.
message,rtems_message_queue_receive() - Receives a message from the queue.
message,rtems_message_queue_get_number_pending() - Gets the number of
message,messages pending on the queue.
message,rtems_message_queue_flush() - Flushes all messages on the queue.
message,RTEMS_MESSAGE_QUEUE_BUFFER() - Defines a structure which can be
message,used as a message queue buffer for messages of the specified maximum size.
message,"© Copyright 1988, 2024 RTEMS Project and contributors."
multiprocessing,RTEMS makes no assumptions regarding the connection media or topology of a
multiprocessing,multiprocessor system.  The tasks which compose a particular application can be
multiprocessing,spread among as many processors as needed to satisfy the application’s timing
multiprocessing,requirements.  The application tasks can interact using a subset of the RTEMS
multiprocessing,directives as if they were on the same processor.  These directives allow
multiprocessing,"application tasks to exchange data, communicate, and synchronize regardless of"
multiprocessing,which processor they reside upon.
multiprocessing,The RTEMS multiprocessor execution model is multiple instruction streams with
multiprocessing,multiple data streams (MIMD).  This execution model has each of the processors
multiprocessing,executing code independent of the other processors.  Because of this
multiprocessing,"parallelism, the application designer can more easily guarantee deterministic"
multiprocessing,behavior.
multiprocessing,"By supporting heterogeneous environments, RTEMS allows the systems designer to"
multiprocessing,select the most efficient processor for each subsystem of the application.
multiprocessing,Configuring RTEMS for a heterogeneous environment is no more difficult than for
multiprocessing,a homogeneous one.  In keeping with RTEMS philosophy of providing transparent
multiprocessing,"physical node boundaries, the minimal heterogeneous processing required is"
multiprocessing,isolated in the MPCI layer.
multiprocessing,A processor in a RTEMS system is referred to as a node.  Each node is assigned
multiprocessing,a unique non-zero node number by the application designer.  RTEMS assumes that
multiprocessing,node numbers are assigned consecutively from one to the maximum_nodes
multiprocessing,"configuration parameter.  The node number, node, and the maximum number of"
multiprocessing,"nodes, maximum_nodes, in a system are found in the Multiprocessor"
multiprocessing,Configuration Table.  The maximum_nodes field and the number of global
multiprocessing,"objects, maximum_global_objects, is required to be the same on all nodes in"
multiprocessing,a system.
multiprocessing,The node number is used by RTEMS to identify each node when performing remote
multiprocessing,"operations.  Thus, the Multiprocessor Communications Interface Layer (MPCI)"
multiprocessing,must be able to route messages based on the node number.
multiprocessing,All RTEMS objects which are created with the GLOBAL attribute will be known on
multiprocessing,"all other nodes.  Global objects can be referenced from any node in the system,"
multiprocessing,although certain directive specific restrictions (e.g. one cannot delete a
multiprocessing,remote object) may apply.  A task does not have to be global to perform
multiprocessing,operations involving remote objects.  The maximum number of global objects is
multiprocessing,the system is user configurable and can be found in the maximum_global_objects
multiprocessing,field in the Multiprocessor Configuration Table.  The distribution of tasks to
multiprocessing,processors is performed during the application design phase.  Dynamic task
multiprocessing,relocation is not supported by RTEMS.
multiprocessing,RTEMS maintains two tables containing object information on every node in a
multiprocessing,multiprocessor system: a local object table and a global object table.  The
multiprocessing,local object table on each node is unique and contains information for all
multiprocessing,objects created on this node whether those objects are local or global.  The
multiprocessing,global object table contains information regarding all global objects in the
multiprocessing,"system and, consequently, is the same on every node."
multiprocessing,"Since each node must maintain an identical copy of the global object table, the"
multiprocessing,maximum number of entries in each copy of the table must be the same.  The
multiprocessing,maximum number of entries in each copy is determined by the
multiprocessing,maximum_global_objects parameter in the Multiprocessor Configuration Table.
multiprocessing,"This parameter, as well as the maximum_nodes parameter, is required to be the"
multiprocessing,"same on all nodes.  To maintain consistency among the table copies, every node"
multiprocessing,in the system must be informed of the creation or deletion of a global object.
multiprocessing,"When an application performs an operation on a remote global object, RTEMS must"
multiprocessing,generate a Remote Request (RQ) message and send it to the appropriate node.
multiprocessing,"After completing the requested operation, the remote node will build a Remote"
multiprocessing,Response (RR) message and send it to the originating node.  Messages generated
multiprocessing,as a side-effect of a directive (such as deleting a global task) are known as
multiprocessing,Remote Processes (RP) and do not require the receiving node to respond.
multiprocessing,"Other than taking slightly longer to execute directives on remote objects, the"
multiprocessing,application is unaware of the location of the objects it acts upon.  The exact
multiprocessing,amount of overhead required for a remote operation is dependent on the media
multiprocessing,"connecting the nodes and, to a lesser degree, on the efficiency of the"
multiprocessing,user-provided MPCI routines.
multiprocessing,The following shows the typical transaction sequence during a remote
multiprocessing,application:
multiprocessing,The application issues a directive accessing a remote global object.
multiprocessing,RTEMS determines the node on which the object resides.
multiprocessing,RTEMS calls the user-provided MPCI routine GET_PACKET to obtain a packet
multiprocessing,in which to build a RQ message.
multiprocessing,"After building a message packet, RTEMS calls the user-provided MPCI routine"
multiprocessing,SEND_PACKET to transmit the packet to the node on which the object
multiprocessing,resides (referred to as the destination node).
multiprocessing,"The calling task is blocked until the RR message arrives, and control of the"
multiprocessing,processor is transferred to another task.
multiprocessing,The MPCI layer on the destination node senses the arrival of a packet
multiprocessing,"(commonly in an ISR), and calls the rtems_multiprocessing_announce"
multiprocessing,directive.  This directive readies the Multiprocessing Server.
multiprocessing,The Multiprocessing Server calls the user-provided MPCI routine
multiprocessing,"RECEIVE_PACKET, performs the requested operation, builds an RR message,"
multiprocessing,and returns it to the originating node.
multiprocessing,The MPCI layer on the originating node senses the arrival of a packet
multiprocessing,"(typically via an interrupt), and calls the RTEMS"
multiprocessing,rtems_multiprocessing_announce directive.  This directive readies the
multiprocessing,Multiprocessing Server.
multiprocessing,The Multiprocessing Server calls the user-provided MPCI routine
multiprocessing,"RECEIVE_PACKET, readies the original requesting task, and blocks until"
multiprocessing,another packet arrives.  Control is transferred to the original task which
multiprocessing,then completes processing of the directive.
multiprocessing,"If an uncorrectable error occurs in the user-provided MPCI layer, the fatal"
multiprocessing,error handler should be invoked.  RTEMS assumes the reliable transmission and
multiprocessing,reception of messages by the MPCI and makes no attempt to detect or correct
multiprocessing,errors.
multiprocessing,A proxy is an RTEMS data structure which resides on a remote node and is used
multiprocessing,to represent a task which must block as part of a remote operation. This action
multiprocessing,can occur as part of the rtems_semaphore_obtain and
multiprocessing,"rtems_message_queue_receive directives.  If the object were local, the"
multiprocessing,task’s control block would be available for modification to indicate it was
multiprocessing,"blocking on a message queue or semaphore.  However, the task’s control block"
multiprocessing,"resides only on the same node as the task.  As a result, the remote node must"
multiprocessing,allocate a proxy to represent the task until it can be readied.
multiprocessing,The maximum number of proxies is defined in the Multiprocessor Configuration
multiprocessing,Table.  Each node in a multiprocessor system may require a different number of
multiprocessing,proxies to be configured.  The distribution of proxy control blocks is
multiprocessing,application dependent and is different from the distribution of tasks.
multiprocessing,The Multiprocessor Configuration Table contains information needed by RTEMS
multiprocessing,when used in a multiprocessor system.  This table is discussed in detail in the
multiprocessing,section Multiprocessor Configuration Table of the Configuring a System chapter.
multiprocessing,The Multiprocessor Communications Interface Layer (MPCI) is a set of
multiprocessing,user-provided procedures which enable the nodes in a multiprocessor system to
multiprocessing,communicate with one another.  These routines are invoked by RTEMS at various
multiprocessing,times in the preparation and processing of remote requests.  Interrupts are
multiprocessing,enabled when an MPCI procedure is invoked.  It is assumed that if the execution
multiprocessing,"mode and/or interrupt level are altered by the MPCI layer, that they will be"
multiprocessing,restored prior to returning to RTEMS.
multiprocessing,The MPCI layer is responsible for managing a pool of buffers called packets and
multiprocessing,for sending these packets between system nodes.  Packet buffers contain the
multiprocessing,"messages sent between the nodes.  Typically, the MPCI layer will encapsulate"
multiprocessing,the packet within an envelope which contains the information needed by the MPCI
multiprocessing,layer.  The number of packets available is dependent on the MPCI layer
multiprocessing,implementation.
multiprocessing,The entry points to the routines in the user’s MPCI layer should be placed in
multiprocessing,the Multiprocessor Communications Interface Table.  The user must provide entry
multiprocessing,points for each of the following table entries in a multiprocessor system:
multiprocessing,initialization
multiprocessing,initialize the MPCI
multiprocessing,get_packet
multiprocessing,obtain a packet buffer
multiprocessing,return_packet
multiprocessing,return a packet buffer
multiprocessing,send_packet
multiprocessing,send a packet to another node
multiprocessing,receive_packet
multiprocessing,called to get an arrived packet
multiprocessing,initialization
multiprocessing,initialize the MPCI
multiprocessing,get_packet
multiprocessing,obtain a packet buffer
multiprocessing,return_packet
multiprocessing,return a packet buffer
multiprocessing,send_packet
multiprocessing,send a packet to another node
multiprocessing,receive_packet
multiprocessing,called to get an arrived packet
multiprocessing,A packet is sent by RTEMS in each of the following situations:
multiprocessing,an RQ is generated on an originating node;
multiprocessing,an RR is generated on a destination node;
multiprocessing,a global object is created;
multiprocessing,a global object is deleted;
multiprocessing,a local task blocked on a remote object is deleted;
multiprocessing,during system initialization to check for system consistency.
multiprocessing,an RQ is generated on an originating node;
multiprocessing,an RR is generated on a destination node;
multiprocessing,a global object is created;
multiprocessing,a global object is deleted;
multiprocessing,a local task blocked on a remote object is deleted;
multiprocessing,during system initialization to check for system consistency.
multiprocessing,"If the target hardware supports it, the arrival of a packet at a node may"
multiprocessing,"generate an interrupt.  Otherwise, the real-time clock ISR can check for the"
multiprocessing,"arrival of a packet.  In any case, the rtems_multiprocessing_announce"
multiprocessing,directive must be called to announce the arrival of a packet.  After exiting
multiprocessing,"the ISR, control will be passed to the Multiprocessing Server to process the"
multiprocessing,packet.  The Multiprocessing Server will call the get_packet entry to obtain a
multiprocessing,packet buffer and the receive_entry entry to copy the message into the buffer
multiprocessing,obtained.
multiprocessing,The INITIALIZATION component of the user-provided MPCI layer is called as part
multiprocessing,of the rtems_initialize_executive directive to initialize the MPCI layer
multiprocessing,and associated hardware.  It is invoked immediately after all of the device
multiprocessing,drivers have been initialized.  This component should be adhere to the
multiprocessing,following prototype:
multiprocessing,Operations on global objects cannot be performed until this component is
multiprocessing,invoked.  The INITIALIZATION component is invoked only once in the life of any
multiprocessing,"system.  If the MPCI layer cannot be successfully initialized, the fatal error"
multiprocessing,manager should be invoked by this routine.
multiprocessing,One of the primary functions of the MPCI layer is to provide the executive with
multiprocessing,packet buffers.  The INITIALIZATION routine must create and initialize a pool
multiprocessing,of packet buffers.  There must be enough packet buffers so RTEMS can obtain one
multiprocessing,whenever needed.
multiprocessing,The GET_PACKET component of the user-provided MPCI layer is called when RTEMS
multiprocessing,must obtain a packet buffer to send or broadcast a message.  This component
multiprocessing,should be adhere to the following prototype:
multiprocessing,where packet is the address of a pointer to a packet.  This routine always
multiprocessing,"succeeds and, upon return, packet will contain the address of a packet.  If for"
multiprocessing,"any reason, a packet cannot be successfully obtained, then the fatal error"
multiprocessing,manager should be invoked.
multiprocessing,RTEMS has been optimized to avoid the need for obtaining a packet each time a
multiprocessing,"message is sent or broadcast.  For example, RTEMS sends response messages (RR)"
multiprocessing,back to the originator in the same packet in which the request message (RQ)
multiprocessing,arrived.
multiprocessing,The RETURN_PACKET component of the user-provided MPCI layer is called when
multiprocessing,RTEMS needs to release a packet to the free packet buffer pool.  This component
multiprocessing,should be adhere to the following prototype:
multiprocessing,where packet is the address of a packet.  If the packet cannot be successfully
multiprocessing,"returned, the fatal error manager should be invoked."
multiprocessing,The RECEIVE_PACKET component of the user-provided MPCI layer is called when
multiprocessing,RTEMS needs to obtain a packet which has previously arrived.  This component
multiprocessing,should be adhere to the following prototype:
multiprocessing,where packet is a pointer to the address of a packet to place the message from
multiprocessing,"another node.  If a message is available, then packet will contain the address"
multiprocessing,"of the message from another node.  If no messages are available, this entry"
multiprocessing,packet should contain NULL.
multiprocessing,The SEND_PACKET component of the user-provided MPCI layer is called when RTEMS
multiprocessing,needs to send a packet containing a message to another node.  This component
multiprocessing,should be adhere to the following prototype:
multiprocessing,where node is the node number of the destination and packet is the address of a
multiprocessing,"packet which containing a message.  If the packet cannot be successfully sent,"
multiprocessing,the fatal error manager should be invoked.
multiprocessing,"If node is set to zero, the packet is to be broadcasted to all other nodes in"
multiprocessing,the system.  Although some MPCI layers will be built upon hardware which
multiprocessing,"support a broadcast mechanism, others may be required to generate a copy of the"
multiprocessing,packet for each node in the system.
multiprocessing,Many MPCI layers use the packet_length field of the rtems_packet_prefix
multiprocessing,portion of the packet to avoid sending unnecessary data.  This is especially
multiprocessing,useful if the media connecting the nodes is relatively slow.
multiprocessing,The to_convert field of the rtems_packet_prefix portion of the packet
multiprocessing,indicates how much of the packet in 32-bit units may require conversion in a
multiprocessing,heterogeneous system.
multiprocessing,Developing an MPCI layer for a heterogeneous system requires a thorough
multiprocessing,understanding of the differences between the processors which comprise the
multiprocessing,system.  One difficult problem is the varying data representation schemes used
multiprocessing,by different processor types.  The most pervasive data representation problem
multiprocessing,is the order of the bytes which compose a data entity.  Processors which place
multiprocessing,the least significant byte at the smallest address are classified as little
multiprocessing,endian processors.  Little endian byte-ordering is shown below:
multiprocessing,"Conversely, processors which place the most significant byte at the smallest"
multiprocessing,address are classified as big endian processors.  Big endian byte-ordering is
multiprocessing,shown below:
multiprocessing,"Unfortunately, sharing a data structure between big endian and little endian"
multiprocessing,processors requires translation into a common endian format.  An application
multiprocessing,designer typically chooses the common endian format to minimize conversion
multiprocessing,overhead.
multiprocessing,Another issue in the design of shared data structures is the alignment of data
multiprocessing,structure elements.  Alignment is both processor and compiler implementation
multiprocessing,"dependent.  For example, some processors allow data elements to begin on any"
multiprocessing,"address boundary, while others impose restrictions.  Common restrictions are"
multiprocessing,that data elements must begin on either an even address or on a long word
multiprocessing,boundary.  Violation of these restrictions may cause an exception or impose a
multiprocessing,performance penalty.
multiprocessing,Other issues which commonly impact the design of shared data structures include
multiprocessing,"the representation of floating point numbers, bit fields, decimal data, and"
multiprocessing,"character strings.  In addition, the representation method for negative"
multiprocessing,integers could be one’s or two’s complement.  These factors combine to increase
multiprocessing,the complexity of designing and manipulating data structures shared between
multiprocessing,processors.
multiprocessing,RTEMS addressed these issues in the design of the packets used to communicate
multiprocessing,between nodes.  The RTEMS packet format is designed to allow the MPCI layer to
multiprocessing,perform all necessary conversion without burdening the developer with the
multiprocessing,"details of the RTEMS packet format.  As a result, the MPCI layer must be aware"
multiprocessing,of the following:
multiprocessing,All packets must begin on a four byte boundary.
multiprocessing,Packets are composed of both RTEMS and application data.  All RTEMS data is
multiprocessing,treated as 32-bit unsigned quantities and is in the first to_convert
multiprocessing,32-bit quantities of the packet.  The to_convert field is part of the
multiprocessing,rtems_packet_prefix portion of the packet.
multiprocessing,The RTEMS data component of the packet must be in native endian format.
multiprocessing,Endian conversion may be performed by either the sending or receiving MPCI
multiprocessing,layer.
multiprocessing,RTEMS makes no assumptions regarding the application data component of the
multiprocessing,packet.
multiprocessing,All packets must begin on a four byte boundary.
multiprocessing,Packets are composed of both RTEMS and application data.  All RTEMS data is
multiprocessing,treated as 32-bit unsigned quantities and is in the first to_convert
multiprocessing,32-bit quantities of the packet.  The to_convert field is part of the
multiprocessing,rtems_packet_prefix portion of the packet.
multiprocessing,The RTEMS data component of the packet must be in native endian format.
multiprocessing,Endian conversion may be performed by either the sending or receiving MPCI
multiprocessing,layer.
multiprocessing,RTEMS makes no assumptions regarding the application data component of the
multiprocessing,packet.
multiprocessing,"© Copyright 1988, 2024 RTEMS Project and contributors."
multiprocessing,The Multiprocessing Manager provides support for heterogeneous multiprocessing
multiprocessing,systems based on message passing in a network of multiprocessing nodes.
multiprocessing,"In multiprocessor real-time systems, new requirements, such as sharing data and"
multiprocessing,"global resources between processors, are introduced.  This requires an"
multiprocessing,efficient and reliable communications vehicle which allows all processors to
multiprocessing,"communicate with each other as necessary.  In addition, the ramifications of"
multiprocessing,"multiple processors affect each and every characteristic of a real-time system,"
multiprocessing,almost always making them more complicated.
multiprocessing,RTEMS addresses these issues by providing simple and flexible real-time
multiprocessing,multiprocessing capabilities.  The executive easily lends itself to both
multiprocessing,tightly-coupled and loosely-coupled configurations of the target system
multiprocessing,"hardware.  In addition, RTEMS supports systems composed of both homogeneous and"
multiprocessing,heterogeneous mixtures of processors and target boards.
multiprocessing,A major design goal of the RTEMS executive was to transcend the physical
multiprocessing,boundaries of the target hardware configuration.  This goal is achieved by
multiprocessing,presenting the application software with a logical view of the target system
multiprocessing,"where the boundaries between processor nodes are transparent.  As a result, the"
multiprocessing,"application developer may designate objects such as tasks, queues, events,"
multiprocessing,"signals, semaphores, and memory blocks as global objects.  These global objects"
multiprocessing,may then be accessed by any task regardless of the physical location of the
multiprocessing,object and the accessing task.  RTEMS automatically determines that the object
multiprocessing,being accessed resides on another processor and performs the actions required
multiprocessing,"to access the desired object.  Simply stated, RTEMS allows the entire system,"
multiprocessing,"both hardware and software, to be viewed logically as a single system. The"
multiprocessing,directives provided by the Multiprocessing Manager are:
multiprocessing,rtems_multiprocessing_announce() - Announces the arrival of a
multiprocessing,packet.
multiprocessing,rtems_multiprocessing_announce() - Announces the arrival of a
multiprocessing,packet.
multiprocessing,"© Copyright 1988, 2024 RTEMS Project and contributors."
object-services,"RTEMS implements multiple APIs including an Internal API, the Classic API, and"
object-services,the POSIX API.  These APIs share the common foundation of SuperCore objects and
object-services,thus share object management code. This includes a common scheme for object Ids
object-services,and for managing object names whether those names be in the thirty-two bit form
object-services,used by the Classic API or C strings.
object-services,The object Id contains a field indicating the API that an object instance is
object-services,associated with.  This field holds a numerically small non-zero integer.
object-services,Each API consists of a collection of managers.  Each manager is responsible for
object-services,instances of a particular object class.  Classic API Tasks and POSIX Mutexes
object-services,example classes.
object-services,The object Id contains a field indicating the class that an object instance is
object-services,associated with.  This field holds a numerically small non-zero integer.  In
object-services,"all APIs, a class value of one is reserved for tasks or threads."
object-services,Every RTEMS object which has an Id may also have a name associated with it.
object-services,"Depending on the API, names may be either thirty-two bit integers as in the"
object-services,Classic API or strings as in the POSIX API.
object-services,Some objects have Ids but do not have a defined way to associate a name with
object-services,"them.  For example, POSIX threads have Ids but per POSIX do not have names. In"
object-services,"RTEMS, objects not defined to have thirty-two bit names may have string names"
object-services,assigned to them via the rtems_object_set_name service.  The original
object-services,impetus in providing this service was so the normally anonymous POSIX threads
object-services,could have a user defined name in CPU Usage Reports.
object-services,"© Copyright 1988, 2024 RTEMS Project and contributors."
object-services,RTEMS provides a collection of services to assist in the management and usage
object-services,of the objects created and utilized via other managers.  These services assist
object-services,in the manipulation of RTEMS objects independent of the API used to create
object-services,them. The directives provided by the Object Services are:
object-services,"rtems_build_id() - Builds the object identifier from the API,"
object-services,"class, MPCI node, and index components."
object-services,rtems_build_name() - Builds the object name composed of the four
object-services,characters.
object-services,rtems_object_get_classic_name() - Gets the object name associated
object-services,with the object identifier.
object-services,rtems_object_get_name() - Gets the object name associated with the
object-services,object identifier as a string.
object-services,rtems_object_set_name() - Sets the object name of the object
object-services,associated with the object identifier.
object-services,rtems_object_id_get_api() - Gets the API component of the object
object-services,identifier.
object-services,rtems_object_id_get_class() - Gets the class component of the
object-services,object identifier.
object-services,rtems_object_id_get_node() - Gets the MPCI node component of the
object-services,object identifier.
object-services,rtems_object_id_get_index() - Gets the index component of the
object-services,object identifier.
object-services,rtems_object_id_api_minimum() - Gets the lowest valid value for the
object-services,API component of an object identifier.
object-services,rtems_object_id_api_maximum() - Gets the highest valid value for
object-services,the API component of an object identifier.
object-services,rtems_object_api_minimum_class() - Gets the lowest valid class
object-services,value of the object API.
object-services,rtems_object_api_maximum_class() - Gets the highest valid class
object-services,value of the object API.
object-services,rtems_object_get_api_name() - Gets a descriptive name of the object
object-services,API.
object-services,rtems_object_get_api_class_name() - Gets a descriptive name of the
object-services,object class of the object API.
object-services,rtems_object_get_class_information() - Gets the object class
object-services,information of the object class of the object API.
object-services,rtems_object_get_local_node() - Gets the local MPCI node number.
object-services,RTEMS_OBJECT_ID_INITIAL() - Builds the object identifier with the
object-services,"lowest index from the API, class, and MPCI node components."
object-services,"rtems_build_id() - Builds the object identifier from the API,"
object-services,"class, MPCI node, and index components."
object-services,rtems_build_name() - Builds the object name composed of the four
object-services,characters.
object-services,rtems_object_get_classic_name() - Gets the object name associated
object-services,with the object identifier.
object-services,rtems_object_get_name() - Gets the object name associated with the
object-services,object identifier as a string.
object-services,rtems_object_set_name() - Sets the object name of the object
object-services,associated with the object identifier.
object-services,rtems_object_id_get_api() - Gets the API component of the object
object-services,identifier.
object-services,rtems_object_id_get_class() - Gets the class component of the
object-services,object identifier.
object-services,rtems_object_id_get_node() - Gets the MPCI node component of the
object-services,object identifier.
object-services,rtems_object_id_get_index() - Gets the index component of the
object-services,object identifier.
object-services,rtems_object_id_api_minimum() - Gets the lowest valid value for the
object-services,API component of an object identifier.
object-services,rtems_object_id_api_maximum() - Gets the highest valid value for
object-services,the API component of an object identifier.
object-services,rtems_object_api_minimum_class() - Gets the lowest valid class
object-services,value of the object API.
object-services,rtems_object_api_maximum_class() - Gets the highest valid class
object-services,value of the object API.
object-services,rtems_object_get_api_name() - Gets a descriptive name of the object
object-services,API.
object-services,rtems_object_get_api_class_name() - Gets a descriptive name of the
object-services,object class of the object API.
object-services,rtems_object_get_class_information() - Gets the object class
object-services,information of the object class of the object API.
object-services,rtems_object_get_local_node() - Gets the local MPCI node number.
object-services,RTEMS_OBJECT_ID_INITIAL() - Builds the object identifier with the
object-services,"lowest index from the API, class, and MPCI node components."
object-services,"© Copyright 1988, 2024 RTEMS Project and contributors."
partition,A partition is a physically contiguous memory area divided into fixed-size
partition,buffers that can be dynamically allocated and deallocated.
partition,Partitions are managed and maintained as a list of buffers.  Buffers are
partition,obtained from the front of the partition’s free buffer chain and returned to
partition,"the rear of the same chain.  When a buffer is on the free buffer chain, RTEMS"
partition,uses two pointers of memory from each buffer as the free buffer chain.  When a
partition,"buffer is allocated, the entire buffer is available for application use."
partition,"Therefore, modifying memory that is outside of an allocated buffer could"
partition,destroy the free buffer chain or the contents of an adjacent allocated buffer.
partition,"In general, an attribute set is built by a bitwise OR of the desired attribute"
partition,components.  The set of valid partition attributes is provided in the following
partition,table:
partition,RTEMS_LOCAL
partition,local partition (default)
partition,RTEMS_GLOBAL
partition,global partition
partition,RTEMS_LOCAL
partition,local partition (default)
partition,RTEMS_GLOBAL
partition,global partition
partition,"Attribute values are specifically designed to be mutually exclusive, therefore"
partition,bitwise OR and addition operations are equivalent as long as each attribute
partition,appears exactly once in the component list.  An attribute listed as a default
partition,"is not required to appear in the attribute list, although it is a good"
partition,programming practice to specify default attributes.  If all defaults are
partition,"desired, the attribute RTEMS_DEFAULT_ATTRIBUTES should be specified on this"
partition,call.  The attribute_set parameter should be RTEMS_GLOBAL to indicate that
partition,the partition is to be known globally.
partition,"© Copyright 1988, 2024 RTEMS Project and contributors."
partition,The Partition Manager provides facilities to dynamically allocate memory in
partition,fixed-size units. The directives provided by the Partition Manager are:
partition,rtems_partition_create() - Creates a partition.
partition,rtems_partition_ident() - Identifies a partition by the object
partition,name.
partition,rtems_partition_delete() - Deletes the partition.
partition,rtems_partition_get_buffer() - Tries to get a buffer from the
partition,partition.
partition,rtems_partition_return_buffer() - Returns the buffer to the
partition,partition.
partition,rtems_partition_create() - Creates a partition.
partition,rtems_partition_ident() - Identifies a partition by the object
partition,name.
partition,rtems_partition_delete() - Deletes the partition.
partition,rtems_partition_get_buffer() - Tries to get a buffer from the
partition,partition.
partition,rtems_partition_return_buffer() - Returns the buffer to the
partition,partition.
partition,"© Copyright 1988, 2024 RTEMS Project and contributors."
rate-monotonic,The rate monotonic manager provides facilities to manage the execution of
rate-monotonic,periodic tasks.  This manager was designed to support application designers who
rate-monotonic,utilize the Rate Monotonic Scheduling Algorithm (RMS) to ensure that their
rate-monotonic,"periodic tasks will meet their deadlines, even under transient overload"
rate-monotonic,"conditions.  Although designed for hard real-time systems, the services"
rate-monotonic,provided by the rate monotonic manager may be used by any application which
rate-monotonic,requires periodic tasks.
rate-monotonic,A clock tick is required to support the functionality provided by this manager.
rate-monotonic,This manager maintains a set of statistics on each period object.  These
rate-monotonic,statistics are reset implictly at period creation time and may be reset or
rate-monotonic,obtained at any time by the application.  The following is a list of the
rate-monotonic,information kept:
rate-monotonic,is the id of the thread that owns this period.
rate-monotonic,is the total number of periods executed.
rate-monotonic,is the number of periods that were missed.
rate-monotonic,is the minimum amount of CPU execution time consumed on any execution of the
rate-monotonic,periodic loop.
rate-monotonic,is the maximum amount of CPU execution time consumed on any execution of the
rate-monotonic,periodic loop.
rate-monotonic,is the total amount of CPU execution time consumed by executions of the
rate-monotonic,periodic loop.
rate-monotonic,is the minimum amount of wall time that passed on any execution of the
rate-monotonic,periodic loop.
rate-monotonic,is the maximum amount of wall time that passed on any execution of the
rate-monotonic,periodic loop.
rate-monotonic,is the total amount of wall time that passed during executions of the
rate-monotonic,periodic loop.
rate-monotonic,Each period is divided into two consecutive phases.  The period starts with the
rate-monotonic,active phase of the task and is followed by the inactive phase of the task.  In
rate-monotonic,the inactive phase the task is blocked and waits for the start of the next
rate-monotonic,period.  The inactive phase is skipped in case of a period miss.  The wall time
rate-monotonic,includes the time during the active phase of the task on which the task is not
rate-monotonic,executing on a processor.  The task is either blocked (for example it waits for
rate-monotonic,"a resource) or a higher priority tasks executes, thus preventing it from"
rate-monotonic,"executing.  In case the wall time exceeds the period time, then this is a"
rate-monotonic,period miss.  The gap between the wall time and the period time is the margin
rate-monotonic,between a period miss or success.
rate-monotonic,The period statistics information is inexpensive to maintain and can provide
rate-monotonic,very useful insights into the execution characteristics of a periodic task
rate-monotonic,loop.  But it is just information.  The period statistics reported must be
rate-monotonic,"analyzed by the user in terms of what the applications is.  For example, in an"
rate-monotonic,"application where priorities are assigned by the Rate Monotonic Algorithm, it"
rate-monotonic,would be very undesirable for high priority (i.e. frequency) tasks to miss
rate-monotonic,"their period.  Similarly, in nearly any application, if a task were supposed to"
rate-monotonic,execute its periodic loop every 10 milliseconds and it averaged 11
rate-monotonic,"milliseconds, then application requirements are not being met."
rate-monotonic,The information reported can be used to determine the “hot spots” in the
rate-monotonic,"application.  Given a period’s id, the user can determine the length of that"
rate-monotonic,"period.  From that information and the CPU usage, the user can calculate the"
rate-monotonic,"percentage of CPU time consumed by that periodic task.  For example, a task"
rate-monotonic,executing for 20 milliseconds every 200 milliseconds is consuming 10 percent of
rate-monotonic,the processor’s execution time.  This is usually enough to make it a good
rate-monotonic,candidate for optimization.
rate-monotonic,"However, execution time alone is not enough to gauge the value of optimizing a"
rate-monotonic,particular task.  It is more important to optimize a task executing 2
rate-monotonic,millisecond every 10 milliseconds (20 percent of the CPU) than one executing 10
rate-monotonic,"milliseconds every 100 (10 percent of the CPU).  As a general rule of thumb,"
rate-monotonic,"the higher frequency at which a task executes, the more important it is to"
rate-monotonic,optimize that task.
rate-monotonic,A periodic task is one which must be executed at a regular interval.  The
rate-monotonic,interval between successive iterations of the task is referred to as its
rate-monotonic,period.  Periodic tasks can be characterized by the length of their period and
rate-monotonic,execution time.  The period and execution time of a task can be used to
rate-monotonic,determine the processor utilization for that task.  Processor utilization is
rate-monotonic,the percentage of processor time used and can be calculated on a per-task or
rate-monotonic,"system-wide basis.  Typically, the task’s worst-case execution time will be"
rate-monotonic,"less than its period.  For example, a periodic task’s requirements may state"
rate-monotonic,that it should execute for 10 milliseconds every 100 milliseconds.  Although
rate-monotonic,"the execution time may be the average, worst, or best case, the worst-case"
rate-monotonic,execution time is more appropriate for use when analyzing system behavior under
rate-monotonic,transient overload conditions.
rate-monotonic,"In contrast, an aperiodic task executes at irregular intervals and has only a"
rate-monotonic,"soft deadline.  In other words, the deadlines for aperiodic tasks are not"
rate-monotonic,"rigid, but adequate response times are desirable.  For example, an aperiodic"
rate-monotonic,task may process user input from a terminal.
rate-monotonic,"Finally, a sporadic task is an aperiodic task with a hard deadline and minimum"
rate-monotonic,interarrival time.  The minimum interarrival time is the minimum period of time
rate-monotonic,"which exists between successive iterations of the task.  For example, a"
rate-monotonic,sporadic task could be used to process the pressing of a fire button on a
rate-monotonic,joystick.  The mechanical action of the fire button ensures a minimum time
rate-monotonic,"period between successive activations, but the missile must be launched by a"
rate-monotonic,hard deadline.
rate-monotonic,The Rate Monotonic Scheduling Algorithm (RMS) is important to real-time systems
rate-monotonic,designers because it allows one to sufficiently guarantee that a set of tasks
rate-monotonic,"is schedulable (see [LL73], [LSD89],"
rate-monotonic,"[SG90], [Bur91])."
rate-monotonic,A set of tasks is said to be schedulable if all of the tasks can meet their
rate-monotonic,deadlines.  RMS provides a set of rules which can be used to perform
rate-monotonic,a guaranteed schedulability analysis for a task set.  This analysis determines
rate-monotonic,whether a task set is schedulable under worst-case conditions and emphasizes
rate-monotonic,the predictability of the system’s behavior.  It has been proven that:
rate-monotonic,RMS
rate-monotonic,"RMS is an optimal fixed-priority algorithm for scheduling independent,"
rate-monotonic,"preemptible, periodic tasks on a single processor."
rate-monotonic,RMS is optimal in the sense that if a set of tasks can be scheduled by any
rate-monotonic,"fixed-priority algorithm, then RMS will be able to schedule that task set."
rate-monotonic,RMS bases it schedulability analysis on the processor utilization level below
rate-monotonic,which all deadlines can be met.
rate-monotonic,RMS calls for the static assignment of task priorities based upon their period.
rate-monotonic,"The shorter a task’s period, the higher its priority.  For example, a task with"
rate-monotonic,a 1 millisecond period has higher priority than a task with a 100 millisecond
rate-monotonic,"period.  If two tasks have the same period, then RMS does not distinguish"
rate-monotonic,"between the tasks.  However, RTEMS specifies that when given tasks of equal"
rate-monotonic,"priority, the task which has been ready longest will execute first.  RMS’s"
rate-monotonic,priority assignment scheme does not provide one with exact numeric values for
rate-monotonic,"task priorities.  For example, consider the following task set and priority"
rate-monotonic,assignments:
rate-monotonic,Task
rate-monotonic,"Period
(in milliseconds)"
rate-monotonic,Priority
rate-monotonic,1
rate-monotonic,100
rate-monotonic,Low
rate-monotonic,2
rate-monotonic,50
rate-monotonic,Medium
rate-monotonic,3
rate-monotonic,50
rate-monotonic,Medium
rate-monotonic,4
rate-monotonic,25
rate-monotonic,High
rate-monotonic,Task
rate-monotonic,Period
rate-monotonic,(in milliseconds)
rate-monotonic,Priority
rate-monotonic,1
rate-monotonic,100
rate-monotonic,Low
rate-monotonic,2
rate-monotonic,50
rate-monotonic,Medium
rate-monotonic,3
rate-monotonic,50
rate-monotonic,Medium
rate-monotonic,4
rate-monotonic,25
rate-monotonic,High
rate-monotonic,"RMS only calls for task 1 to have the lowest priority, task 4 to have the"
rate-monotonic,"highest priority, and tasks 2 and 3 to have an equal priority between that of"
rate-monotonic,tasks 1 and 4.  The actual RTEMS priorities assigned to the tasks must only
rate-monotonic,adhere to those guidelines.
rate-monotonic,Many applications have tasks with both hard and soft deadlines.  The tasks with
rate-monotonic,"hard deadlines are typically referred to as the critical task set, with the"
rate-monotonic,soft deadline tasks being the non-critical task set.  The critical task set can
rate-monotonic,"be scheduled using RMS, with the non-critical tasks not executing under"
rate-monotonic,"transient overload, by simply assigning priorities such that the lowest"
rate-monotonic,priority critical task (i.e. longest period) has a higher priority than the
rate-monotonic,highest priority non-critical task.  Although RMS may be used to assign
rate-monotonic,"priorities to the non-critical tasks, it is not necessary.  In this instance,"
rate-monotonic,schedulability is only guaranteed for the critical task set.
rate-monotonic,"RMS allows application designers to ensure that tasks can meet all deadlines under fixed-priority assignment,"
rate-monotonic,"even under transient overload, without knowing exactly when any given task will"
rate-monotonic,execute by applying proven schedulability analysis rules.
rate-monotonic,The schedulability analysis rules for RMS were developed based on the following
rate-monotonic,assumptions:
rate-monotonic,"The requests for all tasks for which hard deadlines exist are periodic, with"
rate-monotonic,a constant interval between requests.
rate-monotonic,Each task must complete before the next request for it occurs.
rate-monotonic,The tasks are independent in that a task does not depend on the initiation or
rate-monotonic,completion of requests for other tasks.
rate-monotonic,The execution time for each task without preemption or interruption is
rate-monotonic,constant and does not vary.
rate-monotonic,Any non-periodic tasks in the system are special.  These tasks should not
rate-monotonic,"displace periodic tasks while executing and do not have hard, critical"
rate-monotonic,deadlines.
rate-monotonic,"The requests for all tasks for which hard deadlines exist are periodic, with"
rate-monotonic,a constant interval between requests.
rate-monotonic,Each task must complete before the next request for it occurs.
rate-monotonic,The tasks are independent in that a task does not depend on the initiation or
rate-monotonic,completion of requests for other tasks.
rate-monotonic,The execution time for each task without preemption or interruption is
rate-monotonic,constant and does not vary.
rate-monotonic,Any non-periodic tasks in the system are special.  These tasks should not
rate-monotonic,"displace periodic tasks while executing and do not have hard, critical"
rate-monotonic,deadlines.
rate-monotonic,"Once the basic schedulability analysis is understood, some of the above"
rate-monotonic,assumptions can be relaxed and the side-effects accounted for.
rate-monotonic,The Processor Utilization Rule requires that processor utilization be
rate-monotonic,calculated based upon the period and execution time of each task.
rate-monotonic,The fraction of processor time spent executing task index is Time(i)
rate-monotonic,/ Period(i).  The processor utilization can be calculated as follows
rate-monotonic,where n is the number of tasks in the set being analyzed:
rate-monotonic,"To ensure schedulability even under transient overload, the processor"
rate-monotonic,utilization must adhere to the following rule:
rate-monotonic,"As the number of tasks increases, the above formula approaches ln(2) for a"
rate-monotonic,worst-case utilization factor of approximately 0.693.  Many tasks sets can be
rate-monotonic,"scheduled with a greater utilization factor.  In fact, the average processor"
rate-monotonic,utilization threshold for a randomly generated task set is approximately 0.88.
rate-monotonic,See more detail in [LL73].
rate-monotonic,This example illustrates the application of the Processor Utilization Rule to
rate-monotonic,an application with three critical periodic tasks.  The following table details
rate-monotonic,"the RMS priority, period, execution time, and processor utilization for each"
rate-monotonic,task:
rate-monotonic,Task
rate-monotonic,"RMS
Priority"
rate-monotonic,Period
rate-monotonic,"Execution
Time"
rate-monotonic,"Processor
Utilization"
rate-monotonic,1
rate-monotonic,High
rate-monotonic,100
rate-monotonic,15
rate-monotonic,0.15
rate-monotonic,2
rate-monotonic,Medium
rate-monotonic,200
rate-monotonic,50
rate-monotonic,0.25
rate-monotonic,3
rate-monotonic,Low
rate-monotonic,300
rate-monotonic,100
rate-monotonic,0.33
rate-monotonic,Task
rate-monotonic,RMS
rate-monotonic,Priority
rate-monotonic,Period
rate-monotonic,Execution
rate-monotonic,Time
rate-monotonic,Processor
rate-monotonic,Utilization
rate-monotonic,1
rate-monotonic,High
rate-monotonic,100
rate-monotonic,15
rate-monotonic,0.15
rate-monotonic,2
rate-monotonic,Medium
rate-monotonic,200
rate-monotonic,50
rate-monotonic,0.25
rate-monotonic,3
rate-monotonic,Low
rate-monotonic,300
rate-monotonic,100
rate-monotonic,0.33
rate-monotonic,The total processor utilization for this task set is 0.73 which is below the
rate-monotonic,"upper bound of 3 * (2**(1/3) - 1), or 0.779, imposed by the Processor"
rate-monotonic,"Utilization Rule.  Therefore, this task set is guaranteed to be schedulable"
rate-monotonic,using RMS.
rate-monotonic,If a given set of tasks do exceed the processor utilization upper limit imposed
rate-monotonic,"by the Processor Utilization Rule, they can still be guaranteed to meet all"
rate-monotonic,their deadlines by application of the First Deadline Rule.  This rule can be
rate-monotonic,stated as follows:
rate-monotonic,"For a given set of independent periodic tasks, if each task meets its first"
rate-monotonic,"deadline when all tasks are started at the same time, then the"
rate-monotonic,deadlines will always be met for any combination of start times.
rate-monotonic,A key point with this rule is that ALL periodic tasks are assumed to start at
rate-monotonic,the exact same instant in time.  Although this assumption may seem to be
rate-monotonic,"invalid, RTEMS makes it quite easy to ensure.  By having a non-preemptible user"
rate-monotonic,"initialization task, all application tasks, regardless of priority, can be"
rate-monotonic,created and started before the initialization deletes itself.  This technique
rate-monotonic,ensures that all tasks begin to compete for execution time at the same instant
rate-monotonic,- when the user initialization task deletes itself.
rate-monotonic,See more detail in [LSD89].
rate-monotonic,The First Deadline Rule can ensure schedulability even when the Processor
rate-monotonic,Utilization Rule fails.  The example below is a modification of the Processor
rate-monotonic,Utilization Rule example where task execution time has been increased from 15
rate-monotonic,"to 25 units.  The following table details the RMS priority, period, execution"
rate-monotonic,"time, and processor utilization for each task:"
rate-monotonic,Task
rate-monotonic,"RMS
Priority"
rate-monotonic,Period
rate-monotonic,"Execution
Time"
rate-monotonic,"Processor
Utilization"
rate-monotonic,1
rate-monotonic,High
rate-monotonic,100
rate-monotonic,25
rate-monotonic,0.25
rate-monotonic,2
rate-monotonic,Medium
rate-monotonic,200
rate-monotonic,50
rate-monotonic,0.25
rate-monotonic,3
rate-monotonic,Low
rate-monotonic,300
rate-monotonic,100
rate-monotonic,0.33
rate-monotonic,Task
rate-monotonic,RMS
rate-monotonic,Priority
rate-monotonic,Period
rate-monotonic,Execution
rate-monotonic,Time
rate-monotonic,Processor
rate-monotonic,Utilization
rate-monotonic,1
rate-monotonic,High
rate-monotonic,100
rate-monotonic,25
rate-monotonic,0.25
rate-monotonic,2
rate-monotonic,Medium
rate-monotonic,200
rate-monotonic,50
rate-monotonic,0.25
rate-monotonic,3
rate-monotonic,Low
rate-monotonic,300
rate-monotonic,100
rate-monotonic,0.33
rate-monotonic,The total processor utilization for the modified task set is 0.83 which is
rate-monotonic,"above the upper bound of 3 * (2**(1/3) - 1), or 0.779, imposed by the Processor"
rate-monotonic,"Utilization Rule.  Therefore, this task set is not guaranteed to be schedulable"
rate-monotonic,"using RMS.  However, the First Deadline Rule can guarantee the schedulability"
rate-monotonic,of this task set.  This rule calls for one to examine each occurrence of
rate-monotonic,deadline until either all tasks have met their deadline or one task failed to
rate-monotonic,meet its first deadline.  The following table details the time of each deadline
rate-monotonic,"occurrence, the maximum number of times each task may have run, the total"
rate-monotonic,"execution time, and whether all the deadlines have been met:"
rate-monotonic,"Deadline
Time"
rate-monotonic,"Task
1"
rate-monotonic,"Task
2"
rate-monotonic,"Task
3"
rate-monotonic,"Total
Execution Time"
rate-monotonic,"All Deadlines
Met?"
rate-monotonic,100
rate-monotonic,1
rate-monotonic,1
rate-monotonic,1
rate-monotonic,25 + 50 + 100 = 175
rate-monotonic,NO
rate-monotonic,200
rate-monotonic,2
rate-monotonic,1
rate-monotonic,1
rate-monotonic,50 + 50 + 100 = 200
rate-monotonic,YES
rate-monotonic,Deadline
rate-monotonic,Time
rate-monotonic,Task
rate-monotonic,1
rate-monotonic,Task
rate-monotonic,2
rate-monotonic,Task
rate-monotonic,3
rate-monotonic,Total
rate-monotonic,Execution Time
rate-monotonic,All Deadlines
rate-monotonic,Met?
rate-monotonic,100
rate-monotonic,1
rate-monotonic,1
rate-monotonic,1
rate-monotonic,25 + 50 + 100 = 175
rate-monotonic,NO
rate-monotonic,200
rate-monotonic,2
rate-monotonic,1
rate-monotonic,1
rate-monotonic,50 + 50 + 100 = 200
rate-monotonic,YES
rate-monotonic,The key to this analysis is to recognize when each task will execute.  For
rate-monotonic,"example at time 100, task 1 must have met its first deadline, but tasks 2 and 3"
rate-monotonic,"may also have begun execution.  In this example, at time 100 tasks 1 and 2 have"
rate-monotonic,completed execution and thus have met their first deadline.  Tasks 1 and 2 have
rate-monotonic,"used (25 + 50) = 75 time units, leaving (100 - 75) = 25 time units for task 3"
rate-monotonic,"to begin.  Because task 3 takes 100 ticks to execute, it will not have"
rate-monotonic,"completed execution at time 100.  Thus at time 100, all of the tasks except"
rate-monotonic,task 3 have met their first deadline.
rate-monotonic,"At time 200, task 1 must have met its second deadline and task 2 its first"
rate-monotonic,"deadline.  As a result, of the first 200 time units, task 1 uses (2 * 25) = 50"
rate-monotonic,"and task 2 uses 50, leaving (200 - 100) time units for task 3.  Task 3 requires"
rate-monotonic,"100 time units to execute, thus it will have completed execution at time 200."
rate-monotonic,"Thus, all of the tasks have met their first deadlines at time 200, and the task"
rate-monotonic,set is schedulable using the First Deadline Rule.
rate-monotonic,The assumptions used to develop the RMS schedulability rules are uncommon in
rate-monotonic,"most real-time systems.  For example, it was assumed that tasks have constant"
rate-monotonic,"unvarying execution time.  It is possible to relax this assumption, simply by"
rate-monotonic,using the worst-case execution time of each task.
rate-monotonic,Another assumption is that the tasks are independent.  This means that the
rate-monotonic,tasks do not wait for one another or contend for resources.  This assumption
rate-monotonic,can be relaxed by accounting for the amount of time a task spends waiting to
rate-monotonic,"acquire resources.  Similarly, each task’s execution time must account for any"
rate-monotonic,I/O performed and any RTEMS directive calls.
rate-monotonic,"In addition, the assumptions did not account for the time spent executing"
rate-monotonic,interrupt service routines.  This can be accounted for by including all the
rate-monotonic,processor utilization by interrupt service routines in the utilization
rate-monotonic,"calculation.  Similarly, one should also account for the impact of delays in"
rate-monotonic,accessing local memory caused by direct memory access and other processors
rate-monotonic,accessing local dual-ported memory.
rate-monotonic,The assumption that nonperiodic tasks are used only for initialization or
rate-monotonic,failure-recovery can be relaxed by placing all periodic tasks in the critical
rate-monotonic,task set.  This task set can be scheduled and analyzed using RMS.  All
rate-monotonic,nonperiodic tasks are placed in the non-critical task set.  Although the
rate-monotonic,"critical task set can be guaranteed to execute even under transient overload,"
rate-monotonic,the non-critical task set is not guaranteed to execute.
rate-monotonic,"In conclusion, the application designer must be fully cognizant of the system"
rate-monotonic,and its run-time behavior when performing schedulability analysis for a system
rate-monotonic,using RMS.  Every hardware and software factor which impacts the execution time
rate-monotonic,of each task must be accounted for in the schedulability analysis.
rate-monotonic,"© Copyright 1988, 2024 RTEMS Project and contributors."
rate-monotonic,The Rate-Monotonic Manager provides facilities to implement tasks which execute
rate-monotonic,"in a periodic fashion.  Critically, it also gathers information about the"
rate-monotonic,execution of those periods and can provide important statistics to the user
rate-monotonic,which can be used to analyze and tune the application. The directives provided
rate-monotonic,by the Rate-Monotonic Manager are:
rate-monotonic,rtems_rate_monotonic_create() - Creates a period.
rate-monotonic,rtems_rate_monotonic_ident() - Identifies a period by the object
rate-monotonic,name.
rate-monotonic,rtems_rate_monotonic_cancel() - Cancels the period.
rate-monotonic,rtems_rate_monotonic_delete() - Deletes the period.
rate-monotonic,rtems_rate_monotonic_period() - Concludes the current period and
rate-monotonic,"start the next period, or gets the period status."
rate-monotonic,rtems_rate_monotonic_get_status() - Gets the detailed status of the
rate-monotonic,period.
rate-monotonic,rtems_rate_monotonic_get_statistics() - Gets the statistics of the
rate-monotonic,period.
rate-monotonic,rtems_rate_monotonic_reset_statistics() - Resets the statistics of
rate-monotonic,the period.
rate-monotonic,rtems_rate_monotonic_reset_all_statistics() - Resets the statistics
rate-monotonic,of all periods.
rate-monotonic,rtems_rate_monotonic_report_statistics() - Reports the period
rate-monotonic,statistics using the printk() printer.
rate-monotonic,rtems_rate_monotonic_report_statistics_with_plugin() - Reports the
rate-monotonic,period statistics using the printer plugin.
rate-monotonic,rtems_rate_monotonic_create() - Creates a period.
rate-monotonic,rtems_rate_monotonic_ident() - Identifies a period by the object
rate-monotonic,name.
rate-monotonic,rtems_rate_monotonic_cancel() - Cancels the period.
rate-monotonic,rtems_rate_monotonic_delete() - Deletes the period.
rate-monotonic,rtems_rate_monotonic_period() - Concludes the current period and
rate-monotonic,"start the next period, or gets the period status."
rate-monotonic,rtems_rate_monotonic_get_status() - Gets the detailed status of the
rate-monotonic,period.
rate-monotonic,rtems_rate_monotonic_get_statistics() - Gets the statistics of the
rate-monotonic,period.
rate-monotonic,rtems_rate_monotonic_reset_statistics() - Resets the statistics of
rate-monotonic,the period.
rate-monotonic,rtems_rate_monotonic_reset_all_statistics() - Resets the statistics
rate-monotonic,of all periods.
rate-monotonic,rtems_rate_monotonic_report_statistics() - Reports the period
rate-monotonic,statistics using the printk() printer.
rate-monotonic,rtems_rate_monotonic_report_statistics_with_plugin() - Reports the
rate-monotonic,period statistics using the printer plugin.
rate-monotonic,"© Copyright 1988, 2024 RTEMS Project and contributors."
region,A region makes up a physically contiguous memory space with user-defined
region,boundaries from which variable-sized segments are dynamically allocated and
region,deallocated.  A segment is a variable size section of memory which is allocated
region,in multiples of a user-defined page size.  This page size is required to be a
region,"multiple of four greater than or equal to four.  For example, if a request for"
region,"a 350-byte segment is made in a region with 256-byte pages, then a 512-byte"
region,segment is allocated.
region,Regions are organized as doubly linked chains of variable sized memory blocks.
region,"Memory requests are allocated using a first-fit algorithm.  If available, the"
region,requester receives the number of bytes requested (rounded up to the next page
region,size).  RTEMS requires some overhead from the region’s memory for each segment
region,"that is allocated.  Therefore, an application should only modify the memory of"
region,a segment that has been obtained from the region.  The application should NOT
region,modify the memory outside of any obtained segments and within the region’s
region,boundaries while the region is currently active in the system.
region,"Upon return to the region, the free block is coalesced with its neighbors (if"
region,free) on both sides to produce the largest possible unused block.
region,"In general, an attribute set is built by a bitwise OR of the desired attribute"
region,components.  The set of valid region attributes is provided in the following
region,table:
region,RTEMS_FIFO
region,tasks wait by FIFO (default)
region,RTEMS_PRIORITY
region,tasks wait by priority
region,RTEMS_FIFO
region,tasks wait by FIFO (default)
region,RTEMS_PRIORITY
region,tasks wait by priority
region,"Attribute values are specifically designed to be mutually exclusive, therefore"
region,bitwise OR and addition operations are equivalent as long as each attribute
region,appears exactly once in the component list.  An attribute listed as a default
region,"is not required to appear in the attribute list, although it is a good"
region,programming practice to specify default attributes.  If all defaults are
region,"desired, the attribute RTEMS_DEFAULT_ATTRIBUTES should be specified on this"
region,call.
region,This example demonstrates the attribute_set parameter needed to create a region
region,with the task priority waiting queue discipline.  The attribute_set parameter
region,to the rtems_region_create directive should be RTEMS_PRIORITY.
region,"In general, an option is built by a bitwise OR of the desired option"
region,components.  The set of valid options for the rtems_region_get_segment
region,directive are listed in the following table:
region,RTEMS_WAIT
region,task will wait for segment (default)
region,RTEMS_NO_WAIT
region,task should not wait
region,RTEMS_WAIT
region,task will wait for segment (default)
region,RTEMS_NO_WAIT
region,task should not wait
region,"Option values are specifically designed to be mutually exclusive, therefore"
region,bitwise OR and addition operations are equivalent as long as each option
region,appears exactly once in the component list.  An option listed as a default is
region,"not required to appear in the option list, although it is a good programming"
region,"practice to specify default options.  If all defaults are desired, the"
region,option RTEMS_DEFAULT_OPTIONS should be specified on this call.
region,This example demonstrates the option parameter needed to poll for a segment.
region,The option parameter passed to the rtems_region_get_segment directive
region,should be RTEMS_NO_WAIT.
region,"© Copyright 1988, 2024 RTEMS Project and contributors."
region,The Region Manager provides facilities to dynamically allocate memory in
region,variable sized units. The directives provided by the Region Manager are:
region,rtems_region_create() - Creates a region.
region,rtems_region_ident() - Identifies a region by the object name.
region,rtems_region_delete() - Deletes the region.
region,rtems_region_extend() - Extends the region.
region,rtems_region_get_segment() - Gets a segment from the region.
region,rtems_region_return_segment() - Returns the segment to the region.
region,rtems_region_resize_segment() - Changes the size of the segment.
region,rtems_region_get_information() - Gets the region information.
region,rtems_region_get_free_information() - Gets the region free
region,information.
region,rtems_region_get_segment_size() - Gets the size of the region
region,segment.
region,rtems_region_create() - Creates a region.
region,rtems_region_ident() - Identifies a region by the object name.
region,rtems_region_delete() - Deletes the region.
region,rtems_region_extend() - Extends the region.
region,rtems_region_get_segment() - Gets a segment from the region.
region,rtems_region_return_segment() - Returns the segment to the region.
region,rtems_region_resize_segment() - Changes the size of the segment.
region,rtems_region_get_information() - Gets the region information.
region,rtems_region_get_free_information() - Gets the region free
region,information.
region,rtems_region_get_segment_size() - Gets the size of the region
region,segment.
region,"© Copyright 1988, 2024 RTEMS Project and contributors."
regulator,The regulator provides facilities to accept bursty input and buffer it
regulator,as needed before delivering it at a pre-defined periodic rate. The input
regulator,"is referred to as the Source, with the output referred to as the"
regulator,Destination. Messages are accepted from the Source and delivered to
regulator,the Destination by a user-provided Delivery function.
regulator,The Regulator implementation uses the RTEMS Classic API Partition Manager
regulator,to manage the buffer pool and the RTEMS Classic API Message Queue
regulator,Manager to send the buffer to the Delivery thread. The Delivery thread
regulator,invokes a user-provided delivery function to get the message to the
regulator,Destination.
regulator,The regulator is designed to sit logically between two entities – a
regulator,"source and a destination, where it limits the traffic sent to the"
regulator,destination to prevent it from being flooded with messages from the
regulator,source. This can be used to accommodate bursts of input from a source
regulator,and meter it out to a destination.  The maximum number of messages
regulator,which can be buffered in the regulator is specified by the
regulator,maximum_messages field in the rtems_regulator_attributes
regulator,structure passed as an argument to rtems_regulator_create().
regulator,The regulator library accepts an input stream of messages from a
regulator,source and delivers them to a destination. The regulator assumes that the
regulator,input stream from the source contains sporadic bursts of data which can
regulator,"exceed the acceptable rate of the destination. By limiting the message rate,"
regulator,the regulator prevents an overflow of messages.
regulator,The regulator can be configured for the input buffering required to manage
regulator,the maximum burst and for the metering rate for the delivery. The delivery
regulator,"rate is in messages per second. If the sender produces data too fast,"
regulator,the regulator will buffer the configured number of messages.
regulator,A configuration capability is provided to allow for adaptation to different
regulator,"message streams. The regulator can also support running multiple instances,"
regulator,which could be used on independent message streams.
regulator,It is assumed that the application has a design limit on the number of
regulator,"messages which may be buffered. All messages accepted by the regulator,"
regulator,"assuming no overflow on input, will eventually be output by the Delivery"
regulator,thread.
regulator,The Source sends buffers to the Regulator instance. The Regulator
regulator,then sends the buffer via a message queue which delivers them to the
regulator,Delivery thread.  The Delivery thread executes periodically at a rate
regulator,specified by the delivery_thread_period field in the
regulator,rtems_regulator_attributes structure passed as an argument
regulator,to rtems_regulator_create().
regulator,"During each period, the Delivery thread attempts to receive"
regulator,up to maximum_to_dequeue_per_period number of buffers and
regulator,invoke the Delivery function to deliver each of them to the
regulator,Destination. The maximum_to_dequeue_per_period field in the
regulator,rtems_regulator_attributes structure passed as an argument
regulator,to rtems_regulator_create().
regulator,"For example, consider a Source that may produce a burst of up to seven"
regulator,messages every five seconds. But the Destination cannot handle a burst
regulator,of seven and either drops messages or gives an error. This can be
regulator,accommodated by a Regulator instance configured as follows:
regulator,maximum_messages - 7
regulator,delivery_thread_period - one second
regulator,maximum_to_dequeue_per_period - 3
regulator,maximum_messages - 7
regulator,delivery_thread_period - one second
regulator,maximum_to_dequeue_per_period - 3
regulator,"In this scenario, the application will use the Delivery thread"
regulator,rtems_regulator_send() to enqueue the seven messages when they
regulator,arrive. The Delivery thread will deliver three messages per second. The
regulator,following illustrates this sequence:
regulator,Time 0: Source sends seven messages
regulator,Time 1: Delivery of messages 1 to 3
regulator,Time 3: Delivery of messages 4 to 6
regulator,Time 3: Delivery of message 7
regulator,Time 4: No messages to deliver
regulator,Time 0: Source sends seven messages
regulator,Time 1: Delivery of messages 1 to 3
regulator,Time 3: Delivery of messages 4 to 6
regulator,Time 3: Delivery of message 7
regulator,Time 4: No messages to deliver
regulator,This configuration of the regulator ensures that the Destination does
regulator,not overflow.
regulator,"© Copyright 1988, 2024 RTEMS Project and contributors."
regulator,The Regulator Manager provides a set of directives to manage a data flow
regulator,from a source to a destination. The focus is on regulating the bursty
regulator,input so that it is delivered to the destination at a regular rate.
regulator,The directives provided by the Regulator Manager are:
regulator,rtems_regulator_create() - Creates a regulator.
regulator,rtems_regulator_delete() - Deletes the regulator.
regulator,rtems_regulator_obtain_buffer() - Obtain buffer from a regulator.
regulator,rtems_regulator_release_buffer() - Release buffer to a regulator.
regulator,rtems_regulator_send() - Send buffer to a regulator.
regulator,rtems_regulator_get_statistics() - Obtain statistics for a regulator.
regulator,rtems_regulator_create() - Creates a regulator.
regulator,rtems_regulator_delete() - Deletes the regulator.
regulator,rtems_regulator_obtain_buffer() - Obtain buffer from a regulator.
regulator,rtems_regulator_release_buffer() - Release buffer to a regulator.
regulator,rtems_regulator_send() - Send buffer to a regulator.
regulator,rtems_regulator_get_statistics() - Obtain statistics for a regulator.
regulator,"© Copyright 1988, 2024 RTEMS Project and contributors."
scheduling-concepts,RTEMS provides a plugin framework that allows it to support multiple
scheduling-concepts,"scheduling algorithms. RTEMS includes multiple scheduling algorithms, and the"
scheduling-concepts,user can select which of these they wish to use in their application at
scheduling-concepts,"link-time.  In addition, the user can implement their own scheduling algorithm"
scheduling-concepts,and configure RTEMS to use it.
scheduling-concepts,Supporting multiple scheduling algorithms gives the end user the option to
scheduling-concepts,select the algorithm which is most appropriate to their use case. Most
scheduling-concepts,"real-time operating systems schedule tasks using a priority based algorithm,"
scheduling-concepts,possibly with preemption control.  The classic RTEMS scheduling algorithm which
scheduling-concepts,"was the only algorithm available in RTEMS 4.10 and earlier, is a fixed-priority"
scheduling-concepts,scheduling algorithm.  This scheduling algorithm is suitable for uniprocessor
scheduling-concepts,"(e.g., non-SMP) systems and is known as the Deterministic Priority"
scheduling-concepts,"Scheduler.  Unless the user configures another scheduling algorithm, RTEMS"
scheduling-concepts,will use this on uniprocessor systems.
scheduling-concepts,"When using priority based scheduling, RTEMS allocates the processor using a"
scheduling-concepts,"priority-based, preemptive algorithm augmented to provide round-robin"
scheduling-concepts,characteristics within individual priority groups.  The goal of this algorithm
scheduling-concepts,is to guarantee that the task which is executing on the processor at any point
scheduling-concepts,in time is the one with the highest priority among all tasks in the ready
scheduling-concepts,state.
scheduling-concepts,"When a task is added to the ready chain, it is placed behind all other tasks of"
scheduling-concepts,the same priority.  This rule provides a round-robin within a priority group
scheduling-concepts,"scheduling characteristic.  This means that in a group of equal priority tasks,"
scheduling-concepts,tasks will execute in the order they become ready or FIFO order.  Even though
scheduling-concepts,"there are ways to manipulate and adjust task priorities, the most important"
scheduling-concepts,rule to remember is:
scheduling-concepts,Note
scheduling-concepts,Priority based scheduling algorithms will always select the highest priority
scheduling-concepts,task that is ready to run when allocating the processor to a task.
scheduling-concepts,Priority scheduling is the most commonly used scheduling algorithm.  It should
scheduling-concepts,be used by applications in which multiple tasks contend for CPU time or other
scheduling-concepts,"resources, and there is a need to ensure certain tasks are given priority over"
scheduling-concepts,other tasks.
scheduling-concepts,There are a few common methods of accomplishing the mechanics of this
scheduling-concepts,algorithm.  These ways involve a list or chain of tasks in the ready state.
scheduling-concepts,The least efficient method is to randomly place tasks in the ready chain
scheduling-concepts,forcing the scheduler to scan the entire chain to determine which task
scheduling-concepts,receives the processor.
scheduling-concepts,A more efficient method is to schedule the task by placing it in the proper
scheduling-concepts,place on the ready chain based on the designated scheduling criteria at the
scheduling-concepts,"time it enters the ready state.  Thus, when the processor is free, the first"
scheduling-concepts,task on the ready chain is allocated the processor.
scheduling-concepts,Another mechanism is to maintain a list of FIFOs per priority.  When a task
scheduling-concepts,"is readied, it is placed on the rear of the FIFO for its priority.  This"
scheduling-concepts,method is often used with a bitmap to assist in locating which FIFOs have
scheduling-concepts,"ready tasks on them.  This data structure has \(O(1)\) insert, extract"
scheduling-concepts,and find highest ready run-time complexities.
scheduling-concepts,A red-black tree may be used for the ready queue with the priority as the
scheduling-concepts,"key.  This data structure has \(O(log(n))\) insert, extract and find"
scheduling-concepts,highest ready run-time complexities while \(n\) is the count of tasks in
scheduling-concepts,the ready queue.
scheduling-concepts,The least efficient method is to randomly place tasks in the ready chain
scheduling-concepts,forcing the scheduler to scan the entire chain to determine which task
scheduling-concepts,receives the processor.
scheduling-concepts,A more efficient method is to schedule the task by placing it in the proper
scheduling-concepts,place on the ready chain based on the designated scheduling criteria at the
scheduling-concepts,"time it enters the ready state.  Thus, when the processor is free, the first"
scheduling-concepts,task on the ready chain is allocated the processor.
scheduling-concepts,Another mechanism is to maintain a list of FIFOs per priority.  When a task
scheduling-concepts,"is readied, it is placed on the rear of the FIFO for its priority.  This"
scheduling-concepts,method is often used with a bitmap to assist in locating which FIFOs have
scheduling-concepts,"ready tasks on them.  This data structure has \(O(1)\) insert, extract"
scheduling-concepts,and find highest ready run-time complexities.
scheduling-concepts,A red-black tree may be used for the ready queue with the priority as the
scheduling-concepts,"key.  This data structure has \(O(log(n))\) insert, extract and find"
scheduling-concepts,highest ready run-time complexities while \(n\) is the count of tasks in
scheduling-concepts,the ready queue.
scheduling-concepts,RTEMS currently includes multiple priority based scheduling algorithms as well
scheduling-concepts,as other algorithms that incorporate deadline.  Each algorithm is discussed in
scheduling-concepts,the following sections.
scheduling-concepts,RTEMS provides four mechanisms which allow the user to alter the task
scheduling-concepts,scheduling decisions:
scheduling-concepts,user-selectable task priority level
scheduling-concepts,task preemption control
scheduling-concepts,task timeslicing control
scheduling-concepts,manual round-robin selection
scheduling-concepts,user-selectable task priority level
scheduling-concepts,task preemption control
scheduling-concepts,task timeslicing control
scheduling-concepts,manual round-robin selection
scheduling-concepts,Each of these methods provides a powerful capability to customize sets of tasks
scheduling-concepts,to satisfy the unique and particular requirements encountered in custom
scheduling-concepts,"real-time applications.  Although each mechanism operates independently, there"
scheduling-concepts,is a precedence relationship which governs the effects of scheduling
scheduling-concepts,modifications.  The evaluation order for scheduling characteristics is always
scheduling-concepts,"priority, preemption mode, and timeslicing.  When reading the descriptions of"
scheduling-concepts,timeslicing and manual round-robin it is important to keep in mind that
scheduling-concepts,preemption (if enabled) of a task by higher priority tasks will occur as
scheduling-concepts,"required, overriding the other factors presented in the description."
scheduling-concepts,The most significant task scheduling modification mechanism is the ability for
scheduling-concepts,the user to assign a priority level to each individual task when it is created
scheduling-concepts,"and to alter a task’s priority at run-time, see Task Priority."
scheduling-concepts,Another way the user can alter the basic scheduling algorithm is by
scheduling-concepts,manipulating the preemption mode flag (RTEMS_PREEMPT_MASK) of individual
scheduling-concepts,"tasks.  If preemption is disabled for a task (RTEMS_NO_PREEMPT), then the"
scheduling-concepts,"task will not relinquish control of the processor until it terminates, blocks,"
scheduling-concepts,or re-enables preemption.  Even tasks which become ready to run and possess
scheduling-concepts,higher priority levels will not be allowed to execute.  Note that the
scheduling-concepts,preemption setting has no effect on the manner in which a task is scheduled.
scheduling-concepts,It only applies once a task has control of the processor.
scheduling-concepts,Timeslicing or round-robin scheduling is an additional method which can be used
scheduling-concepts,"to alter the basic scheduling algorithm.  Like preemption, timeslicing is"
scheduling-concepts,specified on a task by task basis using the timeslicing mode flag
scheduling-concepts,(RTEMS_TIMESLICE_MASK).  If timeslicing is enabled for a task
scheduling-concepts,"(RTEMS_TIMESLICE), then RTEMS will limit the amount of time the task can"
scheduling-concepts,execute before the processor is allocated to another task.  Each tick of the
scheduling-concepts,real-time clock reduces the currently running task’s timeslice.  When the
scheduling-concepts,"execution time equals the timeslice, RTEMS will dispatch another task of the"
scheduling-concepts,same priority to execute.  If there are no other tasks of the same priority
scheduling-concepts,"ready to execute, then the current task is allocated an additional timeslice"
scheduling-concepts,and continues to run.  Remember that a higher priority task will preempt the
scheduling-concepts,"task (unless preemption is disabled) as soon as it is ready to run, even if the"
scheduling-concepts,task has not used up its entire timeslice.
scheduling-concepts,The final mechanism for altering the RTEMS scheduling algorithm is called
scheduling-concepts,manual round-robin.  Manual round-robin is invoked by using
scheduling-concepts,the rtems_task_wake_after directive with a ticks parameter of
scheduling-concepts,RTEMS_YIELD_PROCESSOR.  This allows a task to give up the processor and be
scheduling-concepts,immediately returned to the ready chain at the end of its priority group.  If
scheduling-concepts,"no other tasks of the same priority are ready to run, then the task does not"
scheduling-concepts,lose control of the processor.
scheduling-concepts,The dispatcher is the RTEMS component responsible for allocating the processor
scheduling-concepts,"to a ready task.  In order to allocate the processor to one task, it must be"
scheduling-concepts,deallocated or retrieved from the task currently using it.  This involves a
scheduling-concepts,"concept called a context switch.  To perform a context switch, the dispatcher"
scheduling-concepts,saves the context of the current task and restores the context of the task
scheduling-concepts,which has been allocated to the processor.  Saving and restoring a task’s
scheduling-concepts,context is the storing/loading of all the essential information about a task to
scheduling-concepts,enable it to continue execution without any effects of the interruption.  For
scheduling-concepts,"example, the contents of a task’s register set must be the same when it is"
scheduling-concepts,given the processor as they were when it was taken away.  All of the
scheduling-concepts,information that must be saved or restored for a context switch is located
scheduling-concepts,either in the TCB or on the task’s stacks.
scheduling-concepts,Tasks that utilize a numeric coprocessor and are created with the
scheduling-concepts,RTEMS_FLOATING_POINT attribute require additional operations during a
scheduling-concepts,context switch.  These additional operations are necessary to save and restore
scheduling-concepts,the floating point context of RTEMS_FLOATING_POINT tasks.  To avoid
scheduling-concepts,"unnecessary save and restore operations, the state of the numeric coprocessor"
scheduling-concepts,is only saved when a RTEMS_FLOATING_POINT task is dispatched and that task
scheduling-concepts,was not the last task to utilize the coprocessor.
scheduling-concepts,Tasks in an RTEMS system must always be in one of the five allowable task
scheduling-concepts,"states.  These states are: executing, ready, blocked, dormant, and"
scheduling-concepts,non-existent.
scheduling-concepts,A task occupies the non-existent state before a rtems_task_create has been
scheduling-concepts,issued on its behalf.  A task enters the non-existent state from any other
scheduling-concepts,state in the system when it is deleted with the rtems_task_delete
scheduling-concepts,directive.  While a task occupies this state it does not have a TCB or a task
scheduling-concepts,"ID assigned to it; therefore, no other tasks in the system may reference this"
scheduling-concepts,task.
scheduling-concepts,"When a task is created via the rtems_task_create directive, it enters the"
scheduling-concepts,dormant state.  This state is not entered through any other means.  Although
scheduling-concepts,"the task exists in the system, it cannot actively compete for system resources."
scheduling-concepts,It will remain in the dormant state until it is started via the
scheduling-concepts,"rtems_task_start directive, at which time it enters the ready state.  The"
scheduling-concepts,task is now permitted to be scheduled for the processor and to compete for
scheduling-concepts,other system resources.
scheduling-concepts,A task occupies the blocked state whenever it is unable to be scheduled to run.
scheduling-concepts,A running task may block itself or be blocked by other tasks in the system.
scheduling-concepts,The running task blocks itself through voluntary operations that cause the task
scheduling-concepts,to wait.  The only way a task can block a task other than itself is with the
scheduling-concepts,rtems_task_suspend directive.  A task enters the blocked state due to any
scheduling-concepts,of the following conditions:
scheduling-concepts,A task issues a rtems_task_suspend directive which blocks either itself
scheduling-concepts,or another task in the system.
scheduling-concepts,The running task issues a rtems_barrier_wait directive.
scheduling-concepts,The running task issues a rtems_message_queue_receive directive with the
scheduling-concepts,"wait option, and the message queue is empty."
scheduling-concepts,The running task issues a rtems_event_receive directive with the wait
scheduling-concepts,"option, and the currently pending events do not satisfy the request."
scheduling-concepts,The running task issues a rtems_semaphore_obtain directive with the wait
scheduling-concepts,option and the requested semaphore is unavailable.
scheduling-concepts,The running task issues a rtems_task_wake_after directive which blocks
scheduling-concepts,the task for the given count of ticks.  If the count of ticks specified is
scheduling-concepts,"zero, the task yields the processor and remains in the ready state."
scheduling-concepts,The running task issues a rtems_task_wake_when directive which blocks the
scheduling-concepts,task until the requested date and time arrives.
scheduling-concepts,The running task issues a rtems_rate_monotonic_period directive and must
scheduling-concepts,wait for the specified rate monotonic period to conclude.
scheduling-concepts,The running task issues a rtems_region_get_segment directive with the
scheduling-concepts,wait option and there is not an available segment large enough to satisfy the
scheduling-concepts,task’s request.
scheduling-concepts,A task issues a rtems_task_suspend directive which blocks either itself
scheduling-concepts,or another task in the system.
scheduling-concepts,The running task issues a rtems_barrier_wait directive.
scheduling-concepts,The running task issues a rtems_message_queue_receive directive with the
scheduling-concepts,"wait option, and the message queue is empty."
scheduling-concepts,The running task issues a rtems_event_receive directive with the wait
scheduling-concepts,"option, and the currently pending events do not satisfy the request."
scheduling-concepts,The running task issues a rtems_semaphore_obtain directive with the wait
scheduling-concepts,option and the requested semaphore is unavailable.
scheduling-concepts,The running task issues a rtems_task_wake_after directive which blocks
scheduling-concepts,the task for the given count of ticks.  If the count of ticks specified is
scheduling-concepts,"zero, the task yields the processor and remains in the ready state."
scheduling-concepts,The running task issues a rtems_task_wake_when directive which blocks the
scheduling-concepts,task until the requested date and time arrives.
scheduling-concepts,The running task issues a rtems_rate_monotonic_period directive and must
scheduling-concepts,wait for the specified rate monotonic period to conclude.
scheduling-concepts,The running task issues a rtems_region_get_segment directive with the
scheduling-concepts,wait option and there is not an available segment large enough to satisfy the
scheduling-concepts,task’s request.
scheduling-concepts,"A blocked task may also be suspended.  Therefore, both the suspension and the"
scheduling-concepts,blocking condition must be removed before the task becomes ready to run again.
scheduling-concepts,"A task occupies the ready state when it is able to be scheduled to run, but"
scheduling-concepts,currently does not have control of the processor.  Tasks of the same or higher
scheduling-concepts,"priority will yield the processor by either becoming blocked, completing their"
scheduling-concepts,"timeslice, or being deleted.  All tasks with the same priority will execute in"
scheduling-concepts,FIFO order.  A task enters the ready state due to any of the following
scheduling-concepts,conditions:
scheduling-concepts,A running task issues a rtems_task_resume directive for a task that is
scheduling-concepts,suspended and the task is not blocked waiting on any resource.
scheduling-concepts,"A running task issues a rtems_message_queue_send,"
scheduling-concepts,"rtems_message_queue_broadcast, or a rtems_message_queue_urgent"
scheduling-concepts,directive which posts a message to the queue on which the blocked task is
scheduling-concepts,waiting.
scheduling-concepts,A running task issues an rtems_event_send directive which sends an event
scheduling-concepts,condition to a task that is blocked waiting on that event condition.
scheduling-concepts,A running task issues a rtems_semaphore_release directive which releases
scheduling-concepts,the semaphore on which the blocked task is waiting.
scheduling-concepts,The requested count of ticks has elapsed for a task which was blocked by a
scheduling-concepts,call to the rtems_task_wake_after directive.
scheduling-concepts,A timeout period expires for a task which blocked by a call to the
scheduling-concepts,rtems_task_wake_when directive.
scheduling-concepts,A running task issues a rtems_region_return_segment directive which
scheduling-concepts,releases a segment to the region on which the blocked task is waiting and a
scheduling-concepts,resulting segment is large enough to satisfy the task’s request.
scheduling-concepts,A rate monotonic period expires for a task which blocked by a call to the
scheduling-concepts,rtems_rate_monotonic_period directive.
scheduling-concepts,"A timeout interval expires for a task which was blocked waiting on a message,"
scheduling-concepts,"event, semaphore, or segment with a timeout specified."
scheduling-concepts,"A running task issues a directive which deletes a message queue, a semaphore,"
scheduling-concepts,or a region on which the blocked task is waiting.
scheduling-concepts,A running task issues a rtems_task_restart directive for the blocked
scheduling-concepts,task.
scheduling-concepts,"The running task, with its preemption mode enabled, may be made ready by"
scheduling-concepts,issuing any of the directives that may unblock a task with a higher priority.
scheduling-concepts,This directive may be issued from the running task itself or from an ISR.  A
scheduling-concepts,ready task occupies the executing state when it has control of the CPU.  A
scheduling-concepts,task enters the executing state due to any of the following conditions:
scheduling-concepts,The task is the highest priority ready task in the system.
scheduling-concepts,The running task blocks and the task is next in the scheduling queue.  The
scheduling-concepts,task may be of equal priority as in round-robin scheduling or the task may
scheduling-concepts,possess the highest priority of the remaining ready tasks.
scheduling-concepts,The running task may reenable its preemption mode and a task exists in the
scheduling-concepts,ready queue that has a higher priority than the running task.
scheduling-concepts,The running task lowers its own priority and another task is of higher
scheduling-concepts,priority as a result.
scheduling-concepts,The running task raises the priority of a task above its own and the running
scheduling-concepts,task is in preemption mode.
scheduling-concepts,A running task issues a rtems_task_resume directive for a task that is
scheduling-concepts,suspended and the task is not blocked waiting on any resource.
scheduling-concepts,"A running task issues a rtems_message_queue_send,"
scheduling-concepts,"rtems_message_queue_broadcast, or a rtems_message_queue_urgent"
scheduling-concepts,directive which posts a message to the queue on which the blocked task is
scheduling-concepts,waiting.
scheduling-concepts,A running task issues an rtems_event_send directive which sends an event
scheduling-concepts,condition to a task that is blocked waiting on that event condition.
scheduling-concepts,A running task issues a rtems_semaphore_release directive which releases
scheduling-concepts,the semaphore on which the blocked task is waiting.
scheduling-concepts,The requested count of ticks has elapsed for a task which was blocked by a
scheduling-concepts,call to the rtems_task_wake_after directive.
scheduling-concepts,A timeout period expires for a task which blocked by a call to the
scheduling-concepts,rtems_task_wake_when directive.
scheduling-concepts,A running task issues a rtems_region_return_segment directive which
scheduling-concepts,releases a segment to the region on which the blocked task is waiting and a
scheduling-concepts,resulting segment is large enough to satisfy the task’s request.
scheduling-concepts,A rate monotonic period expires for a task which blocked by a call to the
scheduling-concepts,rtems_rate_monotonic_period directive.
scheduling-concepts,"A timeout interval expires for a task which was blocked waiting on a message,"
scheduling-concepts,"event, semaphore, or segment with a timeout specified."
scheduling-concepts,"A running task issues a directive which deletes a message queue, a semaphore,"
scheduling-concepts,or a region on which the blocked task is waiting.
scheduling-concepts,A running task issues a rtems_task_restart directive for the blocked
scheduling-concepts,task.
scheduling-concepts,"The running task, with its preemption mode enabled, may be made ready by"
scheduling-concepts,issuing any of the directives that may unblock a task with a higher priority.
scheduling-concepts,This directive may be issued from the running task itself or from an ISR.  A
scheduling-concepts,ready task occupies the executing state when it has control of the CPU.  A
scheduling-concepts,task enters the executing state due to any of the following conditions:
scheduling-concepts,The task is the highest priority ready task in the system.
scheduling-concepts,The running task blocks and the task is next in the scheduling queue.  The
scheduling-concepts,task may be of equal priority as in round-robin scheduling or the task may
scheduling-concepts,possess the highest priority of the remaining ready tasks.
scheduling-concepts,The running task may reenable its preemption mode and a task exists in the
scheduling-concepts,ready queue that has a higher priority than the running task.
scheduling-concepts,The running task lowers its own priority and another task is of higher
scheduling-concepts,priority as a result.
scheduling-concepts,The running task raises the priority of a task above its own and the running
scheduling-concepts,task is in preemption mode.
scheduling-concepts,"© Copyright 1988, 2024 RTEMS Project and contributors."
scheduling-concepts,The scheduling concepts relate to the allocation of processing time for tasks.
scheduling-concepts,The concept of scheduling in real-time systems dictates the ability to provide
scheduling-concepts,"an immediate response to specific external events, particularly the necessity"
scheduling-concepts,of scheduling tasks to run within a specified time limit after the occurrence
scheduling-concepts,"of an event. For example, software embedded in life-support systems used to"
scheduling-concepts,monitor hospital patients must take instant action if a change in the patient’s
scheduling-concepts,status is detected.
scheduling-concepts,The component of RTEMS responsible for providing this capability is
scheduling-concepts,appropriately called the scheduler. The scheduler’s sole purpose is to allocate
scheduling-concepts,the all important resource of processor time to the various tasks competing for
scheduling-concepts,attention. The directives provided by the Scheduler Manager are:
scheduling-concepts,rtems_scheduler_ident() - Identifies a scheduler by the object
scheduling-concepts,name.
scheduling-concepts,rtems_scheduler_ident_by_processor() - Identifies a scheduler by
scheduling-concepts,the processor index.
scheduling-concepts,rtems_scheduler_ident_by_processor_set() - Identifies a scheduler by
scheduling-concepts,the processor set.
scheduling-concepts,rtems_scheduler_get_maximum_priority() - Gets the maximum task
scheduling-concepts,priority of the scheduler.
scheduling-concepts,rtems_scheduler_map_priority_to_posix() - Maps a Classic API task
scheduling-concepts,priority to the corresponding POSIX thread priority.
scheduling-concepts,rtems_scheduler_map_priority_from_posix() - Maps a POSIX thread
scheduling-concepts,priority to the corresponding Classic API task priority.
scheduling-concepts,rtems_scheduler_get_processor() - Returns the index of the current
scheduling-concepts,processor.
scheduling-concepts,rtems_scheduler_get_processor_maximum() - Returns the processor
scheduling-concepts,maximum supported by the system.
scheduling-concepts,rtems_scheduler_get_processor_set() - Gets the set of processors
scheduling-concepts,owned by the scheduler.
scheduling-concepts,rtems_scheduler_add_processor() - Adds the processor to the set of
scheduling-concepts,processors owned by the scheduler.
scheduling-concepts,rtems_scheduler_remove_processor() - Removes the processor from
scheduling-concepts,the set of processors owned by the scheduler.
scheduling-concepts,rtems_scheduler_ident() - Identifies a scheduler by the object
scheduling-concepts,name.
scheduling-concepts,rtems_scheduler_ident_by_processor() - Identifies a scheduler by
scheduling-concepts,the processor index.
scheduling-concepts,rtems_scheduler_ident_by_processor_set() - Identifies a scheduler by
scheduling-concepts,the processor set.
scheduling-concepts,rtems_scheduler_get_maximum_priority() - Gets the maximum task
scheduling-concepts,priority of the scheduler.
scheduling-concepts,rtems_scheduler_map_priority_to_posix() - Maps a Classic API task
scheduling-concepts,priority to the corresponding POSIX thread priority.
scheduling-concepts,rtems_scheduler_map_priority_from_posix() - Maps a POSIX thread
scheduling-concepts,priority to the corresponding Classic API task priority.
scheduling-concepts,rtems_scheduler_get_processor() - Returns the index of the current
scheduling-concepts,processor.
scheduling-concepts,rtems_scheduler_get_processor_maximum() - Returns the processor
scheduling-concepts,maximum supported by the system.
scheduling-concepts,rtems_scheduler_get_processor_set() - Gets the set of processors
scheduling-concepts,owned by the scheduler.
scheduling-concepts,rtems_scheduler_add_processor() - Adds the processor to the set of
scheduling-concepts,processors owned by the scheduler.
scheduling-concepts,rtems_scheduler_remove_processor() - Removes the processor from
scheduling-concepts,the set of processors owned by the scheduler.
scheduling-concepts,"© Copyright 1988, 2024 RTEMS Project and contributors."
semaphore,A semaphore can be viewed as a protected variable whose value can be modified
semaphore,"only with the rtems_semaphore_create, rtems_semaphore_obtain, and"
semaphore,rtems_semaphore_release directives.  RTEMS supports both binary and
semaphore,"counting semaphores. A binary semaphore is restricted to values of zero or one,"
semaphore,while a counting semaphore can assume any non-negative integer value.
semaphore,A binary semaphore (not a simple binary semaphore) can be used to control
semaphore,"access to a single resource.  In particular, it can be used to enforce mutual"
semaphore,"exclusion for a critical section in user code (mutex).  In this instance, the"
semaphore,semaphore would be created with an initial count of one to indicate that no
semaphore,task is executing the critical section of code.  Upon entry to the critical
semaphore,"section, a task must issue the rtems_semaphore_obtain directive to prevent"
semaphore,other tasks from entering the critical section.  Upon exit from the critical
semaphore,"section, the task that obtained the binary semaphore must issue the"
semaphore,rtems_semaphore_release directive to allow another task to execute the
semaphore,critical section.  A binary semaphore must be released by the task that
semaphore,obtained it.
semaphore,A counting semaphore can be used to control access to a pool of two or more
semaphore,"resources.  For example, access to three printers could be administered by a"
semaphore,semaphore created with an initial count of three.  When a task requires access
semaphore,"to one of the printers, it issues the rtems_semaphore_obtain directive to"
semaphore,"obtain access to a printer.  If a printer is not currently available, the task"
semaphore,can wait for a printer to become available or return immediately.  When the
semaphore,"task has completed printing, it should issue the rtems_semaphore_release"
semaphore,directive to allow other tasks access to the printer.
semaphore,Task synchronization may be achieved by creating a semaphore with an initial
semaphore,count of zero.  One task waits for the arrival of another task by issuing a
semaphore,rtems_semaphore_obtain directive when it reaches a synchronization point.
semaphore,The other task performs a corresponding rtems_semaphore_release operation
semaphore,"when it reaches its synchronization point, thus unblocking the pending task."
semaphore,Deadlock occurs when a task owning a binary semaphore attempts to acquire that
semaphore,same semaphore and blocks as result.  Since the semaphore is allocated to a
semaphore,"task, it cannot be deleted.  Therefore, the task that currently holds the"
semaphore,semaphore and is also blocked waiting for that semaphore will never execute
semaphore,again.
semaphore,RTEMS addresses this problem by allowing the task holding the binary semaphore
semaphore,to obtain the same binary semaphore multiple times in a nested manner.  Each
semaphore,rtems_semaphore_obtain must be accompanied with a
semaphore,rtems_semaphore_release.  The semaphore will only be made available for
semaphore,acquisition by other tasks when the outermost rtems_semaphore_obtain is
semaphore,matched with a rtems_semaphore_release.
semaphore,Simple binary semaphores do not allow nested access and so can be used for task
semaphore,synchronization.
semaphore,"RTEMS supports priority inheritance for local,"
semaphore,binary semaphores that use the priority task wait queue blocking discipline.
semaphore,"In SMP configurations, the O(m) Independence-Preserving Protocol (OMIP) is used instead."
semaphore,"RTEMS supports priority ceiling for local, binary"
semaphore,semaphores that use the priority task wait queue blocking discipline.
semaphore,"RTEMS supports the Multiprocessor Resource Sharing Protocol (MrsP) for local, binary semaphores that use the"
semaphore,"priority task wait queue blocking discipline.  In uniprocessor configurations,"
semaphore,the Immediate Ceiling Priority Protocol (ICPP) is used instead.
semaphore,"In general, an attribute set is built by a bitwise OR of the desired attribute"
semaphore,components.  The following table lists the set of valid semaphore attributes:
semaphore,RTEMS_FIFO
semaphore,tasks wait by FIFO (default)
semaphore,RTEMS_PRIORITY
semaphore,tasks wait by priority
semaphore,RTEMS_BINARY_SEMAPHORE
semaphore,restrict values to 0 and 1
semaphore,RTEMS_COUNTING_SEMAPHORE
semaphore,no restriction on values (default)
semaphore,RTEMS_SIMPLE_BINARY_SEMAPHORE
semaphore,"restrict values to 0 and 1, do not allow nested access, allow deletion of
locked semaphore."
semaphore,RTEMS_NO_INHERIT_PRIORITY
semaphore,do not use priority inheritance (default)
semaphore,RTEMS_INHERIT_PRIORITY
semaphore,use priority inheritance
semaphore,RTEMS_NO_PRIORITY_CEILING
semaphore,do not use priority ceiling (default)
semaphore,RTEMS_PRIORITY_CEILING
semaphore,use priority ceiling
semaphore,RTEMS_NO_MULTIPROCESSOR_RESOURCE_SHARING
semaphore,do not use Multiprocessor Resource Sharing Protocol (default)
semaphore,RTEMS_MULTIPROCESSOR_RESOURCE_SHARING
semaphore,use Multiprocessor Resource Sharing Protocol
semaphore,RTEMS_LOCAL
semaphore,local semaphore (default)
semaphore,RTEMS_GLOBAL
semaphore,global semaphore
semaphore,RTEMS_FIFO
semaphore,tasks wait by FIFO (default)
semaphore,RTEMS_PRIORITY
semaphore,tasks wait by priority
semaphore,RTEMS_BINARY_SEMAPHORE
semaphore,restrict values to 0 and 1
semaphore,RTEMS_COUNTING_SEMAPHORE
semaphore,no restriction on values (default)
semaphore,RTEMS_SIMPLE_BINARY_SEMAPHORE
semaphore,"restrict values to 0 and 1, do not allow nested access, allow deletion of"
semaphore,locked semaphore.
semaphore,RTEMS_NO_INHERIT_PRIORITY
semaphore,do not use priority inheritance (default)
semaphore,RTEMS_INHERIT_PRIORITY
semaphore,use priority inheritance
semaphore,RTEMS_NO_PRIORITY_CEILING
semaphore,do not use priority ceiling (default)
semaphore,RTEMS_PRIORITY_CEILING
semaphore,use priority ceiling
semaphore,RTEMS_NO_MULTIPROCESSOR_RESOURCE_SHARING
semaphore,do not use Multiprocessor Resource Sharing Protocol (default)
semaphore,RTEMS_MULTIPROCESSOR_RESOURCE_SHARING
semaphore,use Multiprocessor Resource Sharing Protocol
semaphore,RTEMS_LOCAL
semaphore,local semaphore (default)
semaphore,RTEMS_GLOBAL
semaphore,global semaphore
semaphore,"Attribute values are specifically designed to be mutually exclusive, therefore"
semaphore,bitwise OR and addition operations are equivalent as long as each attribute
semaphore,appears exactly once in the component list.  An attribute listed as a default
semaphore,"is not required to appear in the attribute list, although it is a good"
semaphore,programming practice to specify default attributes.  If all defaults are
semaphore,"desired, the attribute RTEMS_DEFAULT_ATTRIBUTES should be specified on this"
semaphore,call.
semaphore,This example demonstrates the attribute_set parameter needed to create a local
semaphore,semaphore with the task priority waiting queue discipline.  The attribute_set
semaphore,parameter passed to the rtems_semaphore_create directive could be either
semaphore,RTEMS_PRIORITY or RTEMS_LOCAL | RTEMS_PRIORITY.  The attribute_set
semaphore,parameter can be set to RTEMS_PRIORITY because RTEMS_LOCAL is the
semaphore,default for all created tasks.  If a similar semaphore were to be known
semaphore,"globally, then the attribute_set parameter would be RTEMS_GLOBAL |"
semaphore,RTEMS_PRIORITY.
semaphore,"Some combinatinos of these attributes are invalid.  For example, priority"
semaphore,ordered blocking discipline must be applied to a binary semaphore in order to
semaphore,use either the priority inheritance or priority ceiling functionality.  The
semaphore,following tree figure illustrates the valid combinations.
semaphore,"In general, an option is built by a bitwise OR of the desired option"
semaphore,components.  The set of valid options for the rtems_semaphore_obtain
semaphore,directive are listed in the following table:
semaphore,RTEMS_WAIT
semaphore,task will wait for semaphore (default)
semaphore,RTEMS_NO_WAIT
semaphore,task should not wait
semaphore,RTEMS_WAIT
semaphore,task will wait for semaphore (default)
semaphore,RTEMS_NO_WAIT
semaphore,task should not wait
semaphore,"Option values are specifically designed to be mutually exclusive, therefore"
semaphore,bitwise OR and addition operations are equivalent as long as each attribute
semaphore,appears exactly once in the component list.  An option listed as a default is
semaphore,"not required to appear in the list, although it is a good programming practice"
semaphore,"to specify default options.  If all defaults are desired, the option"
semaphore,RTEMS_DEFAULT_OPTIONS should be specified on this call.
semaphore,This example demonstrates the option parameter needed to poll for a semaphore.
semaphore,The option parameter passed to the rtems_semaphore_obtain directive should
semaphore,be RTEMS_NO_WAIT.
semaphore,"© Copyright 1988, 2024 RTEMS Project and contributors."
semaphore,The Semaphore Manager utilizes standard Dijkstra counting semaphores to provide
semaphore,synchronization and mutual exclusion capabilities. The directives provided by
semaphore,the Semaphore Manager are:
semaphore,rtems_semaphore_create() - Creates a semaphore.
semaphore,rtems_semaphore_ident() - Identifies a semaphore by the object
semaphore,name.
semaphore,rtems_semaphore_delete() - Deletes the semaphore.
semaphore,rtems_semaphore_obtain() - Obtains the semaphore.
semaphore,rtems_semaphore_release() - Releases the semaphore.
semaphore,rtems_semaphore_flush() - Flushes the semaphore.
semaphore,rtems_semaphore_set_priority() - Sets the priority by scheduler
semaphore,for the semaphore.
semaphore,rtems_semaphore_create() - Creates a semaphore.
semaphore,rtems_semaphore_ident() - Identifies a semaphore by the object
semaphore,name.
semaphore,rtems_semaphore_delete() - Deletes the semaphore.
semaphore,rtems_semaphore_obtain() - Obtains the semaphore.
semaphore,rtems_semaphore_release() - Releases the semaphore.
semaphore,rtems_semaphore_flush() - Flushes the semaphore.
semaphore,rtems_semaphore_set_priority() - Sets the priority by scheduler
semaphore,for the semaphore.
semaphore,"© Copyright 1988, 2024 RTEMS Project and contributors."
signal,The signal manager allows a task to optionally define an asynchronous signal
signal,routine (ASR).  An ASR is to a task what an ISR is to an application’s set of
signal,"tasks.  When the processor is interrupted, the execution of an application is"
signal,"also interrupted and an ISR is given control.  Similarly, when a signal is sent"
signal,"to a task, that task’s execution path will be “interrupted” by the ASR."
signal,Sending a signal to a task has no effect on the receiving task’s current
signal,execution state.
signal,A signal flag is used by a task (or ISR) to inform another task of the
signal,occurrence of a significant situation.  Thirty-two signal flags are associated
signal,with each task.  A collection of one or more signals is referred to as a signal
signal,set.  The data type rtems_signal_set is used to manipulate signal sets.
signal,A signal set is posted when it is directed (or sent) to a task. A pending
signal,"signal is a signal that has been sent to a task with a valid ASR, but has not"
signal,been processed by that task’s ASR.
signal,The format of an ASR is similar to that of an ISR with the following
signal,exceptions:
signal,ISRs are scheduled by the processor hardware.  ASRs are scheduled by RTEMS.
signal,ISRs do not execute in the context of a task and may invoke only a subset of
signal,directives.  ASRs execute in the context of a task and may execute any
signal,directive.
signal,"When an ISR is invoked, it is passed the vector number as its argument.  When"
signal,"an ASR is invoked, it is passed the signal set as its argument."
signal,An ASR has a task mode which can be different from that of the task.  An ISR
signal,"does not execute as a task and, as a result, does not have a task mode."
signal,ISRs are scheduled by the processor hardware.  ASRs are scheduled by RTEMS.
signal,ISRs do not execute in the context of a task and may invoke only a subset of
signal,directives.  ASRs execute in the context of a task and may execute any
signal,directive.
signal,"When an ISR is invoked, it is passed the vector number as its argument.  When"
signal,"an ASR is invoked, it is passed the signal set as its argument."
signal,An ASR has a task mode which can be different from that of the task.  An ISR
signal,"does not execute as a task and, as a result, does not have a task mode."
signal,A signal set is built by a bitwise OR of the desired signals.  The set of valid
signal,signals is RTEMS_SIGNAL_0 through RTEMS_SIGNAL_31.  If a signal is not
signal,"explicitly specified in the signal set, then it is not present.  Signal values"
signal,"are specifically designed to be mutually exclusive, therefore bitwise OR and"
signal,addition operations are equivalent as long as each signal appears exactly once
signal,in the component list.
signal,This example demonstrates the signal parameter used when sending the signal set
signal,"consisting of RTEMS_SIGNAL_6, RTEMS_SIGNAL_15, and RTEMS_SIGNAL_31."
signal,The signal parameter provided to the rtems_signal_send directive should be
signal,RTEMS_SIGNAL_6 | RTEMS_SIGNAL_15 | RTEMS_SIGNAL_31.
signal,"In general, an ASR’s mode is built by a bitwise OR of the desired mode"
signal,components.  The set of valid mode components is the same as those allowed with
signal,the task_create and task_mode directives.  A complete list of mode options is
signal,provided in the following table:
signal,RTEMS_PREEMPT
signal,is masked by RTEMS_PREEMPT_MASK and enables preemption
signal,RTEMS_NO_PREEMPT
signal,is masked by RTEMS_PREEMPT_MASK and disables preemption
signal,RTEMS_NO_TIMESLICE
signal,is masked by RTEMS_TIMESLICE_MASK and disables timeslicing
signal,RTEMS_TIMESLICE
signal,is masked by RTEMS_TIMESLICE_MASK and enables timeslicing
signal,RTEMS_ASR
signal,is masked by RTEMS_ASR_MASK and enables ASR processing
signal,RTEMS_NO_ASR
signal,is masked by RTEMS_ASR_MASK and disables ASR processing
signal,RTEMS_INTERRUPT_LEVEL(0)
signal,is masked by RTEMS_INTERRUPT_MASK and enables all interrupts
signal,RTEMS_INTERRUPT_LEVEL(n)
signal,is masked by RTEMS_INTERRUPT_MASK and sets interrupts level n
signal,RTEMS_PREEMPT
signal,is masked by RTEMS_PREEMPT_MASK and enables preemption
signal,RTEMS_NO_PREEMPT
signal,is masked by RTEMS_PREEMPT_MASK and disables preemption
signal,RTEMS_NO_TIMESLICE
signal,is masked by RTEMS_TIMESLICE_MASK and disables timeslicing
signal,RTEMS_TIMESLICE
signal,is masked by RTEMS_TIMESLICE_MASK and enables timeslicing
signal,RTEMS_ASR
signal,is masked by RTEMS_ASR_MASK and enables ASR processing
signal,RTEMS_NO_ASR
signal,is masked by RTEMS_ASR_MASK and disables ASR processing
signal,RTEMS_INTERRUPT_LEVEL(0)
signal,is masked by RTEMS_INTERRUPT_MASK and enables all interrupts
signal,RTEMS_INTERRUPT_LEVEL(n)
signal,is masked by RTEMS_INTERRUPT_MASK and sets interrupts level n
signal,"Mode values are specifically designed to be mutually exclusive, therefore"
signal,bitwise OR and addition operations are equivalent as long as each mode appears
signal,exactly once in the component list.  A mode component listed as a default is
signal,"not required to appear in the mode list, although it is a good programming"
signal,"practice to specify default components.  If all defaults are desired, the mode"
signal,DEFAULT_MODES should be specified on this call.
signal,This example demonstrates the mode parameter used with the
signal,rtems_signal_catch to establish an ASR which executes at interrupt level
signal,three and is non-preemptible.  The mode should be set to
signal,RTEMS_INTERRUPT_LEVEL(3) | RTEMS_NO_PREEMPT to indicate the desired
signal,processor mode and interrupt level.
signal,"© Copyright 1988, 2024 RTEMS Project and contributors."
signal,The Signal Manager provides the capabilities required for asynchronous
signal,communication. The directives provided by the Signal Manager are:
signal,rtems_signal_catch() - Establishes an asynchronous signal routine
signal,(ASR) for the calling task.
signal,rtems_signal_send() - Sends the signal set to the task.
signal,rtems_signal_catch() - Establishes an asynchronous signal routine
signal,(ASR) for the calling task.
signal,rtems_signal_send() - Sends the signal set to the task.
signal,"© Copyright 1988, 2024 RTEMS Project and contributors."
task,Many definitions of a task have been proposed in computer literature.
task,"Unfortunately, none of these definitions encompasses all facets of the concept"
task,in a manner which is operating system independent.  Several of the more common
task,definitions are provided to enable each user to select a definition which best
task,matches their own experience and understanding of the task concept:
task,a “dispatchable” unit.
task,an entity to which the processor is allocated.
task,"an atomic unit of a real-time, multiprocessor system."
task,single threads of execution which concurrently compete for resources.
task,a sequence of closely related computations which can execute concurrently
task,with other computational sequences.
task,a “dispatchable” unit.
task,an entity to which the processor is allocated.
task,"an atomic unit of a real-time, multiprocessor system."
task,single threads of execution which concurrently compete for resources.
task,a sequence of closely related computations which can execute concurrently
task,with other computational sequences.
task,"From RTEMS’ perspective, a task is the smallest thread of execution which can"
task,compete on its own for system resources.  A task is manifested by the existence
task,of a task control block (TCB).
task,The Task Control Block (TCB) is an RTEMS defined data structure which contains
task,all the information that is pertinent to the execution of a task.  During
task,"system initialization, RTEMS reserves a TCB for each task configured.  A TCB is"
task,allocated upon creation of the task and is returned to the TCB free list upon
task,deletion of the task.
task,The TCB’s elements are modified as a result of system calls made by the
task,application in response to external and internal stimuli.  TCBs are the only
task,RTEMS internal data structure that can be accessed by an application via user
task,"extension routines.  The TCB contains a task’s name, ID, current priority,"
task,"current and starting states, execution mode, TCB user extension pointer,"
task,"scheduling control structures, as well as data required by a blocked task."
task,A task’s context is stored in the TCB when a task switch occurs.  When the task
task,"regains control of the processor, its context is restored from the TCB.  When a"
task,"task is restarted, the initial state of the task is restored from the starting"
task,context area in the task’s TCB.
task,The system uses two separate memory areas to manage a task.  One memory area is
task,the Task Control Block.  The other memory area is allocated from the stack
task,space or provided by the user and contains
task,"the task stack,"
task,"the thread-local storage (TLS), and"
task,an optional architecture-specific floating-point context.
task,"the task stack,"
task,"the thread-local storage (TLS), and"
task,an optional architecture-specific floating-point context.
task,The size of the thread-local storage is determined at link time.  A
task,user-provided task stack must take the size of the thread-local storage into
task,account.
task,"On architectures with a dedicated floating-point context, the application"
task,"configuration assumes that every task is a floating-point task, but whether or"
task,not a task is actually floating-point is determined at runtime during task
task,creation (see Floating Point Considerations).  In highly memory
task,constrained systems this potential overestimate of the task stack space can be
task,mitigated through the CONFIGURE_MINIMUM_TASK_STACK_SIZE configuration
task,option and aligned task stack sizes for the tasks.  A user-provided task stack
task,must take the potential floating-point context into account.
task,"By default, the task name is defined by the task object name given to"
task,rtems_task_create().  The task name can be obtained
task,with the pthread_getname_np() function.
task,"Optionally, a new task name may be set with the pthread_setname_np() function."
task,The maximum size of a task name is defined by the application configuration
task,option CONFIGURE_MAXIMUM_THREAD_NAME_SIZE.
task,A task may exist in one of the following five states:
task,executing - Currently scheduled to the CPU
task,ready - May be scheduled to the CPU
task,blocked - Unable to be scheduled to the CPU
task,dormant - Created task that is not started
task,non-existent - Uncreated or deleted task
task,executing - Currently scheduled to the CPU
task,ready - May be scheduled to the CPU
task,blocked - Unable to be scheduled to the CPU
task,dormant - Created task that is not started
task,non-existent - Uncreated or deleted task
task,"An active task may occupy the executing, ready, blocked or dormant state,"
task,otherwise the task is considered non-existent.  One or more tasks may be active
task,"in the system simultaneously.  Multiple tasks communicate, synchronize, and"
task,compete for system resources with each other via system calls.  The multiple
task,"tasks appear to execute in parallel, but actually each is dispatched to the CPU"
task,for periods of time determined by the RTEMS scheduling algorithm.  The
task,scheduling of a task is based on its current state and priority.
task,A task’s priority determines its importance in relation to the other
task,"tasks executing on the processor set owned by a scheduler.  Normally,"
task,RTEMS supports 256 levels of priority ranging from 0 to 255.  The priority
task,level 0 represents a special priority reserved for the operating system.  The
task,data type rtems_task_priority is used to store task priorities.  The
task,"maximum priority level depends on the configured scheduler, see"
task,"CONFIGURE_MAXIMUM_PRIORITY, Clustered Scheduler Configuration, and"
task,Scheduling Concepts.
task,Tasks of numerically smaller priority values are more important tasks than
task,"tasks of numerically larger priority values.  For example, a task at priority"
task,level 5 is of higher privilege than a task at priority level 10.  There is no
task,limit to the number of tasks assigned to the same priority.
task,Each task has a priority associated with it at all times.  The initial value of
task,this priority is assigned at task creation time.  The priority of a task may be
task,changed at any subsequent time.
task,Priorities are used by the scheduler to determine which ready task will be
task,"allowed to execute.  In general, the higher the logical priority of a task, the"
task,more likely it is to receive processor execution time.
task,A task’s execution mode is a combination of the following four components:
task,preemption
task,ASR processing
task,timeslicing
task,interrupt level
task,preemption
task,ASR processing
task,timeslicing
task,interrupt level
task,It is used to modify RTEMS’ scheduling process and to alter the execution
task,environment of the task.  The data type rtems_task_mode is used to manage
task,the task execution mode.
task,The preemption component allows a task to determine when control of the
task,"processor is relinquished.  If preemption is disabled (RTEMS_NO_PREEMPT),"
task,the task will retain control of the processor as long as it is in the executing
task,state - even if a higher priority task is made ready.  If preemption is enabled
task,"(RTEMS_PREEMPT) and a higher priority task is made ready, then the"
task,processor will be taken away from the current task immediately and given to the
task,higher priority task.
task,The timeslicing component is used by the RTEMS scheduler to determine how the
task,processor is allocated to tasks of equal priority.  If timeslicing is enabled
task,"(RTEMS_TIMESLICE), then RTEMS will limit the amount of time the task can"
task,execute before the processor is allocated to another ready task of equal
task,priority. The length of the timeslice is application dependent and specified in
task,"the Configuration Table.  If timeslicing is disabled (RTEMS_NO_TIMESLICE),"
task,then the task will be allowed to execute until a task of higher priority is
task,"made ready.  If RTEMS_NO_PREEMPT is selected, then the timeslicing component"
task,is ignored by the scheduler.
task,The asynchronous signal processing component is used to determine when received
task,signals are to be processed by the task.  If signal processing is enabled
task,"(RTEMS_ASR), then signals sent to the task will be processed the next time"
task,"the task executes.  If signal processing is disabled (RTEMS_NO_ASR), then"
task,all signals received by the task will remain posted until signal processing is
task,enabled.  This component affects only tasks which have established a routine to
task,process asynchronous signals.
task,The interrupt level component is used to determine which interrupts will be
task,enabled when the task is executing. RTEMS_INTERRUPT_LEVEL(n) specifies that
task,the task will execute at interrupt level n.
task,RTEMS_PREEMPT
task,enable preemption (default)
task,RTEMS_NO_PREEMPT
task,disable preemption
task,RTEMS_NO_TIMESLICE
task,disable timeslicing (default)
task,RTEMS_TIMESLICE
task,enable timeslicing
task,RTEMS_ASR
task,enable ASR processing (default)
task,RTEMS_NO_ASR
task,disable ASR processing
task,RTEMS_INTERRUPT_LEVEL(0)
task,enable all interrupts (default)
task,RTEMS_INTERRUPT_LEVEL(n)
task,execute at interrupt level n
task,RTEMS_PREEMPT
task,enable preemption (default)
task,RTEMS_NO_PREEMPT
task,disable preemption
task,RTEMS_NO_TIMESLICE
task,disable timeslicing (default)
task,RTEMS_TIMESLICE
task,enable timeslicing
task,RTEMS_ASR
task,enable ASR processing (default)
task,RTEMS_NO_ASR
task,disable ASR processing
task,RTEMS_INTERRUPT_LEVEL(0)
task,enable all interrupts (default)
task,RTEMS_INTERRUPT_LEVEL(n)
task,execute at interrupt level n
task,The set of default modes may be selected by specifying the
task,RTEMS_DEFAULT_MODES constant.
task,"Independent of the task state with respect to the scheduler, the task life is"
task,determined by several orthogonal states:
task,protected or unprotected
task,deferred life changes or no deferred life changes
task,restarting or not restarting
task,terminating or not terminating
task,detached or not detached
task,protected or unprotected
task,deferred life changes or no deferred life changes
task,restarting or not restarting
task,terminating or not terminating
task,detached or not detached
task,"While the task life is protected, asynchronous task restart and termination"
task,requests are blocked.  A task may still restart or terminate itself.  All tasks
task,are created with an unprotected task life.  The task life protection is used by
task,the system to prevent system resources being affected by asynchronous task
task,restart and termination requests.  The task life protection can be enabled
task,(PTHREAD_CANCEL_DISABLE) or disabled (PTHREAD_CANCEL_ENABLE) for the
task,calling task through the pthread_setcancelstate() directive.
task,"While deferred life changes are enabled, asynchronous task restart and"
task,termination requests are delayed until the task performs a life change itself
task,or calls pthread_testcancel().  Cancellation points are not implemented in
task,RTEMS.  Deferred task life changes can be enabled (PTHREAD_CANCEL_DEFERRED)
task,or disabled (PTHREAD_CANCEL_ASYNCHRONOUS) for the calling task through the
task,pthread_setcanceltype() directive.  Classic API tasks are created with
task,deferred life changes disabled.  POSIX threads are created with deferred life
task,changes enabled.
task,A task is made restarting by issuing a task restart request through the
task,rtems_task_restart() directive.
task,A task is made terminating by issuing a task termination request through the
task,"rtems_task_exit(), rtems_task_delete(),"
task,"pthread_exit(), and pthread_cancel() directives."
task,"When a detached task terminates, the termination procedure completes without"
task,the need for another task to join with the terminated task.  Classic API tasks
task,are created as not detached.  The detached state of created POSIX threads is
task,determined by the thread attributes.  They are created as not detached by
task,default.  The calling task is made detached through the pthread_detach()
task,directive.  The rtems_task_exit() directive and self deletion
task,though rtems_task_delete() directive make the calling task
task,"detached.  In contrast, the pthread_exit() directive does not change the"
task,detached state of the calling task.
task,All RTEMS tasks are invoked with a single argument which is specified when they
task,are started or restarted.  The argument is commonly used to communicate startup
task,information to the task.  The simplest manner in which to define a task which
task,accesses it argument is:
task,Application tasks requiring more information may view this single argument as
task,an index into an array of parameter blocks.
task,Please consult the RTEMS CPU Architecture Supplement if this section is
task,relevant on your architecture.  On some architectures the floating-point context
task,is contained in the normal task context and this section does not apply.
task,Creating a task with the RTEMS_FLOATING_POINT attribute flag results in
task,additional memory being allocated for the task to store the state of the numeric
task,coprocessor during task switches.  This additional memory is not allocated
task,for RTEMS_NO_FLOATING_POINT tasks. Saving and restoring the context of a
task,RTEMS_FLOATING_POINT task takes longer than that of a
task,RTEMS_NO_FLOATING_POINT task because of the relatively large amount of time
task,required for the numeric coprocessor to save or restore its computational state.
task,Since RTEMS was designed specifically for embedded military applications which
task,"are floating point intensive, the executive is optimized to avoid unnecessarily"
task,saving and restoring the state of the numeric coprocessor.  In uniprocessor
task,"configurations, the state of the numeric coprocessor is only saved when a"
task,RTEMS_FLOATING_POINT task is dispatched and that task was not the last task
task,to utilize the coprocessor.  In a uniprocessor system with only one
task,"RTEMS_FLOATING_POINT task, the state of the numeric coprocessor will never"
task,be saved or restored.
task,"Although the overhead imposed by RTEMS_FLOATING_POINT tasks is minimal,"
task,some applications may wish to completely avoid the overhead associated with
task,RTEMS_FLOATING_POINT tasks and still utilize a numeric coprocessor.  By
task,preventing a task from being preempted while performing a sequence of floating
task,"point operations, a RTEMS_NO_FLOATING_POINT task can utilize the numeric"
task,coprocessor without incurring the overhead of a RTEMS_FLOATING_POINT
task,context switch.  This approach also avoids the allocation of a floating point
task,"context area.  However, if this approach is taken by the application designer,"
task,"no tasks should be created as RTEMS_FLOATING_POINT tasks.  Otherwise, the"
task,floating point context will not be correctly maintained because RTEMS assumes
task,that the state of the numeric coprocessor will not be altered by
task,RTEMS_NO_FLOATING_POINT tasks.  Some architectures with a dedicated
task,floating-point context raise a processor exception if a task with
task,"RTEMS_NO_FLOATING_POINT issues a floating-point instruction, so this"
task,approach may not work at all.
task,If the supported processor type does not have hardware floating capabilities or
task,"a standard numeric coprocessor, RTEMS will not provide built-in support for"
task,"hardware floating point on that processor.  In this case, all tasks are"
task,considered RTEMS_NO_FLOATING_POINT whether created as
task,RTEMS_FLOATING_POINT or RTEMS_NO_FLOATING_POINT tasks.  A floating
task,point emulation software library must be utilized for floating point
task,operations.
task,"On some processors, it is possible to disable the floating point unit"
task,"dynamically.  If this capability is supported by the target processor, then"
task,RTEMS will utilize this capability to enable the floating point unit only for
task,tasks which are created with the RTEMS_FLOATING_POINT attribute.  The
task,consequence of a RTEMS_NO_FLOATING_POINT task attempting to access the
task,floating point unit is CPU dependent but will generally result in an exception
task,condition.
task,"In general, an attribute set is built by a bitwise OR of the desired"
task,components.  The set of valid task attribute components is listed below:
task,RTEMS_NO_FLOATING_POINT
task,does not use coprocessor (default)
task,RTEMS_FLOATING_POINT
task,uses numeric coprocessor
task,RTEMS_LOCAL
task,local task (default)
task,RTEMS_GLOBAL
task,global task
task,RTEMS_NO_FLOATING_POINT
task,does not use coprocessor (default)
task,RTEMS_FLOATING_POINT
task,uses numeric coprocessor
task,RTEMS_LOCAL
task,local task (default)
task,RTEMS_GLOBAL
task,global task
task,"Attribute values are specifically designed to be mutually exclusive, therefore"
task,bitwise OR and addition operations are equivalent as long as each attribute
task,appears exactly once in the component list.  A component listed as a default is
task,"not required to appear in the component list, although it is a good programming"
task,"practice to specify default components.  If all defaults are desired, then"
task,RTEMS_DEFAULT_ATTRIBUTES should be used.
task,This example demonstrates the attribute_set parameter needed to create a local
task,task which utilizes the numeric coprocessor.  The attribute_set parameter could
task,be RTEMS_FLOATING_POINT or RTEMS_LOCAL | RTEMS_FLOATING_POINT.  The
task,attribute_set parameter can be set to RTEMS_FLOATING_POINT because
task,RTEMS_LOCAL is the default for all created tasks.  If the task were global
task,"and used the numeric coprocessor, then the attribute_set parameter would be"
task,RTEMS_GLOBAL | RTEMS_FLOATING_POINT.
task,"In general, a mode and its corresponding mask is built by a bitwise OR of the"
task,desired components.  The set of valid mode constants and each mode’s
task,corresponding mask constant is listed below:
task,RTEMS_PREEMPT
task,is masked by RTEMS_PREEMPT_MASK and enables preemption
task,RTEMS_NO_PREEMPT
task,is masked by RTEMS_PREEMPT_MASK and disables preemption
task,RTEMS_NO_TIMESLICE
task,is masked by RTEMS_TIMESLICE_MASK and disables timeslicing
task,RTEMS_TIMESLICE
task,is masked by RTEMS_TIMESLICE_MASK and enables timeslicing
task,RTEMS_ASR
task,is masked by RTEMS_ASR_MASK and enables ASR processing
task,RTEMS_NO_ASR
task,is masked by RTEMS_ASR_MASK and disables ASR processing
task,RTEMS_INTERRUPT_LEVEL(0)
task,is masked by RTEMS_INTERRUPT_MASK and enables all interrupts
task,RTEMS_INTERRUPT_LEVEL(n)
task,is masked by RTEMS_INTERRUPT_MASK and sets interrupts level n
task,RTEMS_PREEMPT
task,is masked by RTEMS_PREEMPT_MASK and enables preemption
task,RTEMS_NO_PREEMPT
task,is masked by RTEMS_PREEMPT_MASK and disables preemption
task,RTEMS_NO_TIMESLICE
task,is masked by RTEMS_TIMESLICE_MASK and disables timeslicing
task,RTEMS_TIMESLICE
task,is masked by RTEMS_TIMESLICE_MASK and enables timeslicing
task,RTEMS_ASR
task,is masked by RTEMS_ASR_MASK and enables ASR processing
task,RTEMS_NO_ASR
task,is masked by RTEMS_ASR_MASK and disables ASR processing
task,RTEMS_INTERRUPT_LEVEL(0)
task,is masked by RTEMS_INTERRUPT_MASK and enables all interrupts
task,RTEMS_INTERRUPT_LEVEL(n)
task,is masked by RTEMS_INTERRUPT_MASK and sets interrupts level n
task,"Mode values are specifically designed to be mutually exclusive, therefore"
task,bitwise OR and addition operations are equivalent as long as each mode appears
task,exactly once in the component list.  A mode component listed as a default is
task,"not required to appear in the mode component list, although it is a good"
task,programming practice to specify default components.  If all defaults are
task,"desired, the mode RTEMS_DEFAULT_MODES and the mask RTEMS_ALL_MODE_MASKS"
task,should be used.
task,The following example demonstrates the mode and mask parameters used with the
task,rtems_task_mode directive to place a task at interrupt level 3 and make it
task,non-preemptible.  The mode should be set to RTEMS_INTERRUPT_LEVEL(3) |
task,"RTEMS_NO_PREEMPT to indicate the desired preemption mode and interrupt level,"
task,while the mask parameter should be set to RTEMS_INTERRUPT_MASK |
task,RTEMS_NO_PREEMPT_MASK to indicate that the calling task’s interrupt level and
task,preemption mode are being altered.
task,"© Copyright 1988, 2024 RTEMS Project and contributors."
task,"The Task Manager provides a comprehensive set of directives to create, delete,"
task,and administer tasks. The directives provided by the Task Manager are:
task,rtems_task_create() - Creates a task.
task,rtems_task_construct() - Constructs a task from the specified
task,task configuration.
task,rtems_task_ident() - Identifies a task by the object name.
task,rtems_task_self() - Gets the task identifier of the calling task.
task,rtems_task_start() - Starts the task.
task,rtems_task_restart() - Restarts the task.
task,rtems_task_delete() - Deletes the task.
task,rtems_task_exit() - Deletes the calling task.
task,rtems_task_suspend() - Suspends the task.
task,rtems_task_resume() - Resumes the task.
task,rtems_task_is_suspended() - Checks if the task is suspended.
task,rtems_task_set_priority() - Sets the real priority or gets the
task,current priority of the task.
task,rtems_task_get_priority() - Gets the current priority of the task
task,with respect to the scheduler.
task,rtems_task_mode() - Gets and optionally sets the mode of the
task,calling task.
task,rtems_task_wake_after() - Wakes up after a count of clock
task,ticks have occurred or yields the processor.
task,rtems_task_wake_when() - Wakes up when specified.
task,rtems_task_get_scheduler() - Gets the home scheduler of the task.
task,rtems_task_set_scheduler() - Sets the home scheduler for the task.
task,rtems_task_get_affinity() - Gets the processor affinity of the
task,task.
task,rtems_task_set_affinity() - Sets the processor affinity of the
task,task.
task,rtems_task_iterate() - Iterates over all tasks and invokes the
task,visitor routine for each task.
task,RTEMS_TASK_STORAGE_SIZE() - Gets the recommended task storage area
task,size for the size and task attributes.
task,rtems_task_create() - Creates a task.
task,rtems_task_construct() - Constructs a task from the specified
task,task configuration.
task,rtems_task_ident() - Identifies a task by the object name.
task,rtems_task_self() - Gets the task identifier of the calling task.
task,rtems_task_start() - Starts the task.
task,rtems_task_restart() - Restarts the task.
task,rtems_task_delete() - Deletes the task.
task,rtems_task_exit() - Deletes the calling task.
task,rtems_task_suspend() - Suspends the task.
task,rtems_task_resume() - Resumes the task.
task,rtems_task_is_suspended() - Checks if the task is suspended.
task,rtems_task_set_priority() - Sets the real priority or gets the
task,current priority of the task.
task,rtems_task_get_priority() - Gets the current priority of the task
task,with respect to the scheduler.
task,rtems_task_mode() - Gets and optionally sets the mode of the
task,calling task.
task,rtems_task_wake_after() - Wakes up after a count of clock
task,ticks have occurred or yields the processor.
task,rtems_task_wake_when() - Wakes up when specified.
task,rtems_task_get_scheduler() - Gets the home scheduler of the task.
task,rtems_task_set_scheduler() - Sets the home scheduler for the task.
task,rtems_task_get_affinity() - Gets the processor affinity of the
task,task.
task,rtems_task_set_affinity() - Sets the processor affinity of the
task,task.
task,rtems_task_iterate() - Iterates over all tasks and invokes the
task,visitor routine for each task.
task,RTEMS_TASK_STORAGE_SIZE() - Gets the recommended task storage area
task,size for the size and task attributes.
task,"© Copyright 1988, 2024 RTEMS Project and contributors."
timer,A clock tick is required to support the functionality provided by this manager.
timer,A timer is an RTEMS object which allows the application to schedule operations
timer,to occur at specific times in the future.  User supplied timer service routines
timer,are invoked by either a clock tick directive or a special Timer
timer,Server task when the timer fires.  Timer service routines may perform any
timer,operations or directives which normally would be performed by the application
timer,code which invoked a clock tick directive.
timer,The timer can be used to implement watchdog routines which only fire to denote
timer,that an application error has occurred.  The timer is reset at specific points
timer,"in the application to ensure that the watchdog does not fire.  Thus, if the"
timer,"application does not reset the watchdog timer, then the timer service routine"
timer,will fire to indicate that the application has failed to reach a reset point.
timer,This use of a timer is sometimes referred to as a “keep alive” or a “deadman”
timer,timer.
timer,The Timer Server task is responsible for executing the timer service routines
timer,associated with all task-based timers.  This task executes at a priority
timer,specified by rtems_timer_initiate_server()
timer,and it may have a priority of zero (the highest priority).  In uniprocessor
timer,"configurations, it is created non-preemptible."
timer,By providing a mechanism where timer service routines execute in task rather
timer,"than interrupt space, the application is allowed a bit more flexibility in what"
timer,"operations a timer service routine can perform.  For example, the Timer Server"
timer,can be configured to have a floating point context in which case it would be
timer,safe to perform floating point operations from a task-based timer.  Most of the
timer,"time, executing floating point instructions from an interrupt service routine"
timer,is not considered safe. The timer service routines invoked by the Timer Server
timer,"may block, however, since this blocks the Timer Server itself, other timer"
timer,service routines that are already pending do not run until the blocked timer
timer,service routine finished its work.
timer,The Timer Server is designed to remain blocked until a task-based timer fires.
timer,This reduces the execution overhead of the Timer Server.
timer,The timer service routine should adhere to C calling conventions and have a
timer,prototype similar to the following:
timer,Where the timer_id parameter is the RTEMS object ID of the timer which is being
timer,fired and user_data is a pointer to user-defined information which may be
timer,utilized by the timer service routine.  The argument user_data may be NULL.
timer,"© Copyright 1988, 2024 RTEMS Project and contributors."
timer,The Timer Manager provides support for timer facilities. The directives
timer,provided by the Timer Manager are:
timer,rtems_timer_create() - Creates a timer.
timer,rtems_timer_ident() - Identifies a timer by the object name.
timer,rtems_timer_cancel() - Cancels the timer.
timer,rtems_timer_delete() - Deletes the timer.
timer,rtems_timer_fire_after() - Fires the timer after the interval.
timer,rtems_timer_fire_when() - Fires the timer at the time of day.
timer,rtems_timer_initiate_server() - Initiates the Timer Server.
timer,rtems_timer_server_fire_after() - Fires the timer after the
timer,interval using the Timer Server.
timer,rtems_timer_server_fire_when() - Fires the timer at the time of day
timer,using the Timer Server.
timer,rtems_timer_reset() - Resets the timer.
timer,rtems_timer_get_information() - Gets information about the timer.
timer,rtems_timer_create() - Creates a timer.
timer,rtems_timer_ident() - Identifies a timer by the object name.
timer,rtems_timer_cancel() - Cancels the timer.
timer,rtems_timer_delete() - Deletes the timer.
timer,rtems_timer_fire_after() - Fires the timer after the interval.
timer,rtems_timer_fire_when() - Fires the timer at the time of day.
timer,rtems_timer_initiate_server() - Initiates the Timer Server.
timer,rtems_timer_server_fire_after() - Fires the timer after the
timer,interval using the Timer Server.
timer,rtems_timer_server_fire_when() - Fires the timer at the time of day
timer,using the Timer Server.
timer,rtems_timer_reset() - Resets the timer.
timer,rtems_timer_get_information() - Gets information about the timer.
timer,"© Copyright 1988, 2024 RTEMS Project and contributors."
user-extensions,User extensions (call-back functions) are invoked by the system when the
user-extensions,following events occur
user-extensions,"thread creation,"
user-extensions,"thread start,"
user-extensions,"thread restart,"
user-extensions,"thread switch,"
user-extensions,"thread begin,"
user-extensions,"thread exitted (return from thread entry function),"
user-extensions,"thread termination,"
user-extensions,"thread deletion, and"
user-extensions,fatal error detection (system termination).
user-extensions,"thread creation,"
user-extensions,"thread start,"
user-extensions,"thread restart,"
user-extensions,"thread switch,"
user-extensions,"thread begin,"
user-extensions,"thread exitted (return from thread entry function),"
user-extensions,"thread termination,"
user-extensions,"thread deletion, and"
user-extensions,fatal error detection (system termination).
user-extensions,"The user extensions have event-specific arguments, invocation orders and"
user-extensions,execution contexts.  Extension sets can be installed at run-time via
user-extensions,rtems_extension_create() (dynamic extension
user-extensions,sets) or at link-time via the application configuration option
user-extensions,CONFIGURE_INITIAL_EXTENSIONS (initial
user-extensions,extension sets).
user-extensions,The execution context of user extensions varies.  Some user extensions are
user-extensions,invoked with ownership of the allocator mutex.  The allocator mutex protects
user-extensions,dynamic memory allocations and object creation/deletion.  Some user extensions
user-extensions,are invoked with thread dispatching disabled.  The fatal error extension is
user-extensions,invoked in an arbitrary context.
user-extensions,User extensions are maintained as a set.  All user extensions are optional and
user-extensions,may be NULL.  Together a set of these user extensions typically performs a
user-extensions,specific functionality such as performance monitoring or debugger support.  The
user-extensions,extension set is defined via the following structure.
user-extensions,There is no system-provided storage for the initial extension sets.
user-extensions,The task control block (TCB) contains a pointer for each dynamic extension set.
user-extensions,The pointer is initialized to NULL during thread initialization before the
user-extensions,thread create extension is invoked.  The pointer may be used by the dynamic
user-extensions,extension set to maintain thread-specific data.
user-extensions,The TCB extension is an array of pointers in the TCB. The index into the table
user-extensions,can be obtained from the extension identifier returned when the extension
user-extensions,object is created:
user-extensions,The number of pointers in the area is the same as the number of dynamic user
user-extensions,extension sets configured.  This allows an application to augment the TCB with
user-extensions,"user-defined information.  For example, an application could implement task"
user-extensions,profiling by storing timing statistics in the TCB’s extended memory area.  When
user-extensions,"a task context switch is being executed, the thread switch extension could read"
user-extensions,a real-time clock to calculate how long the task being swapped out has run as
user-extensions,well as timestamp the starting time for the task being swapped in.
user-extensions,"If used, the extended memory area for the TCB should be allocated and the TCB"
user-extensions,extension pointer should be set at the time the task is created or started by
user-extensions,either the thread create or thread start extension.  The application is
user-extensions,responsible for managing this extended memory area for the TCBs.  The memory
user-extensions,may be reinitialized by the thread restart extension and should be deallocated
user-extensions,by the thread delete extension  when the task is deleted.  Since the TCB
user-extensions,"extension buffers would most likely be of a fixed size, the RTEMS partition"
user-extensions,manager could be used to manage the application’s extended memory area.  The
user-extensions,application could create a partition of fixed size TCB extension buffers and
user-extensions,use the partition manager’s allocation and deallocation directives to obtain
user-extensions,and release the extension buffers.
user-extensions,The user extensions are invoked in either extension forward order or
user-extensions,extension reverse order.  By invoking the user extensions in these
user-extensions,"orders, extensions can be built upon one another.  At the following system"
user-extensions,"events, the user extensions are invoked in forward order"
user-extensions,"thread creation,"
user-extensions,"thread start,"
user-extensions,"thread restart,"
user-extensions,"thread switch,"
user-extensions,"thread begin,"
user-extensions,"thread exitted (return from thread entry function), and"
user-extensions,fatal error detection.
user-extensions,"thread creation,"
user-extensions,"thread start,"
user-extensions,"thread restart,"
user-extensions,"thread switch,"
user-extensions,"thread begin,"
user-extensions,"thread exitted (return from thread entry function), and"
user-extensions,fatal error detection.
user-extensions,"At the following system events, the user extensions are invoked in reverse"
user-extensions,order:
user-extensions,"thread termination, and"
user-extensions,thread deletion.
user-extensions,"thread termination, and"
user-extensions,thread deletion.
user-extensions,"At these system events, the user extensions are invoked in reverse order to insure"
user-extensions,"that if an extension set is built upon another, the more complicated user extension"
user-extensions,is invoked before the user extension it is built upon.  An example is use of the
user-extensions,thread delete extension by the Standard C Library.  Extension sets which are
user-extensions,installed after the Standard C Library will operate correctly even if they
user-extensions,utilize the C Library because the C Library’s thread delete extension is
user-extensions,invoked after that of the other thread delete extensions.
user-extensions,"The thread create extension is invoked during thread creation, for example"
user-extensions,via rtems_task_create() or pthread_create().
user-extensions,The thread create extension is defined as follows.
user-extensions,The executing is a pointer to the TCB of the currently executing
user-extensions,thread.  The created is a pointer to the TCB of the created thread.
user-extensions,The created thread is completely initialized with respect to the operating
user-extensions,system.
user-extensions,The executing thread is the owner of the allocator mutex except during creation
user-extensions,of the idle threads.  Since the allocator mutex allows nesting the normal
user-extensions,memory allocation routines can be used.
user-extensions,A thread create extension will frequently attempt to allocate resources.  If
user-extensions,"this allocation fails, then the thread create extension must return"
user-extensions,"false and the entire thread create operation will fail, otherwise it"
user-extensions,must return true.
user-extensions,The thread create extension is invoked in forward order with thread dispatching
user-extensions,enabled (except during system initialization).
user-extensions,"The thread start extension is invoked during a thread start, for example"
user-extensions,via rtems_task_start() or pthread_create().
user-extensions,The thread start extension is defined as follows.
user-extensions,The executing is a pointer to the TCB of the currently executing
user-extensions,thread.  The started is a pointer to the TCB of the started thread.
user-extensions,It is invoked after the environment of the started thread has been loaded and the
user-extensions,"started thread has been made ready.  So, in SMP configurations, the thread may"
user-extensions,already run on another processor before the thread start extension is actually
user-extensions,invoked.  Thread switch and thread begin extensions may run before or in
user-extensions,parallel with the thread start extension in SMP configurations.
user-extensions,The thread start extension is invoked in forward order with thread dispatching
user-extensions,disabled.
user-extensions,"The thread restart extension is invoked during a thread restart, for example"
user-extensions,via rtems_task_restart().
user-extensions,The thread restart extension is defined as follows.
user-extensions,Both executing and restarted are pointers the TCB of the
user-extensions,currently executing thread.  It is invoked in the context of the executing
user-extensions,thread right before the execution context is reloaded.  The thread stack
user-extensions,reflects the previous execution context.
user-extensions,The thread restart extension is invoked in forward order with thread
user-extensions,dispatching enabled (except during system initialization).  The thread life is
user-extensions,protected.  Thread restart and delete requests issued by thread restart
user-extensions,"extensions lead to recursion.  The POSIX cleanup handlers, POSIX key"
user-extensions,destructors and thread-local object destructors run in this context.
user-extensions,The thread switch extension is defined as follows.
user-extensions,The invocation conditions of the thread switch extension depend on whether RTEMS
user-extensions,was configured for uniprocessor or SMP systems.  A user must pay attention to
user-extensions,the differences to correctly implement a thread switch extension.
user-extensions,"In uniprocessor configurations, the thread switch extension is invoked before"
user-extensions,the context switch from the currently executing thread to the heir thread.  The
user-extensions,executing is a pointer to the TCB of the currently executing thread.
user-extensions,The heir is a pointer to the TCB of the heir thread.  The context
user-extensions,switch initiated through the multitasking start is not covered by the thread
user-extensions,switch extension.
user-extensions,"In SMP configurations, the thread switch extension is invoked after the context"
user-extensions,switch to the new executing thread (previous heir thread).  The
user-extensions,executing is a pointer to the TCB of the previously executing thread.
user-extensions,"Despite the name, this is not the currently executing thread.  The"
user-extensions,heir is a pointer to the TCB of the newly executing thread.  This is
user-extensions,the currently executing thread.  The context switches initiated through the
user-extensions,multitasking start are covered by the thread switch extension.  The reason for
user-extensions,the differences to uniprocessor configurations is that the context switch may
user-extensions,"update the heir thread of the processor, see Thread Dispatch Details."
user-extensions,The thread switch extensions are invoked with disabled interrupts and with
user-extensions,ownership of a per-processor SMP lock.  Thread switch extensions may run in
user-extensions,parallel on multiple processors.  It is recommended to use thread-local or
user-extensions,per-processor data structures for thread switch extensions.  A global SMP lock
user-extensions,should be avoided for performance reasons.
user-extensions,The thread switch extension is invoked in forward order with thread dispatching
user-extensions,disabled.
user-extensions,The thread begin extension is invoked during a thread begin before the thread
user-extensions,entry function is called.  The thread begin extension is defined as follows.
user-extensions,The executing is a pointer to the TCB of the currently executing
user-extensions,thread.  The thread begin extension executes in a normal thread context and may
user-extensions,"allocate resources for the executing thread.  In particular, it has access to"
user-extensions,thread-local storage of the executing thread.
user-extensions,The thread begin extension is invoked in forward order with thread dispatching
user-extensions,enabled.  The thread switch extension may be called multiple times for this
user-extensions,thread before or during the thread begin extension is invoked.
user-extensions,The thread exitted extension is invoked once the thread entry function returns.
user-extensions,The thread exitted extension is defined as follows.
user-extensions,The executing is a pointer to the TCB of the currently executing
user-extensions,thread.
user-extensions,This extension is invoked in forward order with thread dispatching enabled.
user-extensions,The thread termination extension is invoked in case a termination request is
user-extensions,recognized by the currently executing thread.  Termination requests may result
user-extensions,"due to calls of rtems_task_delete(),"
user-extensions,"pthread_exit(), or pthread_cancel().  The thread termination"
user-extensions,extension is defined as follows.
user-extensions,The executing is a pointer to the TCB of the currently executing
user-extensions,thread.
user-extensions,It is invoked in the context of the terminated thread right before the thread
user-extensions,"dispatch to the heir thread.  The POSIX cleanup handlers, POSIX key destructors"
user-extensions,and thread-local object destructors run in this context.  Depending on the
user-extensions,"order, the thread termination extension has access to thread-local storage and"
user-extensions,thread-specific data of POSIX keys.
user-extensions,The thread terminate extension is invoked in reverse order with thread
user-extensions,dispatching enabled.  The thread life is protected.  Thread restart and delete
user-extensions,requests issued by thread terminate extensions lead to recursion.
user-extensions,The thread delete extension is invoked in case a zombie thread is killed.  A
user-extensions,thread becomes a zombie thread after it terminated.  The thread delete
user-extensions,extension is defined as follows.
user-extensions,The executing is a pointer to the TCB of the currently executing
user-extensions,thread.  The deleted is a pointer to the TCB of the deleted thread.
user-extensions,The executing and deleted pointers are never equal.
user-extensions,The executing thread is the owner of the allocator mutex.  Since the allocator
user-extensions,mutex allows nesting the normal memory allocation routines can be used.
user-extensions,The thread delete extension is invoked in reverse order with thread dispatching
user-extensions,enabled.
user-extensions,Please note that a thread delete extension is not immediately invoked with a
user-extensions,call to rtems_task_delete() or similar.  The thread
user-extensions,must first terminate and this may take some time.  The thread delete extension
user-extensions,is invoked by rtems_task_create() or similar as a
user-extensions,result of a lazy garbage collection of zombie threads.
user-extensions,The fatal error extension is invoked during system termination.  The fatal error extension is defined as follows.
user-extensions,The source parameter is the fatal source indicating the subsystem the
user-extensions,fatal condition originated in.  The always_set_to_false parameter is
user-extensions,always set to false and provided only for backward compatibility
user-extensions,reasons.  The code parameter is the fatal error code.  This value
user-extensions,must be interpreted with respect to the source.
user-extensions,The fatal error extension is invoked in forward order.
user-extensions,It is strongly advised to use initial extension sets to install a fatal error
user-extensions,"extension.  Usually, the initial extension set of board support package"
user-extensions,"provides a fatal error extension which resets the board.  In this case, the"
user-extensions,dynamic fatal error extensions are not invoked.
user-extensions,"© Copyright 1988, 2024 RTEMS Project and contributors."
user-extensions,The User Extensions Manager allows the application developer to augment the
user-extensions,executive by allowing them to supply extension routines which are invoked at
user-extensions,critical system events. The directives provided by the User Extensions Manager
user-extensions,are:
user-extensions,rtems_extension_create() - Creates an extension set.
user-extensions,rtems_extension_delete() - Deletes the extension set.
user-extensions,rtems_extension_ident() - Identifies an extension set by the
user-extensions,object name.
user-extensions,rtems_extension_create() - Creates an extension set.
user-extensions,rtems_extension_delete() - Deletes the extension set.
user-extensions,rtems_extension_ident() - Identifies an extension set by the
user-extensions,object name.
user-extensions,"© Copyright 1988, 2024 RTEMS Project and contributors."
