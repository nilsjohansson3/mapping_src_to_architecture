Module,Text
barrier,"A barrier can be viewed as a gate at which tasks wait until the gate is opened. This has many analogies in the real world.  Horses and other farm animals may approach a closed gate and gather in front of it, waiting for someone to open the gate so they may proceed.  Similarly, ticket holders gather at the gates of arenas before concerts or sporting events waiting for the arena personnel to open the gates so they may enter."
barrier,"Barriers are useful during application initialization.  Each application task can perform its local initialization before waiting for the application as a whole to be initialized.  Once all tasks have completed their independent initializations, the “application ready” barrier can be released."
barrier,"Just as with a real-world gate, barriers may be configured to be manually opened or automatically opened.  All tasks calling the rtems_barrier_wait directive will block until a controlling task invokes the rtems_barrier_release directive."
barrier,"Automatic barriers are created with a limit to the number of tasks which may simultaneously block at the barrier.  Once this limit is reached, all of the tasks are released.  For example, if the automatic limit is ten tasks, then the first nine tasks calling the rtems_barrier_wait directive will block.  When the tenth task calls the rtems_barrier_wait directive, the nine blocked tasks will be released and the tenth task returns to the caller without blocking."
barrier,"In general, an attribute set is built by a bitwise OR of the desired attribute components.  The following table lists the set of valid barrier attributes:"
barrier,automatically release the barrier when the configured number of tasks are blocked
barrier,only release the barrier when the application invokes the rtems_barrier_release directive.  (default)
barrier,Note
barrier,Barriers only support FIFO blocking order because all waiting tasks are released as a set.  Thus the released tasks will all become ready to execute at the same time and compete for the processor based upon their priority.
barrier,"Attribute values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each attribute appears exactly once in the component list.  An attribute listed as a default is not required to appear in the attribute list, although it is a good programming practice to specify default attributes.  If all defaults are desired, the attribute RTEMS_DEFAULT_ATTRIBUTES should be specified on this call."
barrier,"This example demonstrates the attribute_set parameter needed to create a barrier with the automatic release policy.  The attribute_set parameter passed to the rtems_barrier_create directive will be RTEMS_BARRIER_AUTOMATIC_RELEASE.  In this case, the user must also specify the maximum_waiters parameter."
barrier,"© Copyright 1988, 2024 RTEMS Project and contributors."
barrier,"This section details the directives of the Barrier Manager. A subsection is dedicated to each of this manager’s directives and lists the calling sequence, parameters, description, return values, and notes of the directive."
barrier,Creates a barrier.
barrier,CALLING SEQUENCE:
barrier,PARAMETERS:
barrier,This parameter is the object name of the barrier.
barrier,This parameter is the attribute set of the barrier.
barrier,This parameter is the maximum count of waiters on an automatic release barrier.
barrier,"This parameter is the pointer to an rtems_id object.  When the directive call is successful, the identifier of the created barrier will be stored in this object."
barrier,DESCRIPTION:
barrier,This directive creates a barrier which resides on the local node.  The barrier has the user-defined object name specified in name and the initial count specified in attribute_set.  The assigned object identifier is returned in id.  This identifier is used to access the barrier with other barrier related directives.
barrier,"The attribute set specified in attribute_set is built through a bitwise or of the attribute constants described below.  Not all combinations of attributes are allowed.  Some attributes are mutually exclusive.  If mutually exclusive attributes are combined, the behaviour is undefined. Attributes not mentioned below are not evaluated by this directive and have no effect.  Default attributes can be selected by using the RTEMS_DEFAULT_ATTRIBUTES constant."
barrier,The barrier class is selected by the mutually exclusive RTEMS_BARRIER_MANUAL_RELEASE and RTEMS_BARRIER_AUTOMATIC_RELEASE attributes.
barrier,"The manual release class is the default and can be emphasized through use of the RTEMS_BARRIER_MANUAL_RELEASE attribute.  For this class, there is no limit on the number of tasks that will block at the barrier. Only when the rtems_barrier_release() directive is invoked, are the tasks waiting at the barrier unblocked. The automatic release class is selected by the RTEMS_BARRIER_AUTOMATIC_RELEASE attribute.  For this class, tasks calling the rtems_barrier_wait() directive will block until there are maximum_waiters minus one tasks waiting at the barrier.  When the maximum_waiters task invokes the rtems_barrier_wait() directive, the previous maximum_waiters - 1 tasks are automatically released and the caller returns."
barrier,"The manual release class is the default and can be emphasized through use of the RTEMS_BARRIER_MANUAL_RELEASE attribute.  For this class, there is no limit on the number of tasks that will block at the barrier. Only when the rtems_barrier_release() directive is invoked, are the tasks waiting at the barrier unblocked."
barrier,"The automatic release class is selected by the RTEMS_BARRIER_AUTOMATIC_RELEASE attribute.  For this class, tasks calling the rtems_barrier_wait() directive will block until there are maximum_waiters minus one tasks waiting at the barrier.  When the maximum_waiters task invokes the rtems_barrier_wait() directive, the previous maximum_waiters - 1 tasks are automatically released and the caller returns."
barrier,RETURN VALUES:
barrier,The requested operation was successful.
barrier,The name parameter was invalid.
barrier,The id parameter was NULL.
barrier,The maximum_waiters parameter was 0 for an automatic release barrier.
barrier,There was no inactive object available to create a barrier.  The number of barriers available to the application is configured through the CONFIGURE_MAXIMUM_BARRIERS application configuration option.
barrier,NOTES:
barrier,"For control and maintenance of the barrier, RTEMS allocates a BCB from the local BCB free pool and initializes it."
barrier,CONSTRAINTS:
barrier,The following constraints apply to this directive:
barrier,"The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted. The number of barriers available to the application is configured through the CONFIGURE_MAXIMUM_BARRIERS application configuration option. Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace."
barrier,The directive may be called from within device driver initialization context.
barrier,The directive may be called from within task context.
barrier,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
barrier,The number of barriers available to the application is configured through the CONFIGURE_MAXIMUM_BARRIERS application configuration option.
barrier,"Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace."
barrier,Identifies a barrier by the object name.
barrier,CALLING SEQUENCE:
barrier,PARAMETERS:
barrier,This parameter is the object name to look up.
barrier,"This parameter is the pointer to an rtems_id object.  When the directive call is successful, the object identifier of an object with the specified name will be stored in this object."
barrier,DESCRIPTION:
barrier,This directive obtains a barrier identifier associated with the barrier name specified in name.
barrier,RETURN VALUES:
barrier,The requested operation was successful.
barrier,The id parameter was NULL.
barrier,The name parameter was 0.
barrier,There was no object with the specified name on the local node.
barrier,NOTES:
barrier,"If the barrier name is not unique, then the barrier identifier will match the first barrier with that name in the search order.  However, this barrier identifier is not guaranteed to correspond to the desired barrier."
barrier,The objects are searched from lowest to the highest index.  Only the local node is searched.
barrier,The barrier identifier is used with other barrier related directives to access the barrier.
barrier,CONSTRAINTS:
barrier,The following constraints apply to this directive:
barrier,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
barrier,The directive may be called from within any runtime context.
barrier,The directive will not cause the calling task to be preempted.
barrier,Deletes the barrier.
barrier,CALLING SEQUENCE:
barrier,PARAMETERS:
barrier,This parameter is the barrier identifier.
barrier,DESCRIPTION:
barrier,This directive deletes the barrier specified by id.  All tasks blocked waiting for the barrier to be released will be readied and returned a status code which indicates that the barrier was deleted.
barrier,RETURN VALUES:
barrier,The requested operation was successful.
barrier,There was no barrier associated with the identifier specified by id.
barrier,NOTES:
barrier,The BCB for the deleted barrier is reclaimed by RTEMS.
barrier,CONSTRAINTS:
barrier,The following constraints apply to this directive:
barrier,"The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted. The calling task does not have to be the task that created the object.  Any local task that knows the object identifier can delete the object. Where the object class corresponding to the directive is configured to use unlimited objects, the directive may free memory to the RTEMS Workspace."
barrier,The directive may be called from within device driver initialization context.
barrier,The directive may be called from within task context.
barrier,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
barrier,The calling task does not have to be the task that created the object.  Any local task that knows the object identifier can delete the object.
barrier,"Where the object class corresponding to the directive is configured to use unlimited objects, the directive may free memory to the RTEMS Workspace."
barrier,Waits at the barrier.
barrier,CALLING SEQUENCE:
barrier,PARAMETERS:
barrier,This parameter is the barrier identifier.
barrier,This parameter is the timeout in clock ticks.  Use RTEMS_NO_TIMEOUT to wait potentially forever.
barrier,DESCRIPTION:
barrier,"This directive waits at the barrier specified by id.  The timeout parameter defines how long the calling task is willing to wait.  Use RTEMS_NO_TIMEOUT to wait potentially forever, otherwise set a timeout interval in clock ticks."
barrier,"Conceptually, the calling task should always be thought of as blocking when it makes this call and being unblocked when the barrier is released.  If the barrier is configured for manual release, this rule of thumb will always be valid.  If the barrier is configured for automatic release, all callers will block except for the one which trips the automatic release condition."
barrier,RETURN VALUES:
barrier,The requested operation was successful.
barrier,There was no barrier associated with the identifier specified by id.
barrier,The timeout happened while the calling task was waiting at the barrier.
barrier,The barrier was deleted while the calling task was waiting at the barrier.
barrier,NOTES:
barrier,"For automatic release barriers, the maximum count of waiting tasks is defined during barrier creation, see rtems_barrier_create()."
barrier,CONSTRAINTS:
barrier,The following constraints apply to this directive:
barrier,The directive may be called from within task context. The timeout functionality of the directive requires a clock tick.
barrier,The directive may be called from within task context.
barrier,The timeout functionality of the directive requires a clock tick.
barrier,Releases the barrier.
barrier,CALLING SEQUENCE:
barrier,PARAMETERS:
barrier,This parameter is the barrier identifier.
barrier,"This parameter is the pointer to an uint32_t object.  When the directive call is successful, the number of released tasks will be stored in this object."
barrier,DESCRIPTION:
barrier,This directive releases the barrier specified by id.  All tasks waiting at the barrier will be unblocked.  The number of released tasks will be returned in released.
barrier,RETURN VALUES:
barrier,The requested operation was successful.
barrier,The released parameter was NULL.
barrier,There was no barrier associated with the identifier specified by id.
barrier,CONSTRAINTS:
barrier,The following constraints apply to this directive:
barrier,The directive may be called from within interrupt context. The directive may be called from within task context. The directive may unblock a task.  This may cause the calling task to be preempted.
barrier,The directive may be called from within interrupt context.
barrier,The directive may be called from within task context.
barrier,The directive may unblock a task.  This may cause the calling task to be preempted.
barrier,"© Copyright 1988, 2024 RTEMS Project and contributors."
barrier,The Barrier Manager provides a unique synchronization capability which can be used to have a set of tasks block and be unblocked as a set. The directives provided by the Barrier Manager are:
barrier,rtems_barrier_create() - Creates a barrier. rtems_barrier_ident() - Identifies a barrier by the object name. rtems_barrier_delete() - Deletes the barrier. rtems_barrier_wait() - Waits at the barrier. rtems_barrier_release() - Releases the barrier.
barrier,rtems_barrier_create() - Creates a barrier.
barrier,rtems_barrier_ident() - Identifies a barrier by the object name.
barrier,rtems_barrier_delete() - Deletes the barrier.
barrier,rtems_barrier_wait() - Waits at the barrier.
barrier,rtems_barrier_release() - Releases the barrier.
barrier,"© Copyright 1988, 2024 RTEMS Project and contributors."
cache,"This section details the directives of the Cache Manager. A subsection is dedicated to each of this manager’s directives and lists the calling sequence, parameters, description, return values, and notes of the directive."
cache,Flushes the data cache lines covering the memory area.
cache,CALLING SEQUENCE:
cache,PARAMETERS:
cache,This parameter is the begin address of the memory area to flush.
cache,This parameter is the size in bytes of the memory area to flush.
cache,DESCRIPTION:
cache,Dirty data cache lines covering the area are transfered to memory.  Depending on the cache implementation this may mark the lines as invalid.
cache,CONSTRAINTS:
cache,The following constraints apply to this directive:
cache,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
cache,The directive may be called from within any runtime context.
cache,The directive will not cause the calling task to be preempted.
cache,Invalidates the data cache lines covering the memory area.
cache,CALLING SEQUENCE:
cache,PARAMETERS:
cache,This parameter is the begin address of the memory area to invalidate.
cache,This parameter is the size in bytes of the memory area to invalidate.
cache,DESCRIPTION:
cache,The cache lines covering the area are marked as invalid.  A later read access in the area will load the data from memory.
cache,NOTES:
cache,"In case the area is not aligned on cache line boundaries, then this operation may destroy unrelated data."
cache,"On some systems, the cache lines may be flushed before they are invalidated."
cache,CONSTRAINTS:
cache,The following constraints apply to this directive:
cache,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
cache,The directive may be called from within any runtime context.
cache,The directive will not cause the calling task to be preempted.
cache,Invalidates the instruction cache lines covering the memory area.
cache,CALLING SEQUENCE:
cache,PARAMETERS:
cache,This parameter is the begin address of the memory area to invalidate.
cache,This parameter is the size in bytes of the memory area to invalidate.
cache,DESCRIPTION:
cache,The cache lines covering the area are marked as invalid.  A later instruction fetch from the area will result in a load from memory.
cache,NOTES:
cache,"In SMP configurations, on processors without instruction cache snooping, this operation will invalidate the instruction cache lines on all processors."
cache,CONSTRAINTS:
cache,The following constraints apply to this directive:
cache,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
cache,The directive may be called from within any runtime context.
cache,The directive will not cause the calling task to be preempted.
cache,Ensures necessary synchronization required after code changes.
cache,CALLING SEQUENCE:
cache,PARAMETERS:
cache,This parameter is the begin address of the code area to synchronize.
cache,This parameter is the size in bytes of the code area to synchronize.
cache,NOTES:
cache,"When code is loaded or modified, then most systems require synchronization instructions to update the instruction caches so that the loaded or modified code is fetched.  For example, systems with separate data and instruction caches or systems without instruction cache snooping.  The directives should be used by run time loader for example."
cache,CONSTRAINTS:
cache,The following constraints apply to this directive:
cache,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
cache,The directive may be called from within any runtime context.
cache,The directive will not cause the calling task to be preempted.
cache,"Gets the maximal cache line size in bytes of all caches (data, instruction, or unified)."
cache,CALLING SEQUENCE:
cache,RETURN VALUES:
cache,There is no cache present.
cache,"Returns the maximal cache line size in bytes of all caches (data, instruction, or unified)."
cache,CONSTRAINTS:
cache,The following constraints apply to this directive:
cache,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
cache,The directive may be called from within any runtime context.
cache,The directive will not cause the calling task to be preempted.
cache,Gets the data cache line size in bytes.
cache,CALLING SEQUENCE:
cache,RETURN VALUES:
cache,There is no data cache present.
cache,Returns the data cache line size in bytes.  For multi-level caches this is the maximum of the cache line sizes of all levels.
cache,CONSTRAINTS:
cache,The following constraints apply to this directive:
cache,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
cache,The directive may be called from within any runtime context.
cache,The directive will not cause the calling task to be preempted.
cache,Gets the instruction cache line size in bytes.
cache,CALLING SEQUENCE:
cache,RETURN VALUES:
cache,There is no instruction cache present.
cache,Returns the instruction cache line size in bytes.  For multi-level caches this is the maximum of the cache line sizes of all levels.
cache,CONSTRAINTS:
cache,The following constraints apply to this directive:
cache,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
cache,The directive may be called from within any runtime context.
cache,The directive will not cause the calling task to be preempted.
cache,Gets the data cache size in bytes for the cache level.
cache,CALLING SEQUENCE:
cache,PARAMETERS:
cache,This parameter is the requested data cache level.  The cache level zero specifies the entire data cache.
cache,RETURN VALUES:
cache,There is no data cache present at the requested cache level.
cache,Returns the data cache size in bytes of the requested cache level.
cache,CONSTRAINTS:
cache,The following constraints apply to this directive:
cache,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
cache,The directive may be called from within any runtime context.
cache,The directive will not cause the calling task to be preempted.
cache,Gets the instruction cache size in bytes for the cache level.
cache,CALLING SEQUENCE:
cache,PARAMETERS:
cache,This parameter is the requested instruction cache level.  The cache level zero specifies the entire instruction cache.
cache,RETURN VALUES:
cache,There is no instruction cache present at the requested cache level.
cache,Returns the instruction cache size in bytes of the requested cache level.
cache,CONSTRAINTS:
cache,The following constraints apply to this directive:
cache,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
cache,The directive may be called from within any runtime context.
cache,The directive will not cause the calling task to be preempted.
cache,Flushes the entire data cache.
cache,CALLING SEQUENCE:
cache,CONSTRAINTS:
cache,The following constraints apply to this directive:
cache,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
cache,The directive may be called from within any runtime context.
cache,The directive will not cause the calling task to be preempted.
cache,Invalidates the entire data cache.
cache,CALLING SEQUENCE:
cache,CONSTRAINTS:
cache,The following constraints apply to this directive:
cache,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
cache,The directive may be called from within any runtime context.
cache,The directive will not cause the calling task to be preempted.
cache,Invalidates the entire instruction cache.
cache,CALLING SEQUENCE:
cache,CONSTRAINTS:
cache,The following constraints apply to this directive:
cache,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
cache,The directive may be called from within any runtime context.
cache,The directive will not cause the calling task to be preempted.
cache,Enables the data cache.
cache,CALLING SEQUENCE:
cache,CONSTRAINTS:
cache,The following constraints apply to this directive:
cache,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
cache,The directive may be called from within any runtime context.
cache,The directive will not cause the calling task to be preempted.
cache,Disables the data cache.
cache,CALLING SEQUENCE:
cache,NOTES:
cache,"On some targets or configurations, calling this directive may cause a fatal error with a fatal source of INTERNAL_ERROR_CORE and fatal code of INTERNAL_ERROR_CANNOT_DISABLE_DATA_CACHE.   The data cache may be necessary to provide atomic operations. In SMP configurations, the data cache may be required to ensure data coherency.  See the BSP documentation in the RTEMS User Manual for more information."
cache,CONSTRAINTS:
cache,The following constraints apply to this directive:
cache,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
cache,The directive may be called from within any runtime context.
cache,The directive will not cause the calling task to be preempted.
cache,Enables the instruction cache.
cache,CALLING SEQUENCE:
cache,CONSTRAINTS:
cache,The following constraints apply to this directive:
cache,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
cache,The directive may be called from within any runtime context.
cache,The directive will not cause the calling task to be preempted.
cache,Disables the instruction cache.
cache,CALLING SEQUENCE:
cache,CONSTRAINTS:
cache,The following constraints apply to this directive:
cache,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
cache,The directive may be called from within any runtime context.
cache,The directive will not cause the calling task to be preempted.
cache,Allocates memory from the C Program Heap which begins at a cache line boundary.
cache,CALLING SEQUENCE:
cache,PARAMETERS:
cache,This parameter is the size in bytes of the memory area to allocate.
cache,RETURN VALUES:
cache,There is not enough memory available to satisfy the allocation request.
cache,Returns the begin address of the allocated memory.  The begin address is on a cache line boundary.
cache,CONSTRAINTS:
cache,The following constraints apply to this directive:
cache,The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
cache,The directive may be called from within device driver initialization context.
cache,The directive may be called from within task context.
cache,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
cache,"© Copyright 1988, 2024 RTEMS Project and contributors."
cache,The Cache Manager provides functions to perform maintenance operations for data and instruction caches.
cache,The actual actions of the Cache Manager operations depend on the hardware and the implementation provided by the CPU architecture port or a board support package.  Cache implementations tend to be highly hardware dependent. The directives provided by the Cache Manager are:
cache,"rtems_cache_flush_multiple_data_lines() - Flushes the data cache lines covering the memory area. rtems_cache_invalidate_multiple_data_lines() - Invalidates the data cache lines covering the memory area. rtems_cache_invalidate_multiple_instruction_lines() - Invalidates the instruction cache lines covering the memory area. rtems_cache_instruction_sync_after_code_change() - Ensures necessary synchronization required after code changes. rtems_cache_get_maximal_line_size() - Gets the maximal cache line size in bytes of all caches (data, instruction, or unified). rtems_cache_get_data_line_size() - Gets the data cache line size in bytes. rtems_cache_get_instruction_line_size() - Gets the instruction cache line size in bytes. rtems_cache_get_data_cache_size() - Gets the data cache size in bytes for the cache level. rtems_cache_get_instruction_cache_size() - Gets the instruction cache size in bytes for the cache level. rtems_cache_flush_entire_data() - Flushes the entire data cache. rtems_cache_invalidate_entire_data() - Invalidates the entire data cache. rtems_cache_invalidate_entire_instruction() - Invalidates the entire instruction cache. rtems_cache_enable_data() - Enables the data cache. rtems_cache_disable_data() - Disables the data cache. rtems_cache_enable_instruction() - Enables the instruction cache. rtems_cache_disable_instruction() - Disables the instruction cache. rtems_cache_aligned_malloc() - Allocates memory from the C Program Heap which begins at a cache line boundary."
cache,rtems_cache_flush_multiple_data_lines() - Flushes the data cache lines covering the memory area.
cache,rtems_cache_invalidate_multiple_data_lines() - Invalidates the data cache lines covering the memory area.
cache,rtems_cache_invalidate_multiple_instruction_lines() - Invalidates the instruction cache lines covering the memory area.
cache,rtems_cache_instruction_sync_after_code_change() - Ensures necessary synchronization required after code changes.
cache,"rtems_cache_get_maximal_line_size() - Gets the maximal cache line size in bytes of all caches (data, instruction, or unified)."
cache,rtems_cache_get_data_line_size() - Gets the data cache line size in bytes.
cache,rtems_cache_get_instruction_line_size() - Gets the instruction cache line size in bytes.
cache,rtems_cache_get_data_cache_size() - Gets the data cache size in bytes for the cache level.
cache,rtems_cache_get_instruction_cache_size() - Gets the instruction cache size in bytes for the cache level.
cache,rtems_cache_flush_entire_data() - Flushes the entire data cache.
cache,rtems_cache_invalidate_entire_data() - Invalidates the entire data cache.
cache,rtems_cache_invalidate_entire_instruction() - Invalidates the entire instruction cache.
cache,rtems_cache_enable_data() - Enables the data cache.
cache,rtems_cache_disable_data() - Disables the data cache.
cache,rtems_cache_enable_instruction() - Enables the instruction cache.
cache,rtems_cache_disable_instruction() - Disables the instruction cache.
cache,rtems_cache_aligned_malloc() - Allocates memory from the C Program Heap which begins at a cache line boundary.
cache,"© Copyright 1988, 2024 RTEMS Project and contributors."
clock,"For the features provided by the Clock Manager to be utilized, a Clock Driver is required.  The Clock Driver usually provides a clock interrupt which is serviced on each configured processor at each clock tick.  In addition, the Clock Driver provides three clock sources:"
clock,clock tick CLOCK_REALTIME CLOCK_MONOTONIC
clock,clock tick
clock,CLOCK_REALTIME
clock,CLOCK_MONOTONIC
clock,"The time of these clock sources advances at each clock tick.  This yields the time of the clock sources in a coarse resolution.  To get the time of the CLOCK_REALTIME or CLOCK_MONOTONIC clock sources in a higher resolution, the Clock Driver may use a clock device to get the time between clock ticks."
clock,The clock facilities of the Clock Manager operate upon calendar time.  These directives utilize the following date and time structure for the native time and date format:
clock,"The native date and time format is the only format supported when setting the system date and time using the rtems_clock_set() directive.  Some applications expect to operate on a UNIX-style date and time data structure. For example, the rtems_clock_get_tod_timeval() returns the date and time in struct timeval format."
clock,"Some directives use data structures defined by POSIX.  The struct timeval data structure has two members: tv_sec and tv_usec which are seconds and microseconds, respectively.  The struct timespec data structure has two members: tv_sec and tv_nsec which are seconds and nanoseconds, respectively.  For CLOCK_REALTIME time points, the tv_sec member in these data structures is the number of seconds since the Unix epoch but will never be prior to the RTEMS epoch."
clock,"The struct bintime and sbintime_t time formats used by some directives originate in FreeBSD.  The struct bintime data structure which represents time in a binary time format has two members: sec and frac which are seconds and fractions of a second in units of \(1 / 2^{64}\) seconds, respectively.  The sbintime_t type is a signed 64-bit integer type used to represent time in units of \(1 / 2^{32}\) seconds."
clock,Timeslicing is a task scheduling discipline in which tasks of equal priority are executed for a specific period of time before control of the CPU is passed to another task.  It is also sometimes referred to as the automatic round-robin scheduling algorithm.  The length of time allocated to each task is known as the quantum or timeslice.
clock,"The system’s timeslice is defined as an integral number of ticks, and is specified by the CONFIGURE_TICKS_PER_TIMESLICE application configuration option.  The timeslice is defined for the entire system of tasks, but timeslicing is enabled and disabled on a per task basis."
clock,"The clock tick directives implement timeslicing by decrementing the running task’s time-remaining counter when both timeslicing and preemption are enabled.  If the task’s timeslice has expired, then that task will be preempted if there exists a ready task of equal priority."
clock,"A sleep timer allows a task to delay for a given interval or up until a given time, and then wake and continue execution.  This type of timer is created automatically by the rtems_task_wake_after() and rtems_task_wake_when() directives and, as a result, does not have an object identifier.  Once activated, a sleep timer cannot be explicitly deleted. Each task may activate one and only one sleep timer at a time."
clock,"Timeouts are a special type of timer automatically created when the timeout option is used on the rtems_barrier_wait(), rtems_event_receive(), rtems_message_queue_receive(), rtems_region_get_segment(), and rtems_semaphore_obtain() directives.  Each task may have one and only one timeout active at a time. When a timeout expires, it unblocks the task with a timeout status code."
clock,"© Copyright 1988, 2024 RTEMS Project and contributors."
clock,"This section details the directives of the Clock Manager. A subsection is dedicated to each of this manager’s directives and lists the calling sequence, parameters, description, return values, and notes of the directive."
clock,Sets the CLOCK_REALTIME to the time of day.
clock,CALLING SEQUENCE:
clock,PARAMETERS:
clock,This parameter is the time of day to set the clock.
clock,RETURN VALUES:
clock,The requested operation was successful.
clock,The time_of_day parameter was NULL.
clock,The time of day specified by time_of_day was invalid.
clock,NOTES:
clock,"The date, time, and ticks specified by time_of_day are all range-checked, and an error is returned if any one is out of its valid range."
clock,"RTEMS can represent time points of the CLOCK_REALTIME clock in nanoseconds ranging from 1988-01-01T00:00:00.000000000Z to 2514-05-31T01:53:03.999999999Z.  The future uptime of the system shall be in this range, otherwise the system behaviour is undefined.  Due to implementation constraints, the time of day set by the directive shall be before 2100-01-01:00:00.000000000Z.  The latest valid time of day accepted by the POSIX clock_settime() is 2400-01-01T00:00:00.999999999Z."
clock,"The specified time is based on the configured clock tick rate, see the CONFIGURE_MICROSECONDS_PER_TICK application configuration option."
clock,"Setting the time forward will fire all CLOCK_REALTIME timers which are scheduled at a time point before or at the time set by the directive.  This may unblock tasks, which may preempt the calling task. User-provided timer routines will execute in the context of the caller."
clock,"It is allowed to call this directive from within interrupt context, however, this is not recommended since an arbitrary number of timers may fire."
clock,"The directive shall be called at least once to enable the service of CLOCK_REALTIME related directives.  If the clock is not set at least once, they may return an error status."
clock,CONSTRAINTS:
clock,The following constraints apply to this directive:
clock,The directive may be called from within any runtime context. The directive may change the priority of a task.  This may cause the calling task to be preempted. The directive may unblock a task.  This may cause the calling task to be preempted. The time of day set by the directive shall be 1988-01-01T00:00:00.000000000Z or later. The time of day set by the directive shall be before 2100-01-01T00:00:00.000000000Z.
clock,The directive may be called from within any runtime context.
clock,The directive may change the priority of a task.  This may cause the calling task to be preempted.
clock,The directive may unblock a task.  This may cause the calling task to be preempted.
clock,The time of day set by the directive shall be 1988-01-01T00:00:00.000000000Z or later.
clock,The time of day set by the directive shall be before 2100-01-01T00:00:00.000000000Z.
clock,Gets the time of day associated with the current CLOCK_REALTIME.
clock,CALLING SEQUENCE:
clock,PARAMETERS:
clock,"This parameter is the pointer to an rtems_time_of_day object. When the directive call is successful, the time of day associated with the CLOCK_REALTIME at some point during the directive call will be stored in this object."
clock,RETURN VALUES:
clock,The requested operation was successful.
clock,The time_of_day parameter was NULL.
clock,The CLOCK_REALTIME was not set.  It can be set with rtems_clock_set().
clock,CONSTRAINTS:
clock,The following constraints apply to this directive:
clock,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. The directive requires a Clock Driver.
clock,The directive may be called from within any runtime context.
clock,The directive will not cause the calling task to be preempted.
clock,The directive requires a Clock Driver.
clock,Gets the seconds and microseconds elapsed since the Unix epoch and the current CLOCK_REALTIME.
clock,CALLING SEQUENCE:
clock,PARAMETERS:
clock,"This parameter is the pointer to a struct timeval object.  When the directive call is successful, the seconds and microseconds elapsed since the Unix epoch and the CLOCK_REALTIME at some point during the directive call will be stored in this object."
clock,RETURN VALUES:
clock,The requested operation was successful.
clock,The time_of_day parameter was NULL.
clock,The CLOCK_REALTIME was not set.  It can be set with rtems_clock_set().
clock,CONSTRAINTS:
clock,The following constraints apply to this directive:
clock,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. The directive requires a Clock Driver.
clock,The directive may be called from within any runtime context.
clock,The directive will not cause the calling task to be preempted.
clock,The directive requires a Clock Driver.
clock,Gets the time elapsed since the Unix epoch measured using CLOCK_REALTIME in seconds and nanoseconds format.
clock,CALLING SEQUENCE:
clock,PARAMETERS:
clock,This parameter is the pointer to a struct timespec object.  The time elapsed since the Unix epoch measured using the CLOCK_REALTIME at some time point during the directive call will be stored in this object.  Calling the directive with a pointer equal to NULL is undefined behaviour.
clock,NOTES:
clock,"The directive accesses a device provided by the Clock Driver to get the time in the highest resolution available to the system.  Alternatively, the rtems_clock_get_realtime_coarse() directive may be used to get the time in a lower resolution and with less runtime overhead."
clock,See rtems_clock_get_realtime_bintime() and rtems_clock_get_realtime_timeval() to get the time in alternative formats.
clock,CONSTRAINTS:
clock,The following constraints apply to this directive:
clock,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. The directive requires a Clock Driver.
clock,The directive may be called from within any runtime context.
clock,The directive will not cause the calling task to be preempted.
clock,The directive requires a Clock Driver.
clock,Gets the time elapsed since the Unix epoch measured using CLOCK_REALTIME in binary time format.
clock,CALLING SEQUENCE:
clock,PARAMETERS:
clock,This parameter is the pointer to a struct bintime object.  The time elapsed since the Unix epoch measured using the CLOCK_REALTIME at some time point during the directive call will be stored in this object.  Calling the directive with a pointer equal to NULL is undefined behaviour.
clock,NOTES:
clock,"The directive accesses a device provided by the Clock Driver to get the time in the highest resolution available to the system.  Alternatively, the rtems_clock_get_realtime_coarse_bintime() directive may be used to get the time in a lower resolution and with less runtime overhead."
clock,See rtems_clock_get_realtime() and rtems_clock_get_realtime_timeval() to get the time in alternative formats.
clock,CONSTRAINTS:
clock,The following constraints apply to this directive:
clock,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. The directive requires a Clock Driver.
clock,The directive may be called from within any runtime context.
clock,The directive will not cause the calling task to be preempted.
clock,The directive requires a Clock Driver.
clock,Gets the time elapsed since the Unix epoch measured using CLOCK_REALTIME in seconds and microseconds format.
clock,CALLING SEQUENCE:
clock,PARAMETERS:
clock,This parameter is the pointer to a struct timeval object.  The time elapsed since the Unix epoch measured using the CLOCK_REALTIME at some time point during the directive call will be stored in this object.  Calling the directive with a pointer equal to NULL is undefined behaviour.
clock,NOTES:
clock,"The directive accesses a device provided by the Clock Driver to get the time in the highest resolution available to the system.  Alternatively, the rtems_clock_get_realtime_coarse_timeval() directive may be used to get the time in a lower resolution and with less runtime overhead."
clock,See rtems_clock_get_realtime() and rtems_clock_get_realtime_bintime() to get the time in alternative formats.
clock,CONSTRAINTS:
clock,The following constraints apply to this directive:
clock,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. The directive requires a Clock Driver.
clock,The directive may be called from within any runtime context.
clock,The directive will not cause the calling task to be preempted.
clock,The directive requires a Clock Driver.
clock,Gets the time elapsed since the Unix epoch measured using CLOCK_REALTIME in coarse resolution in seconds and nanoseconds format.
clock,CALLING SEQUENCE:
clock,PARAMETERS:
clock,This parameter is the pointer to a struct timespec object.  The time elapsed since the Unix epoch measured using the CLOCK_REALTIME at some time point close to the directive call will be stored in this object.  Calling the directive with a pointer equal to NULL is undefined behaviour.
clock,NOTES:
clock,"The directive does not access a device to get the time.  It uses a recent snapshot provided by the Clock Driver.  Alternatively, the rtems_clock_get_realtime() directive may be used to get the time in a higher resolution and with a higher runtime overhead."
clock,See rtems_clock_get_realtime_coarse_bintime() and rtems_clock_get_realtime_coarse_timeval() to get the time in alternative formats.
clock,CONSTRAINTS:
clock,The following constraints apply to this directive:
clock,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. The directive requires a Clock Driver.
clock,The directive may be called from within any runtime context.
clock,The directive will not cause the calling task to be preempted.
clock,The directive requires a Clock Driver.
clock,Gets the time elapsed since the Unix epoch measured using CLOCK_REALTIME in coarse resolution in binary time format.
clock,CALLING SEQUENCE:
clock,PARAMETERS:
clock,This parameter is the pointer to a struct bintime object.  The time elapsed since the Unix epoch measured using the CLOCK_REALTIME at some time point close to the directive call will be stored in this object.  Calling the directive with a pointer equal to NULL is undefined behaviour.
clock,NOTES:
clock,"The directive does not access a device to get the time.  It uses a recent snapshot provided by the Clock Driver.  Alternatively, the rtems_clock_get_realtime_bintime() directive may be used to get the time in a higher resolution and with a higher runtime overhead."
clock,See rtems_clock_get_realtime_coarse() and rtems_clock_get_realtime_coarse_timeval() to get the time in alternative formats.
clock,CONSTRAINTS:
clock,The following constraints apply to this directive:
clock,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. The directive requires a Clock Driver.
clock,The directive may be called from within any runtime context.
clock,The directive will not cause the calling task to be preempted.
clock,The directive requires a Clock Driver.
clock,Gets the time elapsed since the Unix epoch measured using CLOCK_REALTIME in coarse resolution in seconds and microseconds format.
clock,CALLING SEQUENCE:
clock,PARAMETERS:
clock,This parameter is the pointer to a struct timeval object.  The time elapsed since the Unix epoch measured using the CLOCK_REALTIME at some time point close to the directive call will be stored in this object.  Calling the directive with a pointer equal to NULL is undefined behaviour.
clock,NOTES:
clock,"The directive does not access a device to get the time.  It uses a recent snapshot provided by the Clock Driver.  Alternatively, the rtems_clock_get_realtime_timeval() directive may be used to get the time in a higher resolution and with a higher runtime overhead."
clock,See rtems_clock_get_realtime_coarse() and rtems_clock_get_realtime_coarse_timeval() to get the time in alternative formats.
clock,CONSTRAINTS:
clock,The following constraints apply to this directive:
clock,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. The directive requires a Clock Driver.
clock,The directive may be called from within any runtime context.
clock,The directive will not cause the calling task to be preempted.
clock,The directive requires a Clock Driver.
clock,Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in seconds and nanoseconds format.
clock,CALLING SEQUENCE:
clock,PARAMETERS:
clock,This parameter is the pointer to a struct timespec object.  The time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC at some time point during the directive call will be stored in this object.  Calling the directive with a pointer equal to NULL is undefined behaviour.
clock,NOTES:
clock,"The directive accesses a device provided by the Clock Driver to get the time in the highest resolution available to the system.  Alternatively, the rtems_clock_get_monotonic_coarse() directive may be used to get the time with in a lower resolution and with less runtime overhead."
clock,"See rtems_clock_get_monotonic_bintime(), rtems_clock_get_monotonic_sbintime(), and rtems_clock_get_monotonic_timeval() to get the time in alternative formats."
clock,CONSTRAINTS:
clock,The following constraints apply to this directive:
clock,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. The directive requires a Clock Driver.
clock,The directive may be called from within any runtime context.
clock,The directive will not cause the calling task to be preempted.
clock,The directive requires a Clock Driver.
clock,Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in binary time format.
clock,CALLING SEQUENCE:
clock,PARAMETERS:
clock,This parameter is the pointer to a struct bintime object.  The time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC at some time point during the directive call will be stored in this object.  Calling the directive with a pointer equal to NULL is undefined behaviour.
clock,NOTES:
clock,"The directive accesses a device provided by the Clock Driver to get the time in the highest resolution available to the system.  Alternatively, the rtems_clock_get_monotonic_coarse_bintime() directive may be used to get the time in a lower resolution and with less runtime overhead."
clock,"See rtems_clock_get_monotonic(), rtems_clock_get_monotonic_sbintime(), and rtems_clock_get_monotonic_timeval() to get the time in alternative formats."
clock,CONSTRAINTS:
clock,The following constraints apply to this directive:
clock,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. The directive requires a Clock Driver.
clock,The directive may be called from within any runtime context.
clock,The directive will not cause the calling task to be preempted.
clock,The directive requires a Clock Driver.
clock,Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in signed binary time format.
clock,CALLING SEQUENCE:
clock,RETURN VALUES:
clock,Returns the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC at some time point during the directive call.
clock,NOTES:
clock,The directive accesses a device provided by the Clock Driver to get the time in the highest resolution available to the system.
clock,"See rtems_clock_get_monotonic(), rtems_clock_get_monotonic_bintime(), and rtems_clock_get_monotonic_timeval() to get the time in alternative formats."
clock,CONSTRAINTS:
clock,The following constraints apply to this directive:
clock,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. The directive requires a Clock Driver.
clock,The directive may be called from within any runtime context.
clock,The directive will not cause the calling task to be preempted.
clock,The directive requires a Clock Driver.
clock,Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in seconds and microseconds format.
clock,CALLING SEQUENCE:
clock,PARAMETERS:
clock,This parameter is the pointer to a struct timeval object.  The time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC at some time point during the directive call will be stored in this object.  Calling the directive with a pointer equal to NULL is undefined behaviour.
clock,NOTES:
clock,"The directive accesses a device provided by the Clock Driver to get the time in the highest resolution available to the system.  Alternatively, the rtems_clock_get_monotonic_coarse_timeval() directive may be used to get the time in a lower resolution and with less runtime overhead."
clock,"See rtems_clock_get_monotonic(), rtems_clock_get_monotonic_bintime(), and rtems_clock_get_monotonic_sbintime() to get the time in alternative formats."
clock,CONSTRAINTS:
clock,The following constraints apply to this directive:
clock,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. The directive requires a Clock Driver.
clock,The directive may be called from within any runtime context.
clock,The directive will not cause the calling task to be preempted.
clock,The directive requires a Clock Driver.
clock,Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in coarse resolution in seconds and nanoseconds format.
clock,CALLING SEQUENCE:
clock,PARAMETERS:
clock,This parameter is the pointer to a struct timespec object.  The time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC at some time point close to the directive call will be stored in this object.  Calling the directive with a pointer equal to NULL is undefined behaviour.
clock,NOTES:
clock,"The directive does not access a device to get the time.  It uses a recent snapshot provided by the Clock Driver.  Alternatively, the rtems_clock_get_monotonic() directive may be used to get the time in a higher resolution and with a higher runtime overhead."
clock,See rtems_clock_get_monotonic_coarse_bintime() and rtems_clock_get_monotonic_coarse_timeval() to get the time in alternative formats.
clock,CONSTRAINTS:
clock,The following constraints apply to this directive:
clock,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. The directive requires a Clock Driver.
clock,The directive may be called from within any runtime context.
clock,The directive will not cause the calling task to be preempted.
clock,The directive requires a Clock Driver.
clock,Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in coarse resolution in binary time format.
clock,CALLING SEQUENCE:
clock,PARAMETERS:
clock,This parameter is the pointer to a struct bintime object.  The time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC at some time point close to the directive call will be stored in this object.  Calling the directive with a pointer equal to NULL is undefined behaviour.
clock,NOTES:
clock,"The directive does not access a device to get the time.  It uses a recent snapshot provided by the Clock Driver.  Alternatively, the rtems_clock_get_monotonic_bintime() directive may be used to get the time in a higher resolution and with a higher runtime overhead."
clock,See rtems_clock_get_monotonic_coarse() and rtems_clock_get_monotonic_coarse_timeval() to get the time in alternative formats.
clock,CONSTRAINTS:
clock,The following constraints apply to this directive:
clock,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. The directive requires a Clock Driver.
clock,The directive may be called from within any runtime context.
clock,The directive will not cause the calling task to be preempted.
clock,The directive requires a Clock Driver.
clock,Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in coarse resolution in seconds and microseconds format.
clock,CALLING SEQUENCE:
clock,PARAMETERS:
clock,This parameter is the pointer to a struct timeval object.  The time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC at some time point close to the directive call will be stored in this object.  Calling the directive with a pointer equal to NULL is undefined behaviour.
clock,NOTES:
clock,"The directive does not access a device to get the time.  It uses a recent snapshot provided by the Clock Driver.  Alternatively, the rtems_clock_get_monotonic_timeval() directive may be used to get the time in a higher resolution and with a higher runtime overhead."
clock,See rtems_clock_get_monotonic_coarse() and rtems_clock_get_monotonic_coarse_bintime() to get the time in alternative formats.
clock,CONSTRAINTS:
clock,The following constraints apply to this directive:
clock,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. The directive requires a Clock Driver.
clock,The directive may be called from within any runtime context.
clock,The directive will not cause the calling task to be preempted.
clock,The directive requires a Clock Driver.
clock,Gets the time elapsed since the Unix epoch at some time point during system initialization in seconds and nanoseconds format.
clock,CALLING SEQUENCE:
clock,PARAMETERS:
clock,This parameter is the pointer to a struct timespec object.  The time elapsed since the Unix epoch at some time point during system initialization call will be stored in this object.  Calling the directive with a pointer equal to NULL is undefined behaviour.
clock,NOTES:
clock,See rtems_clock_get_boot_time_bintime() and rtems_clock_get_boot_time_timeval() to get the boot time in alternative formats.  Setting the CLOCK_REALTIME will also set the boot time.
clock,CONSTRAINTS:
clock,The following constraints apply to this directive:
clock,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. The directive requires a Clock Driver.
clock,The directive may be called from within any runtime context.
clock,The directive will not cause the calling task to be preempted.
clock,The directive requires a Clock Driver.
clock,Gets the time elapsed since the Unix epoch at some time point during system initialization in binary time format.
clock,CALLING SEQUENCE:
clock,PARAMETERS:
clock,This parameter is the pointer to a struct bintime object.  The time elapsed since the Unix epoch at some time point during system initialization call will be stored in this object.  Calling the directive with a pointer equal to NULL is undefined behaviour.
clock,NOTES:
clock,See rtems_clock_get_boot_time() and rtems_clock_get_boot_time_timeval() to get the boot time in alternative formats.  Setting the CLOCK_REALTIME will also set the boot time.
clock,CONSTRAINTS:
clock,The following constraints apply to this directive:
clock,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. The directive requires a Clock Driver.
clock,The directive may be called from within any runtime context.
clock,The directive will not cause the calling task to be preempted.
clock,The directive requires a Clock Driver.
clock,Gets the time elapsed since the Unix epoch at some time point during system initialization in seconds and microseconds format.
clock,CALLING SEQUENCE:
clock,PARAMETERS:
clock,This parameter is the pointer to a struct timeval object.  The time elapsed since the Unix epoch at some time point during system initialization call will be stored in this object.  Calling the directive with a pointer equal to NULL is undefined behaviour.
clock,NOTES:
clock,See rtems_clock_get_boot_time() and rtems_clock_get_boot_time_bintime() to get the boot time in alternative formats.  Setting the CLOCK_REALTIME will also set the boot time.
clock,CONSTRAINTS:
clock,The following constraints apply to this directive:
clock,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. The directive requires a Clock Driver.
clock,The directive may be called from within any runtime context.
clock,The directive will not cause the calling task to be preempted.
clock,The directive requires a Clock Driver.
clock,Gets the seconds elapsed since the RTEMS epoch and the current CLOCK_REALTIME.
clock,CALLING SEQUENCE:
clock,PARAMETERS:
clock,"This parameter is the pointer to an rtems_interval object. When the directive call is successful, the seconds elapsed since the RTEMS epoch and the CLOCK_REALTIME at some point during the directive call will be stored in this object."
clock,RETURN VALUES:
clock,The requested operation was successful.
clock,The seconds_since_rtems_epoch parameter was NULL.
clock,The CLOCK_REALTIME was not set.  It can be set with rtems_clock_set().
clock,CONSTRAINTS:
clock,The following constraints apply to this directive:
clock,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. The directive requires a Clock Driver.
clock,The directive may be called from within any runtime context.
clock,The directive will not cause the calling task to be preempted.
clock,The directive requires a Clock Driver.
clock,Gets the number of clock ticks per second configured for the application.
clock,CALLING SEQUENCE:
clock,RETURN VALUES:
clock,Returns the number of clock ticks per second configured for this application.
clock,NOTES:
clock,The number of clock ticks per second is defined indirectly by the CONFIGURE_MICROSECONDS_PER_TICK configuration option.
clock,CONSTRAINTS:
clock,The following constraints apply to this directive:
clock,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
clock,The directive may be called from within any runtime context.
clock,The directive will not cause the calling task to be preempted.
clock,Gets the number of clock ticks since some time point during the system initialization or the last overflow of the clock tick counter.
clock,CALLING SEQUENCE:
clock,RETURN VALUES:
clock,Returns the number of clock ticks since some time point during the system initialization or the last overflow of the clock tick counter.
clock,NOTES:
clock,"With a 1ms clock tick, this counter overflows after 50 days since boot.  This is the historical measure of uptime in an RTEMS system.  The newer service rtems_clock_get_uptime() is another and potentially more accurate way of obtaining similar information."
clock,CONSTRAINTS:
clock,The following constraints apply to this directive:
clock,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
clock,The directive may be called from within any runtime context.
clock,The directive will not cause the calling task to be preempted.
clock,Gets the seconds and nanoseconds elapsed since some time point during the system initialization using CLOCK_MONOTONIC.
clock,CALLING SEQUENCE:
clock,PARAMETERS:
clock,"This parameter is the pointer to a struct timespec object.  When the directive call is successful, the seconds and nanoseconds elapsed since some time point during the system initialization and some point during the directive call using CLOCK_MONOTONIC will be stored in this object."
clock,RETURN VALUES:
clock,The requested operation was successful.
clock,The uptime parameter was NULL.
clock,CONSTRAINTS:
clock,The following constraints apply to this directive:
clock,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. The directive requires a Clock Driver.
clock,The directive may be called from within any runtime context.
clock,The directive will not cause the calling task to be preempted.
clock,The directive requires a Clock Driver.
clock,Gets the seconds and microseconds elapsed since some time point during the system initialization using CLOCK_MONOTONIC.
clock,CALLING SEQUENCE:
clock,PARAMETERS:
clock,"This parameter is the pointer to a struct timeval object.  The seconds and microseconds elapsed since some time point during the system initialization and some point during the directive call using CLOCK_MONOTONIC will be stored in this object.  The pointer shall be valid, otherwise the behaviour is undefined."
clock,CONSTRAINTS:
clock,The following constraints apply to this directive:
clock,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. The directive requires a Clock Driver.
clock,The directive may be called from within any runtime context.
clock,The directive will not cause the calling task to be preempted.
clock,The directive requires a Clock Driver.
clock,Gets the seconds elapsed since some time point during the system initialization using CLOCK_MONOTONIC.
clock,CALLING SEQUENCE:
clock,RETURN VALUES:
clock,Returns the seconds elapsed since some time point during the system initialization and some point during the directive call using CLOCK_MONOTONIC.
clock,CONSTRAINTS:
clock,The following constraints apply to this directive:
clock,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. The directive requires a Clock Driver.
clock,The directive may be called from within any runtime context.
clock,The directive will not cause the calling task to be preempted.
clock,The directive requires a Clock Driver.
clock,Gets the nanoseconds elapsed since some time point during the system initialization using CLOCK_MONOTONIC.
clock,CALLING SEQUENCE:
clock,RETURN VALUES:
clock,Returns the nanoseconds elapsed since some time point during the system initialization and some point during the directive call using CLOCK_MONOTONIC.
clock,CONSTRAINTS:
clock,The following constraints apply to this directive:
clock,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. The directive requires a Clock Driver.
clock,The directive may be called from within any runtime context.
clock,The directive will not cause the calling task to be preempted.
clock,The directive requires a Clock Driver.
clock,Gets a clock tick value which is at least delta clock ticks in the future.
clock,CALLING SEQUENCE:
clock,PARAMETERS:
clock,This parameter is the delta value in clock ticks.
clock,RETURN VALUES:
clock,Returns a clock tick counter value which is at least delta clock ticks in the future.
clock,CONSTRAINTS:
clock,The following constraints apply to this directive:
clock,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. The directive requires a Clock Driver.
clock,The directive may be called from within any runtime context.
clock,The directive will not cause the calling task to be preempted.
clock,The directive requires a Clock Driver.
clock,Gets a clock tick value which is at least delta microseconds in the future.
clock,CALLING SEQUENCE:
clock,PARAMETERS:
clock,This parameter is the delta value in microseconds.
clock,RETURN VALUES:
clock,Returns a clock tick counter value which is at least delta_in_usec microseconds in the future.
clock,CONSTRAINTS:
clock,The following constraints apply to this directive:
clock,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. The directive requires a Clock Driver.
clock,The directive may be called from within any runtime context.
clock,The directive will not cause the calling task to be preempted.
clock,The directive requires a Clock Driver.
clock,Indicates if the current clock tick counter is before the ticks.
clock,CALLING SEQUENCE:
clock,PARAMETERS:
clock,This parameter is the ticks value to check.
clock,RETURN VALUES:
clock,"Returns true, if current clock tick counter indicates a time before the time in ticks, otherwise returns false."
clock,NOTES:
clock,This directive can be used to write busy loops with a timeout.
clock,CONSTRAINTS:
clock,The following constraints apply to this directive:
clock,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. The directive requires a Clock Driver.
clock,The directive may be called from within any runtime context.
clock,The directive will not cause the calling task to be preempted.
clock,The directive requires a Clock Driver.
clock,"© Copyright 1988, 2024 RTEMS Project and contributors."
clock,The Clock Manager provides support for time of day and other time related capabilities. The directives provided by the Clock Manager are:
clock,rtems_clock_set() - Sets the CLOCK_REALTIME to the time of day. rtems_clock_get_tod() - Gets the time of day associated with the current CLOCK_REALTIME. rtems_clock_get_tod_timeval() - Gets the seconds and microseconds elapsed since the Unix epoch and the current CLOCK_REALTIME. rtems_clock_get_realtime() - Gets the time elapsed since the Unix epoch measured using CLOCK_REALTIME in seconds and nanoseconds format. rtems_clock_get_realtime_bintime() - Gets the time elapsed since the Unix epoch measured using CLOCK_REALTIME in binary time format. rtems_clock_get_realtime_timeval() - Gets the time elapsed since the Unix epoch measured using CLOCK_REALTIME in seconds and microseconds format. rtems_clock_get_realtime_coarse() - Gets the time elapsed since the Unix epoch measured using CLOCK_REALTIME in coarse resolution in seconds and nanoseconds format. rtems_clock_get_realtime_coarse_bintime() - Gets the time elapsed since the Unix epoch measured using CLOCK_REALTIME in coarse resolution in binary time format. rtems_clock_get_realtime_coarse_timeval() - Gets the time elapsed since the Unix epoch measured using CLOCK_REALTIME in coarse resolution in seconds and microseconds format. rtems_clock_get_monotonic() - Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in seconds and nanoseconds format. rtems_clock_get_monotonic_bintime() - Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in binary time format. rtems_clock_get_monotonic_sbintime() - Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in signed binary time format. rtems_clock_get_monotonic_timeval() - Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in seconds and microseconds format. rtems_clock_get_monotonic_coarse() - Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in coarse resolution in seconds and nanoseconds format. rtems_clock_get_monotonic_coarse_bintime() - Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in coarse resolution in binary time format. rtems_clock_get_monotonic_coarse_timeval() - Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in coarse resolution in seconds and microseconds format. rtems_clock_get_boot_time() - Gets the time elapsed since the Unix epoch at some time point during system initialization in seconds and nanoseconds format. rtems_clock_get_boot_time_bintime() - Gets the time elapsed since the Unix epoch at some time point during system initialization in binary time format. rtems_clock_get_boot_time_timeval() - Gets the time elapsed since the Unix epoch at some time point during system initialization in seconds and microseconds format. rtems_clock_get_seconds_since_epoch() - Gets the seconds elapsed since the RTEMS epoch and the current CLOCK_REALTIME. rtems_clock_get_ticks_per_second() - Gets the number of clock ticks per second configured for the application. rtems_clock_get_ticks_since_boot() - Gets the number of clock ticks since some time point during the system initialization or the last overflow of the clock tick counter. rtems_clock_get_uptime() - Gets the seconds and nanoseconds elapsed since some time point during the system initialization using CLOCK_MONOTONIC. rtems_clock_get_uptime_timeval() - Gets the seconds and microseconds elapsed since some time point during the system initialization using CLOCK_MONOTONIC. rtems_clock_get_uptime_seconds() - Gets the seconds elapsed since some time point during the system initialization using CLOCK_MONOTONIC. rtems_clock_get_uptime_nanoseconds() - Gets the nanoseconds elapsed since some time point during the system initialization using CLOCK_MONOTONIC. rtems_clock_tick_later() - Gets a clock tick value which is at least delta clock ticks in the future. rtems_clock_tick_later_usec() - Gets a clock tick value which is at least delta microseconds in the future. rtems_clock_tick_before() - Indicates if the current clock tick counter is before the ticks.
clock,rtems_clock_set() - Sets the CLOCK_REALTIME to the time of day.
clock,rtems_clock_get_tod() - Gets the time of day associated with the current CLOCK_REALTIME.
clock,rtems_clock_get_tod_timeval() - Gets the seconds and microseconds elapsed since the Unix epoch and the current CLOCK_REALTIME.
clock,rtems_clock_get_realtime() - Gets the time elapsed since the Unix epoch measured using CLOCK_REALTIME in seconds and nanoseconds format.
clock,rtems_clock_get_realtime_bintime() - Gets the time elapsed since the Unix epoch measured using CLOCK_REALTIME in binary time format.
clock,rtems_clock_get_realtime_timeval() - Gets the time elapsed since the Unix epoch measured using CLOCK_REALTIME in seconds and microseconds format.
clock,rtems_clock_get_realtime_coarse() - Gets the time elapsed since the Unix epoch measured using CLOCK_REALTIME in coarse resolution in seconds and nanoseconds format.
clock,rtems_clock_get_realtime_coarse_bintime() - Gets the time elapsed since the Unix epoch measured using CLOCK_REALTIME in coarse resolution in binary time format.
clock,rtems_clock_get_realtime_coarse_timeval() - Gets the time elapsed since the Unix epoch measured using CLOCK_REALTIME in coarse resolution in seconds and microseconds format.
clock,rtems_clock_get_monotonic() - Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in seconds and nanoseconds format.
clock,rtems_clock_get_monotonic_bintime() - Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in binary time format.
clock,rtems_clock_get_monotonic_sbintime() - Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in signed binary time format.
clock,rtems_clock_get_monotonic_timeval() - Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in seconds and microseconds format.
clock,rtems_clock_get_monotonic_coarse() - Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in coarse resolution in seconds and nanoseconds format.
clock,rtems_clock_get_monotonic_coarse_bintime() - Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in coarse resolution in binary time format.
clock,rtems_clock_get_monotonic_coarse_timeval() - Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in coarse resolution in seconds and microseconds format.
clock,rtems_clock_get_boot_time() - Gets the time elapsed since the Unix epoch at some time point during system initialization in seconds and nanoseconds format.
clock,rtems_clock_get_boot_time_bintime() - Gets the time elapsed since the Unix epoch at some time point during system initialization in binary time format.
clock,rtems_clock_get_boot_time_timeval() - Gets the time elapsed since the Unix epoch at some time point during system initialization in seconds and microseconds format.
clock,rtems_clock_get_seconds_since_epoch() - Gets the seconds elapsed since the RTEMS epoch and the current CLOCK_REALTIME.
clock,rtems_clock_get_ticks_per_second() - Gets the number of clock ticks per second configured for the application.
clock,rtems_clock_get_ticks_since_boot() - Gets the number of clock ticks since some time point during the system initialization or the last overflow of the clock tick counter.
clock,rtems_clock_get_uptime() - Gets the seconds and nanoseconds elapsed since some time point during the system initialization using CLOCK_MONOTONIC.
clock,rtems_clock_get_uptime_timeval() - Gets the seconds and microseconds elapsed since some time point during the system initialization using CLOCK_MONOTONIC.
clock,rtems_clock_get_uptime_seconds() - Gets the seconds elapsed since some time point during the system initialization using CLOCK_MONOTONIC.
clock,rtems_clock_get_uptime_nanoseconds() - Gets the nanoseconds elapsed since some time point during the system initialization using CLOCK_MONOTONIC.
clock,rtems_clock_tick_later() - Gets a clock tick value which is at least delta clock ticks in the future.
clock,rtems_clock_tick_later_usec() - Gets a clock tick value which is at least delta microseconds in the future.
clock,rtems_clock_tick_before() - Indicates if the current clock tick counter is before the ticks.
clock,"© Copyright 1988, 2024 RTEMS Project and contributors."
clock,"RTEMS provides the several clock tick directives which are called from the user’s real-time clock ISR to inform RTEMS that a tick has elapsed.  Depending on the timer hardware capabilities the clock driver must choose the most appropriate clock tick directive.  The tick frequency value, defined in microseconds, is a configuration parameter found in the Configuration Table. RTEMS divides one million microseconds (one second) by the number of microseconds per tick to determine the number of calls to the clock tick directive per second.  The frequency of clock tick calls determines the resolution (granularity) for all time dependent RTEMS actions.  For example, calling the clock tick directive ten times per second yields a higher resolution than calling the clock tick two times per second.  The clock tick directives are responsible for maintaining both calendar time and the dynamic set of timers."
clock,"The rtems_clock_set directive allows a task or an ISR to set the date and time maintained by RTEMS.  If setting the date and time causes any outstanding timers to pass their deadline, then the expired timers will be fired during the invocation of the rtems_clock_set directive."
clock,"RTEMS provides multiple directives which can be used by an application to obtain the current date and time or date and time related information.  These directives allow a task or an ISR to obtain the current date and time or date and time related information.  The current date and time can be returned in either native or UNIX-style format.  Additionally, the application can obtain date and time related information such as the number of seconds since the RTEMS epoch, the number of ticks since the executive was initialized, and the number of ticks per second.  The following directives are available:"
clock,obtain native style date and time
clock,obtain UNIX-style date and time
clock,obtain number of ticks since RTEMS was initialized
clock,obtain number of seconds since RTEMS epoch
clock,obtain number of clock ticks per second
clock,Calendar time operations will return an error code if invoked before the date and time have been set.
clock,The directive CLOCK_GET - Get date and time information took an untyped pointer with an options argument to indicate the time information desired. This has been replaced with a set of typed directives:
clock,rtems_clock_get_seconds_since_epoch rtems_clock_get_ticks_per_second rtems_clock_get_ticks_since_boot rtems_clock_get_tod rtems_clock_get_tod_timeval
clock,rtems_clock_get_seconds_since_epoch
clock,rtems_clock_get_ticks_per_second
clock,rtems_clock_get_ticks_since_boot
clock,rtems_clock_get_tod
clock,rtems_clock_get_tod_timeval
clock,These directives directly correspond to what were previously referred to as clock options.  These strongly typed directives were available for multiple releases in parallel with rtems_clock_get() until that directive was removed.
clock,"© Copyright 1988, 2024 RTEMS Project and contributors."
config,"This section details the directives of the Application Configuration Information. A subsection is dedicated to each of this manager’s directives and lists the calling sequence, parameters, description, return values, and notes of the directive."
config,Gets the RTEMS build label.
config,CALLING SEQUENCE:
config,DESCRIPTION:
config,The build label is a user-provided string defined by the build configuration through the RTEMS_BUILD_LABEL build option.  The format of the string is completely user-defined.
config,RETURN VALUES:
config,Returns a pointer to the RTEMS build label.
config,NOTES:
config,The build label can be used to distinguish test suite results obtained from different build configurations.  A use case is to record test results with performance data to track performance regressions.  For this a database of performance limits is required.  The build label and the target hash obtained from rtems_get_target_hash() can be used as a key to obtain performance limits.
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Gets the RTEMS copyright notice.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,Returns a pointer to the RTEMS copyright notice.
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Gets the RTEMS target hash.
config,CALLING SEQUENCE:
config,DESCRIPTION:
config,The target hash is calculated from BSP-specific values which characterize a target system.  The target hash is encoded as a base64url string.  The target hash algorithm is unspecified.
config,RETURN VALUES:
config,Returns a pointer to the RTEMS target hash.
config,NOTES:
config,"For example, the device tree, settings of the memory controller, processor and bus frequencies, a serial number of a chip may be used to calculate the target hash."
config,The target hash can be used to distinguish test suite results obtained from different target systems.  See also rtems_get_build_label().
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Gets the RTEMS version string.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,Returns a pointer to the RTEMS version string.
config,NOTES:
config,The version string has no particular format.  Parsing the string may break across RTEMS releases.
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Indicates if the RTEMS Workspace is configured to be zeroed during system initialization for this application.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,"Returns true, if the RTEMS Workspace is configured to be zeroed during system initialization for this application, otherwise false."
config,NOTES:
config,The setting is defined by the CONFIGURE_ZERO_WORKSPACE_AUTOMATICALLY application configuration option.
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Gets the IDLE task stack size in bytes of this application.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,Returns the IDLE task stack size in bytes of this application.
config,NOTES:
config,The IDLE task stack size is defined by the CONFIGURE_IDLE_TASK_STACK_SIZE application configuration option.
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Gets the IDLE task body of this application.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,Returns the IDLE task body of this application.
config,NOTES:
config,The IDLE task body is defined by the CONFIGURE_IDLE_TASK_BODY application configuration option.
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Gets the interrupt stack size in bytes of this application.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,Returns the interrupt stack size in bytes of this application.
config,NOTES:
config,The interrupt stack size is defined by the CONFIGURE_INTERRUPT_STACK_SIZE application configuration option.
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Gets the resource number of Barrier Manager objects configured for this application.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,Returns the resource number of Barrier Manager objects configured for this application.
config,NOTES:
config,The resource number is defined by the CONFIGURE_MAXIMUM_BARRIERS application configuration option.  See also rtems_resource_is_unlimited() and rtems_resource_maximum_per_allocation().
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Gets the resource number of User Extensions Manager objects configured for this application.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,Returns the resource number of User Extensions Manager objects configured for this application.
config,NOTES:
config,The resource number is defined by the CONFIGURE_MAXIMUM_USER_EXTENSIONS application configuration option.  See also rtems_resource_is_unlimited() and rtems_resource_maximum_per_allocation().
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Gets the resource number of Message Manager objects configured for this application.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,Returns the resource number of Message Manager objects configured for this application.
config,NOTES:
config,The resource number is defined by the CONFIGURE_MAXIMUM_MESSAGE_QUEUES application configuration option.  See also rtems_resource_is_unlimited() and rtems_resource_maximum_per_allocation().
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Gets the resource number of Partition Manager objects configured for this application.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,Returns the resource number of Partition Manager objects configured for this application.
config,NOTES:
config,The resource number is defined by the CONFIGURE_MAXIMUM_PARTITIONS application configuration option.  See also rtems_resource_is_unlimited() and rtems_resource_maximum_per_allocation().
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Gets the resource number of Rate Monotonic Manager objects configured for this application.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,Returns the resource number of Rate Monotonic Manager objects configured for this application.
config,NOTES:
config,The resource number is defined by the CONFIGURE_MAXIMUM_PERIODS application configuration option.  See also rtems_resource_is_unlimited() and rtems_resource_maximum_per_allocation().
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Gets the resource number of Dual-Ported Memory Manager objects configured for this application.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,Returns the resource number of Dual-Ported Memory Manager objects configured for this application.
config,NOTES:
config,The resource number is defined by the CONFIGURE_MAXIMUM_PORTS application configuration option.  See also rtems_resource_is_unlimited() and rtems_resource_maximum_per_allocation().
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Gets the maximum number of processors configured for this application.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,Returns the maximum number of processors configured for this application.
config,NOTES:
config,The actual number of processors available to the application is returned by rtems_scheduler_get_processor_maximum() which less than or equal to the configured maximum number of processors (CONFIGURE_MAXIMUM_PROCESSORS).
config,"In uniprocessor configurations, this macro is a compile time constant which evaluates to one."
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Gets the resource number of Region Manager objects configured for this application.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,Returns the resource number of Region Manager objects configured for this application.
config,NOTES:
config,The resource number is defined by the CONFIGURE_MAXIMUM_REGIONS application configuration option.  See also rtems_resource_is_unlimited() and rtems_resource_maximum_per_allocation().
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Gets the resource number of Semaphore Manager objects configured for this application.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,Returns the resource number of Semaphore Manager objects configured for this application.
config,NOTES:
config,The resource number is defined by the CONFIGURE_MAXIMUM_SEMAPHORES application configuration option.  See also rtems_resource_is_unlimited() and rtems_resource_maximum_per_allocation().
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Gets the resource number of Task Manager objects configured for this application.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,Returns the resource number of Task Manager objects configured for this application.
config,NOTES:
config,The resource number is defined by the CONFIGURE_MAXIMUM_TASKS application configuration option.  See also rtems_resource_is_unlimited() and rtems_resource_maximum_per_allocation().
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Gets the resource number of Timer Manager objects configured for this application.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,Returns the resource number of Timer Manager objects configured for this application.
config,NOTES:
config,The resource number is defined by the CONFIGURE_MAXIMUM_TIMERS application configuration option.  See also rtems_resource_is_unlimited() and rtems_resource_maximum_per_allocation().
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Gets the number of microseconds per clock tick configured for this application.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,Returns the number of microseconds per clock tick configured for this application.
config,NOTES:
config,The number of microseconds per clock tick is defined by the CONFIGURE_MICROSECONDS_PER_TICK application configuration option.
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Gets the number of milliseconds per clock tick configured for this application.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,Returns the number of milliseconds per clock tick configured for this application.
config,NOTES:
config,The number of milliseconds per clock tick is defined by the CONFIGURE_MICROSECONDS_PER_TICK application configuration option.
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Gets the number of microseconds per clock tick configured for this application.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,Returns the number of microseconds per clock tick configured for this application.
config,NOTES:
config,The number of nanoseconds per clock tick is defined by the CONFIGURE_MICROSECONDS_PER_TICK application configuration option.
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Gets the number of initial extensions configured for this application.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,Returns the number of initial extensions configured for this application.
config,NOTES:
config,The number of initial extensions is defined by the CONFIGURE_INITIAL_EXTENSIONS application configuration option and related options.
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Gets the task stack allocator allocate hook used to allocate the stack of each IDLE task configured for this application.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,Returns the task stack allocator allocate hook used to allocate the stack of each IDLE task configured for this application.
config,NOTES:
config,The task stack allocator allocate hook for idle tasks is defined by the CONFIGURE_TASK_STACK_ALLOCATOR_FOR_IDLE application configuration option.
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Gets the task stack allocator allocate hook configured for this application.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,Returns the task stack allocator allocate hook configured for this application.
config,NOTES:
config,The task stack allocator allocate hook is defined by the CONFIGURE_TASK_STACK_ALLOCATOR application configuration option.
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Gets the task stack allocator initialization hook configured for this application.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,Returns the task stack allocator initialization hook configured for this application.
config,NOTES:
config,The task stack allocator initialization hook is defined by the CONFIGURE_TASK_STACK_ALLOCATOR_INIT application configuration option.
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Indicates if the task stack allocator is configured to avoid the RTEMS Workspace for this application.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,"Returns true, if the task stack allocator is configured to avoid the RTEMS Workspace for this application, otherwise false."
config,NOTES:
config,The setting is defined by the CONFIGURE_TASK_STACK_ALLOCATOR_AVOIDS_WORK_SPACE application configuration option.
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Gets the task stack allocator free hook configured for this application.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,Returns the task stack allocator free hook configured for this application.
config,NOTES:
config,The task stack allocator free hook is defined by the CONFIGURE_TASK_STACK_DEALLOCATOR application configuration option.
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Gets the configured size in bytes of the memory space used to allocate thread stacks for this application.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,Returns the configured size in bytes of the memory space used to allocate thread stacks for this application.
config,NOTES:
config,The size takes only threads and tasks into account with are known at the application configuration time.
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Gets the clock ticks per timeslice configured for this application.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,Returns the clock ticks per timeslice configured for this application.
config,NOTES:
config,The clock ticks per timeslice is defined by the CONFIGURE_TICKS_PER_TIMESLICE application configuration option.
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Indicates if the RTEMS Workspace and C Program Heap are configured to be unified for this application.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,"Returns true, if the RTEMS Workspace and C Program Heap are configured to be unified for this application, otherwise false."
config,NOTES:
config,The setting is defined by the CONFIGURE_UNIFIED_WORK_AREAS application configuration option.
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Gets the initial extensions table configured for this application.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,Returns a pointer to the initial extensions table configured for this application.
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Gets the MPCI configuration table configured for this application.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,Returns a pointer to the MPCI configuration table configured for this application.
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Gets the RTEMS Workspace size in bytes configured for this application.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,Returns the RTEMS Workspace size in bytes configured for this application.
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Gets the Classic API Configuration Table of this application.
config,CALLING SEQUENCE:
config,RETURN VALUES:
config,Returns a pointer to the Classic API Configuration Table of this application.
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
config,The directive may be called from within any runtime context.
config,The directive will not cause the calling task to be preempted.
config,Indicates if the resource is unlimited.
config,CALLING SEQUENCE:
config,PARAMETERS:
config,This parameter is the resource number.
config,RETURN VALUES:
config,"Returns true, if the resource is unlimited, otherwise false."
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,"The directive is implemented by a macro and may be called from within C/C++ constant expressions.  In addition, a function implementation of the directive exists for bindings to other programming languages. The directive will not cause the calling task to be preempted."
config,"The directive is implemented by a macro and may be called from within C/C++ constant expressions.  In addition, a function implementation of the directive exists for bindings to other programming languages."
config,The directive will not cause the calling task to be preempted.
config,Gets the maximum number per allocation of a resource number.
config,CALLING SEQUENCE:
config,PARAMETERS:
config,This parameter is the resource number.
config,RETURN VALUES:
config,Returns the maximum number per allocation of a resource number.
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,"The directive is implemented by a macro and may be called from within C/C++ constant expressions.  In addition, a function implementation of the directive exists for bindings to other programming languages. The directive will not cause the calling task to be preempted."
config,"The directive is implemented by a macro and may be called from within C/C++ constant expressions.  In addition, a function implementation of the directive exists for bindings to other programming languages."
config,The directive will not cause the calling task to be preempted.
config,Augments the resource number so that it indicates an unlimited resource.
config,CALLING SEQUENCE:
config,PARAMETERS:
config,This parameter is the resource number to augment.
config,RETURN VALUES:
config,Returns the resource number augmented to indicate an unlimited resource.
config,NOTES:
config,"This directive should be used to configure unlimited objects, see Unlimited Objects."
config,CONSTRAINTS:
config,The following constraints apply to this directive:
config,"The directive is implemented by a macro and may be called from within C/C++ constant expressions.  In addition, a function implementation of the directive exists for bindings to other programming languages. The directive will not cause the calling task to be preempted."
config,"The directive is implemented by a macro and may be called from within C/C++ constant expressions.  In addition, a function implementation of the directive exists for bindings to other programming languages."
config,The directive will not cause the calling task to be preempted.
config,"© Copyright 1988, 2024 RTEMS Project and contributors."
config,The application configuration information group provides an API to get the configuration of an application.
config,"RTEMS must be configured for an application.  This configuration encompasses a variety of information including the length of each clock tick, the maximum number of each information RTEMS object that can be created, the application initialization tasks, the task scheduling algorithm to be used, and the device drivers in the application."
config,"Although this information is contained in data structures that are used by RTEMS at system initialization time, the data structures themselves must not be generated by hand. RTEMS provides a set of macros system which provides a simple standard mechanism to automate the generation of these structures."
config,The RTEMS header file <rtems/confdefs.h> is at the core of the automatic generation of system configuration. It is based on the idea of setting macros which define configuration parameters of interest to the application and defaulting or calculating all others. This variety of macros can automatically produce all of the configuration data required for an RTEMS application.  The term confdefs is shorthand for a Configuration Defaults.
config,"As a general rule, application developers only specify values for the configuration parameters of interest to them. They define what resources or features they require. In most cases, when a parameter is not specified, it defaults to zero (0) instances, a standards compliant value, or disabled as appropriate. For example, by default there will be 256 task priority levels but this can be lowered by the application. This number of priority levels is required to be compliant with the RTEID/ORKID standards upon which the Classic API is based. There are similar cases where the default is selected to be compliant with the POSIX standard."
config,"For each configuration parameter in the configuration tables, the macro corresponding to that field is discussed. The RTEMS Maintainers expect that all systems can be easily configured using the <rtems/confdefs.h> mechanism and that using this mechanism will avoid internal RTEMS configuration changes impacting applications."
config,Some application configuration settings and other system parameters can be queried by the application. The directives provided by the Application Configuration Information are:
config,rtems_get_build_label() - Gets the RTEMS build label. rtems_get_copyright_notice() - Gets the RTEMS copyright notice. rtems_get_target_hash() - Gets the RTEMS target hash. rtems_get_version_string() - Gets the RTEMS version string. rtems_configuration_get_do_zero_of_workspace() - Indicates if the RTEMS Workspace is configured to be zeroed during system initialization for this application. rtems_configuration_get_idle_task_stack_size() - Gets the IDLE task stack size in bytes of this application. rtems_configuration_get_idle_task() - Gets the IDLE task body of this application. rtems_configuration_get_interrupt_stack_size() - Gets the interrupt stack size in bytes of this application. rtems_configuration_get_maximum_barriers() - Gets the resource number of Barrier Manager objects configured for this application. rtems_configuration_get_maximum_extensions() - Gets the resource number of User Extensions Manager objects configured for this application. rtems_configuration_get_maximum_message_queues() - Gets the resource number of Message Manager objects configured for this application. rtems_configuration_get_maximum_partitions() - Gets the resource number of Partition Manager objects configured for this application. rtems_configuration_get_maximum_periods() - Gets the resource number of Rate Monotonic Manager objects configured for this application. rtems_configuration_get_maximum_ports() - Gets the resource number of Dual-Ported Memory Manager objects configured for this application. rtems_configuration_get_maximum_processors() - Gets the maximum number of processors configured for this application. rtems_configuration_get_maximum_regions() - Gets the resource number of Region Manager objects configured for this application. rtems_configuration_get_maximum_semaphores() - Gets the resource number of Semaphore Manager objects configured for this application. rtems_configuration_get_maximum_tasks() - Gets the resource number of Task Manager objects configured for this application. rtems_configuration_get_maximum_timers() - Gets the resource number of Timer Manager objects configured for this application. rtems_configuration_get_microseconds_per_tick() - Gets the number of microseconds per clock tick configured for this application. rtems_configuration_get_milliseconds_per_tick() - Gets the number of milliseconds per clock tick configured for this application. rtems_configuration_get_nanoseconds_per_tick() - Gets the number of microseconds per clock tick configured for this application. rtems_configuration_get_number_of_initial_extensions() - Gets the number of initial extensions configured for this application. rtems_configuration_get_stack_allocate_for_idle_hook() - Gets the task stack allocator allocate hook used to allocate the stack of each IDLE task configured for this application. rtems_configuration_get_stack_allocate_hook() - Gets the task stack allocator allocate hook configured for this application. rtems_configuration_get_stack_allocate_init_hook() - Gets the task stack allocator initialization hook configured for this application. rtems_configuration_get_stack_allocator_avoids_work_space() - Indicates if the task stack allocator is configured to avoid the RTEMS Workspace for this application. rtems_configuration_get_stack_free_hook() - Gets the task stack allocator free hook configured for this application. rtems_configuration_get_stack_space_size() - Gets the configured size in bytes of the memory space used to allocate thread stacks for this application. rtems_configuration_get_ticks_per_timeslice() - Gets the clock ticks per timeslice configured for this application. rtems_configuration_get_unified_work_area() - Indicates if the RTEMS Workspace and C Program Heap are configured to be unified for this application. rtems_configuration_get_user_extension_table() - Gets the initial extensions table configured for this application. rtems_configuration_get_user_multiprocessing_table() - Gets the MPCI configuration table configured for this application. rtems_configuration_get_work_space_size() - Gets the RTEMS Workspace size in bytes configured for this application. rtems_configuration_get_rtems_api_configuration() - Gets the Classic API Configuration Table of this application. rtems_resource_is_unlimited() - Indicates if the resource is unlimited. rtems_resource_maximum_per_allocation() - Gets the maximum number per allocation of a resource number. rtems_resource_unlimited() - Augments the resource number so that it indicates an unlimited resource.
config,rtems_get_build_label() - Gets the RTEMS build label.
config,rtems_get_copyright_notice() - Gets the RTEMS copyright notice.
config,rtems_get_target_hash() - Gets the RTEMS target hash.
config,rtems_get_version_string() - Gets the RTEMS version string.
config,rtems_configuration_get_do_zero_of_workspace() - Indicates if the RTEMS Workspace is configured to be zeroed during system initialization for this application.
config,rtems_configuration_get_idle_task_stack_size() - Gets the IDLE task stack size in bytes of this application.
config,rtems_configuration_get_idle_task() - Gets the IDLE task body of this application.
config,rtems_configuration_get_interrupt_stack_size() - Gets the interrupt stack size in bytes of this application.
config,rtems_configuration_get_maximum_barriers() - Gets the resource number of Barrier Manager objects configured for this application.
config,rtems_configuration_get_maximum_extensions() - Gets the resource number of User Extensions Manager objects configured for this application.
config,rtems_configuration_get_maximum_message_queues() - Gets the resource number of Message Manager objects configured for this application.
config,rtems_configuration_get_maximum_partitions() - Gets the resource number of Partition Manager objects configured for this application.
config,rtems_configuration_get_maximum_periods() - Gets the resource number of Rate Monotonic Manager objects configured for this application.
config,rtems_configuration_get_maximum_ports() - Gets the resource number of Dual-Ported Memory Manager objects configured for this application.
config,rtems_configuration_get_maximum_processors() - Gets the maximum number of processors configured for this application.
config,rtems_configuration_get_maximum_regions() - Gets the resource number of Region Manager objects configured for this application.
config,rtems_configuration_get_maximum_semaphores() - Gets the resource number of Semaphore Manager objects configured for this application.
config,rtems_configuration_get_maximum_tasks() - Gets the resource number of Task Manager objects configured for this application.
config,rtems_configuration_get_maximum_timers() - Gets the resource number of Timer Manager objects configured for this application.
config,rtems_configuration_get_microseconds_per_tick() - Gets the number of microseconds per clock tick configured for this application.
config,rtems_configuration_get_milliseconds_per_tick() - Gets the number of milliseconds per clock tick configured for this application.
config,rtems_configuration_get_nanoseconds_per_tick() - Gets the number of microseconds per clock tick configured for this application.
config,rtems_configuration_get_number_of_initial_extensions() - Gets the number of initial extensions configured for this application.
config,rtems_configuration_get_stack_allocate_for_idle_hook() - Gets the task stack allocator allocate hook used to allocate the stack of each IDLE task configured for this application.
config,rtems_configuration_get_stack_allocate_hook() - Gets the task stack allocator allocate hook configured for this application.
config,rtems_configuration_get_stack_allocate_init_hook() - Gets the task stack allocator initialization hook configured for this application.
config,rtems_configuration_get_stack_allocator_avoids_work_space() - Indicates if the task stack allocator is configured to avoid the RTEMS Workspace for this application.
config,rtems_configuration_get_stack_free_hook() - Gets the task stack allocator free hook configured for this application.
config,rtems_configuration_get_stack_space_size() - Gets the configured size in bytes of the memory space used to allocate thread stacks for this application.
config,rtems_configuration_get_ticks_per_timeslice() - Gets the clock ticks per timeslice configured for this application.
config,rtems_configuration_get_unified_work_area() - Indicates if the RTEMS Workspace and C Program Heap are configured to be unified for this application.
config,rtems_configuration_get_user_extension_table() - Gets the initial extensions table configured for this application.
config,rtems_configuration_get_user_multiprocessing_table() - Gets the MPCI configuration table configured for this application.
config,rtems_configuration_get_work_space_size() - Gets the RTEMS Workspace size in bytes configured for this application.
config,rtems_configuration_get_rtems_api_configuration() - Gets the Classic API Configuration Table of this application.
config,rtems_resource_is_unlimited() - Indicates if the resource is unlimited.
config,rtems_resource_maximum_per_allocation() - Gets the maximum number per allocation of a resource number.
config,rtems_resource_unlimited() - Augments the resource number so that it indicates an unlimited resource.
config,"© Copyright 1988, 2024 RTEMS Project and contributors."
dual-ported-memory,"A dual-ported memory area (DPMA) is an contiguous block of RAM owned by a particular processor but which can be accessed by other processors in the system.  The owner accesses the memory using internal addresses, while other processors must use external addresses.  RTEMS defines a port as a particular mapping of internal and external addresses."
dual-ported-memory,There are two system configurations in which dual-ported memory is commonly found.  The first is tightly-coupled multiprocessor computer systems where the dual-ported memory is shared between all nodes and is used for inter-node communication.  The second configuration is computer systems with intelligent peripheral controllers.  These controllers typically utilize the DPMA for high-performance data transfers.
dual-ported-memory,"© Copyright 1988, 2024 RTEMS Project and contributors."
dual-ported-memory,"This section details the directives of the Dual-Ported Memory Manager. A subsection is dedicated to each of this manager’s directives and lists the calling sequence, parameters, description, return values, and notes of the directive."
dual-ported-memory,Creates a port.
dual-ported-memory,CALLING SEQUENCE:
dual-ported-memory,PARAMETERS:
dual-ported-memory,This parameter is the object name of the port.
dual-ported-memory,This parameter is the internal start address of the memory area.
dual-ported-memory,This parameter is the external start address of the memory area.
dual-ported-memory,This parameter is the length in bytes of the memory area.
dual-ported-memory,"This parameter is the pointer to an rtems_id object.  When the directive call is successful, the identifier of the created port will be stored in this object."
dual-ported-memory,DESCRIPTION:
dual-ported-memory,This directive creates a port which resides on the local node.  The port has the user-defined object name specified in name.  The assigned object identifier is returned in id.  This identifier is used to access the port with other dual-ported memory port related directives.
dual-ported-memory,RETURN VALUES:
dual-ported-memory,The requested operation was successful.
dual-ported-memory,The name parameter was invalid.
dual-ported-memory,The id parameter was NULL.
dual-ported-memory,The internal_start parameter was not properly aligned.
dual-ported-memory,The external_start parameter was not properly aligned.
dual-ported-memory,There was no inactive object available to create a port.  The number of port available to the application is configured through the CONFIGURE_MAXIMUM_PORTS application configuration option.
dual-ported-memory,NOTES:
dual-ported-memory,The internal_start and external_start parameters must be on a boundary defined by the target processor architecture.
dual-ported-memory,"For control and maintenance of the port, RTEMS allocates a DPCB from the local DPCB free pool and initializes it."
dual-ported-memory,CONSTRAINTS:
dual-ported-memory,The following constraints apply to this directive:
dual-ported-memory,"The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted. The number of ports available to the application is configured through the CONFIGURE_MAXIMUM_PORTS application configuration option. Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace."
dual-ported-memory,The directive may be called from within device driver initialization context.
dual-ported-memory,The directive may be called from within task context.
dual-ported-memory,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
dual-ported-memory,The number of ports available to the application is configured through the CONFIGURE_MAXIMUM_PORTS application configuration option.
dual-ported-memory,"Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace."
dual-ported-memory,Identifies a port by the object name.
dual-ported-memory,CALLING SEQUENCE:
dual-ported-memory,PARAMETERS:
dual-ported-memory,This parameter is the object name to look up.
dual-ported-memory,"This parameter is the pointer to an rtems_id object.  When the directive call is successful, the object identifier of an object with the specified name will be stored in this object."
dual-ported-memory,DESCRIPTION:
dual-ported-memory,This directive obtains a port identifier associated with the port name specified in name.
dual-ported-memory,RETURN VALUES:
dual-ported-memory,The requested operation was successful.
dual-ported-memory,The id parameter was NULL.
dual-ported-memory,The name parameter was 0.
dual-ported-memory,There was no object with the specified name on the local node.
dual-ported-memory,NOTES:
dual-ported-memory,"If the port name is not unique, then the port identifier will match the first port with that name in the search order.  However, this port identifier is not guaranteed to correspond to the desired port."
dual-ported-memory,The objects are searched from lowest to the highest index.  Only the local node is searched.
dual-ported-memory,The port identifier is used with other dual-ported memory related directives to access the port.
dual-ported-memory,CONSTRAINTS:
dual-ported-memory,The following constraints apply to this directive:
dual-ported-memory,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
dual-ported-memory,The directive may be called from within any runtime context.
dual-ported-memory,The directive will not cause the calling task to be preempted.
dual-ported-memory,Deletes the port.
dual-ported-memory,CALLING SEQUENCE:
dual-ported-memory,PARAMETERS:
dual-ported-memory,This parameter is the port identifier.
dual-ported-memory,DESCRIPTION:
dual-ported-memory,This directive deletes the port specified by id.
dual-ported-memory,RETURN VALUES:
dual-ported-memory,The requested operation was successful.
dual-ported-memory,There was no port associated with the identifier specified by id.
dual-ported-memory,NOTES:
dual-ported-memory,The DPCB for the deleted port is reclaimed by RTEMS.
dual-ported-memory,CONSTRAINTS:
dual-ported-memory,The following constraints apply to this directive:
dual-ported-memory,"The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted. The calling task does not have to be the task that created the object.  Any local task that knows the object identifier can delete the object. Where the object class corresponding to the directive is configured to use unlimited objects, the directive may free memory to the RTEMS Workspace."
dual-ported-memory,The directive may be called from within device driver initialization context.
dual-ported-memory,The directive may be called from within task context.
dual-ported-memory,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
dual-ported-memory,The calling task does not have to be the task that created the object.  Any local task that knows the object identifier can delete the object.
dual-ported-memory,"Where the object class corresponding to the directive is configured to use unlimited objects, the directive may free memory to the RTEMS Workspace."
dual-ported-memory,Converts the external address to the internal address.
dual-ported-memory,CALLING SEQUENCE:
dual-ported-memory,PARAMETERS:
dual-ported-memory,This parameter is the port identifier.
dual-ported-memory,This parameter is the external address to convert.
dual-ported-memory,"This parameter is the pointer to a void pointer object.  When the directive call is successful, the external address associated with the internal address will be stored in this object."
dual-ported-memory,DESCRIPTION:
dual-ported-memory,"This directive converts a dual-ported memory address from external to internal representation for the specified port.  If the given external address is invalid for the specified port, then the internal address is set to the given external address."
dual-ported-memory,RETURN VALUES:
dual-ported-memory,The requested operation was successful.
dual-ported-memory,The id parameter was invalid.
dual-ported-memory,The internal parameter was NULL.
dual-ported-memory,CONSTRAINTS:
dual-ported-memory,The following constraints apply to this directive:
dual-ported-memory,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive will not cause the calling task to be preempted.
dual-ported-memory,The directive may be called from within interrupt context.
dual-ported-memory,The directive may be called from within device driver initialization context.
dual-ported-memory,The directive may be called from within task context.
dual-ported-memory,The directive will not cause the calling task to be preempted.
dual-ported-memory,Converts the internal address to the external address.
dual-ported-memory,CALLING SEQUENCE:
dual-ported-memory,PARAMETERS:
dual-ported-memory,This parameter is the port identifier.
dual-ported-memory,This parameter is the internal address to convert.
dual-ported-memory,"This parameter is the pointer to a void pointer object.  When the directive call is successful, the external address associated with the internal address will be stored in this object."
dual-ported-memory,DESCRIPTION:
dual-ported-memory,"This directive converts a dual-ported memory address from internal to external representation so that it can be passed to owner of the DPMA represented by the specified port.  If the given internal address is an invalid dual-ported address, then the external address is set to the given internal address."
dual-ported-memory,RETURN VALUES:
dual-ported-memory,The requested operation was successful.
dual-ported-memory,The id parameter was invalid.
dual-ported-memory,The external parameter was NULL.
dual-ported-memory,CONSTRAINTS:
dual-ported-memory,The following constraints apply to this directive:
dual-ported-memory,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive will not cause the calling task to be preempted.
dual-ported-memory,The directive may be called from within interrupt context.
dual-ported-memory,The directive may be called from within device driver initialization context.
dual-ported-memory,The directive may be called from within task context.
dual-ported-memory,The directive will not cause the calling task to be preempted.
dual-ported-memory,"© Copyright 1988, 2024 RTEMS Project and contributors."
dual-ported-memory,The Dual-Ported Memory Manager provides a mechanism for converting addresses between internal and external representations for multiple dual-ported memory areas (DPMA). The directives provided by the Dual-Ported Memory Manager are:
dual-ported-memory,rtems_port_create() - Creates a port. rtems_port_ident() - Identifies a port by the object name. rtems_port_delete() - Deletes the port. rtems_port_external_to_internal() - Converts the external address to the internal address. rtems_port_internal_to_external() - Converts the internal address to the external address.
dual-ported-memory,rtems_port_create() - Creates a port.
dual-ported-memory,rtems_port_ident() - Identifies a port by the object name.
dual-ported-memory,rtems_port_delete() - Deletes the port.
dual-ported-memory,rtems_port_external_to_internal() - Converts the external address to the internal address.
dual-ported-memory,rtems_port_internal_to_external() - Converts the internal address to the external address.
dual-ported-memory,"© Copyright 1988, 2024 RTEMS Project and contributors."
dual-ported-memory,The rtems_port_create directive creates a port into a DPMA with the user-defined name.  The user specifies the association between internal and external representations for the port being created.  RTEMS allocates a Dual-Ported Memory Control Block (DPCB) from the DPCB free list to maintain the newly created DPMA.  RTEMS also generates a unique dual-ported memory port ID which is returned to the calling task.  RTEMS does not initialize the dual-ported memory area or access any memory within it.
dual-ported-memory,"When a port is created, RTEMS generates a unique port ID and assigns it to the created port until it is deleted.  The port ID may be obtained by either of two methods.  First, as the result of an invocation of the``rtems_port_create`` directive, the task ID is stored in a user provided location.  Second, the port ID may be obtained later using the rtems_port_ident directive.  The port ID is used by other dual-ported memory manager directives to access this port."
dual-ported-memory,"The rtems_port_external_to_internal directive is used to convert an address from external to internal representation for the specified port.  The rtems_port_internal_to_external directive is used to convert an address from internal to external representation for the specified port.  If an attempt is made to convert an address which lies outside the specified DPMA, then the address to be converted will be returned."
dual-ported-memory,"A port can be removed from the system and returned to RTEMS with the rtems_port_delete directive.  When a port is deleted, its control block is returned to the DPCB free list."
dual-ported-memory,"© Copyright 1988, 2024 RTEMS Project and contributors."
event,An event flag is used by a task (or ISR) to inform another task of the occurrence of a significant situation.  Thirty-two event flags are associated with each task.  A collection of one or more event flags is referred to as an event set.  The data type rtems_event_set is used to manage event sets.
event,The application developer should remember the following key characteristics of event operations when utilizing the event manager:
event,"Events provide a simple synchronization facility. Events are aimed at tasks. Tasks can wait on more than one event simultaneously. Events are independent of one another. Events do not hold or transport data. Events are not queued.  In other words, if an event is sent more than once to a task before being received, the second and subsequent send operations to that same task have no effect."
event,Events provide a simple synchronization facility.
event,Events are aimed at tasks.
event,Tasks can wait on more than one event simultaneously.
event,Events are independent of one another.
event,Events do not hold or transport data.
event,"Events are not queued.  In other words, if an event is sent more than once to a task before being received, the second and subsequent send operations to that same task have no effect."
event,An event set is posted when it is directed (or sent) to a task.  A pending event is an event that has been posted but not received.  An event condition is used to specify the event set which the task desires to receive and the algorithm which will be used to determine when the request is satisfied. An event condition is satisfied based upon one of two algorithms which are selected by the user.  The RTEMS_EVENT_ANY algorithm states that an event condition is satisfied when at least a single requested event is posted.  The RTEMS_EVENT_ALL algorithm states that an event condition is satisfied when every requested event is posted.
event,"An event set or condition is built by a bitwise OR of the desired events.  The set of valid events is RTEMS_EVENT_0 through RTEMS_EVENT_31.  If an event is not explicitly specified in the set or condition, then it is not present.  Events are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each event appears exactly once in the event set list."
event,"For example, when sending the event set consisting of RTEMS_EVENT_6, RTEMS_EVENT_15, and RTEMS_EVENT_31, the event parameter to the rtems_event_send directive should be RTEMS_EVENT_6 | RTEMS_EVENT_15 | RTEMS_EVENT_31."
event,"In general, an option is built by a bitwise OR of the desired option components.  The set of valid options for the rtems_event_receive directive are listed in the following table:"
event,RTEMS_WAIT task will wait for event (default) RTEMS_NO_WAIT task should not wait RTEMS_EVENT_ALL return after all events (default) RTEMS_EVENT_ANY return after any events
event,RTEMS_WAIT
event,task will wait for event (default)
event,RTEMS_NO_WAIT
event,task should not wait
event,RTEMS_EVENT_ALL
event,return after all events (default)
event,RTEMS_EVENT_ANY
event,return after any events
event,"Option values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each option appears exactly once in the component list.  An option listed as a default is not required to appear in the option list, although it is a good programming practice to specify default options.  If all defaults are desired, the option RTEMS_DEFAULT_OPTIONS should be specified on this call."
event,This example demonstrates the option parameter needed to poll for all events in a particular event condition to arrive.  The option parameter passed to the rtems_event_receive directive should be either RTEMS_EVENT_ALL | RTEMS_NO_WAIT or RTEMS_NO_WAIT.  The option parameter can be set to RTEMS_NO_WAIT because RTEMS_EVENT_ALL is the default condition for rtems_event_receive.
event,"© Copyright 1988, 2024 RTEMS Project and contributors."
event,"This section details the directives of the Event Manager. A subsection is dedicated to each of this manager’s directives and lists the calling sequence, parameters, description, return values, and notes of the directive."
event,Sends the event set to the task.
event,CALLING SEQUENCE:
event,PARAMETERS:
event,This parameter is the identifier of the target task to receive the event set.
event,This parameter is the event set to send.
event,DESCRIPTION:
event,"This directive sends the event set, event_in, to the target task identified by id.  Based upon the state of the target task, one of the following situations applies:"
event,"The target task is blocked waiting for events, then if the waiting task’s input event condition is satisfied, then the task is made ready for execution, or otherwise, the event set is posted but left pending and the task remains blocked. if the waiting task’s input event condition is satisfied, then the task is made ready for execution, or otherwise, the event set is posted but left pending and the task remains blocked. The target task is not waiting for events, then the event set is posted and left pending."
event,"The target task is blocked waiting for events, then"
event,"if the waiting task’s input event condition is satisfied, then the task is made ready for execution, or otherwise, the event set is posted but left pending and the task remains blocked."
event,"if the waiting task’s input event condition is satisfied, then the task is made ready for execution, or"
event,"otherwise, the event set is posted but left pending and the task remains blocked."
event,"The target task is not waiting for events, then the event set is posted and left pending."
event,RETURN VALUES:
event,The requested operation was successful.
event,There was no task associated with the identifier specified by id.
event,NOTES:
event,Events can be sent by tasks or an ISR.
event,Specifying RTEMS_SELF for id results in the event set being sent to the calling task.
event,"The event set to send shall be built by a bitwise or of the desired events. The set of valid events is RTEMS_EVENT_0 through RTEMS_EVENT_31.  If an event is not explicitly specified in the set, then it is not present."
event,"Identical events sent to a task are not queued.  In other words, the second, and subsequent, posting of an event to a task before it can perform an rtems_event_receive() has no effect."
event,The calling task will be preempted if it has preemption enabled and a higher priority task is unblocked as the result of this directive.
event,Sending an event set to a global task which does not reside on the local node will generate a request telling the remote node to send the event set to the appropriate task.
event,CONSTRAINTS:
event,The following constraints apply to this directive:
event,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may unblock a task.  This may cause the calling task to be preempted.
event,The directive may be called from within interrupt context.
event,The directive may be called from within device driver initialization context.
event,The directive may be called from within task context.
event,The directive may unblock a task.  This may cause the calling task to be preempted.
event,Receives or gets an event set from the calling task.
event,CALLING SEQUENCE:
event,PARAMETERS:
event,This parameter is the event set of interest.  Use RTEMS_PENDING_EVENTS to get the pending events.
event,This parameter is the option set.
event,This parameter is the timeout in clock ticks if the RTEMS_WAIT option is set.  Use RTEMS_NO_TIMEOUT to wait potentially forever.
event,This parameter is the pointer to an event set.  The received or pending events are stored in the referenced event set if the operation was successful.
event,DESCRIPTION:
event,This directive can be used to
event,"get the pending events of the calling task, or receive events."
event,"get the pending events of the calling task, or"
event,receive events.
event,To get the pending events use the constant RTEMS_PENDING_EVENTS for the event_in parameter.  The pending events are returned to the calling task but the event set of the calling task is left unaltered.  The option_set and ticks parameters are ignored in this case.  The directive returns immediately and does not block.
event,To receive events you have to define an input event condition and some options.
event,"The option set specified in option_set is built through a bitwise or of the option constants described below.  Not all combinations of options are allowed.  Some options are mutually exclusive.  If mutually exclusive options are combined, the behaviour is undefined.  Options not mentioned below are not evaluated by this directive and have no effect. Default options can be selected by using the RTEMS_DEFAULT_OPTIONS constant.  The option set defines"
event,"if the calling task will wait or poll for the events, and if the calling task wants to receive all or any of the input events."
event,"if the calling task will wait or poll for the events, and"
event,if the calling task wants to receive all or any of the input events.
event,The calling task can wait or poll for the events.
event,"Waiting for events is the default and can be emphasized through the use of the RTEMS_WAIT option.  The ticks parameter defines how long the calling task is willing to wait.  Use RTEMS_NO_TIMEOUT to wait potentially forever, otherwise set a timeout interval in clock ticks. Not waiting for events (polling) is selected by the RTEMS_NO_WAIT option.  If this option is defined, then the ticks parameter is ignored."
event,"Waiting for events is the default and can be emphasized through the use of the RTEMS_WAIT option.  The ticks parameter defines how long the calling task is willing to wait.  Use RTEMS_NO_TIMEOUT to wait potentially forever, otherwise set a timeout interval in clock ticks."
event,"Not waiting for events (polling) is selected by the RTEMS_NO_WAIT option.  If this option is defined, then the ticks parameter is ignored."
event,The calling task can receive all or any of the input events specified in event_in.
event,Receiving all input events is the default and can be emphasized through the use of the RTEMS_EVENT_ALL option. Receiving any of the input events is selected by the RTEMS_EVENT_ANY option.
event,Receiving all input events is the default and can be emphasized through the use of the RTEMS_EVENT_ALL option.
event,Receiving any of the input events is selected by the RTEMS_EVENT_ANY option.
event,RETURN VALUES:
event,The requested operation was successful.
event,The event_out parameter was NULL.
event,The events of interest were not immediately available.
event,The events of interest were not available within the specified timeout interval.
event,NOTES:
event,This directive only affects the events specified in event_in. Any pending events that do not correspond to any of the events specified in event_in will be left pending.
event,To receive all events use the event set constant RTEMS_ALL_EVENTS for the event_in parameter.  Do not confuse this event set constant with the directive option RTEMS_EVENT_ALL.
event,A task can receive all of the pending events by calling the directive with a value of RTEMS_ALL_EVENTS for the event_in parameter and the bitwise or of the RTEMS_NO_WAIT and RTEMS_EVENT_ANY options for the option_set parameter.  The pending events are returned and the event set of the task is cleared.  If no events are pending then the RTEMS_UNSATISFIED status code will be returned.
event,CONSTRAINTS:
event,The following constraints apply to this directive:
event,The directive may be called from within device driver initialization context. The directive may be called from within task context. The timeout functionality of the directive requires a clock tick.
event,The directive may be called from within device driver initialization context.
event,The directive may be called from within task context.
event,The timeout functionality of the directive requires a clock tick.
event,"© Copyright 1988, 2024 RTEMS Project and contributors."
event,The Event Manager provides a high performance method of inter-task communication and synchronization. The directives provided by the Event Manager are:
event,rtems_event_send() - Sends the event set to the task. rtems_event_receive() - Receives or gets an event set from the calling task.
event,rtems_event_send() - Sends the event set to the task.
event,rtems_event_receive() - Receives or gets an event set from the calling task.
event,"© Copyright 1988, 2024 RTEMS Project and contributors."
event,"The rtems_event_send directive allows a task (or an ISR) to direct an event set to a target task.  Based upon the state of the target task, one of the following situations applies:"
event,"Target Task is Blocked Waiting for Events If the waiting task’s input event condition is satisfied, then the task is made ready for execution. If the waiting task’s input event condition is not satisfied, then the event set is posted but left pending and the task remains blocked. If the waiting task’s input event condition is satisfied, then the task is made ready for execution. If the waiting task’s input event condition is not satisfied, then the event set is posted but left pending and the task remains blocked. Target Task is Not Waiting for Events The event set is posted and left pending. The event set is posted and left pending."
event,Target Task is Blocked Waiting for Events
event,"If the waiting task’s input event condition is satisfied, then the task is made ready for execution. If the waiting task’s input event condition is not satisfied, then the event set is posted but left pending and the task remains blocked."
event,"If the waiting task’s input event condition is satisfied, then the task is made ready for execution."
event,"If the waiting task’s input event condition is not satisfied, then the event set is posted but left pending and the task remains blocked."
event,Target Task is Not Waiting for Events
event,The event set is posted and left pending.
event,The event set is posted and left pending.
event,"The rtems_event_receive directive is used by tasks to accept a specific input event condition.  The task also specifies whether the request is satisfied when all requested events are available or any single requested event is available.  If the requested event condition is satisfied by pending events, then a successful return code and the satisfying event set are returned immediately.  If the condition is not satisfied, then one of the following situations applies:"
event,"By default, the calling task will wait forever for the event condition to be satisfied. Specifying the RTEMS_NO_WAIT option forces an immediate return with an error status code. Specifying a timeout limits the period the task will wait before returning with an error status code."
event,"By default, the calling task will wait forever for the event condition to be satisfied."
event,Specifying the RTEMS_NO_WAIT option forces an immediate return with an error status code.
event,Specifying a timeout limits the period the task will wait before returning with an error status code.
event,A task can determine the pending event set by calling the rtems_event_receive directive with a value of RTEMS_PENDING_EVENTS for the input event condition.  The pending events are returned to the calling task but the event set is left unaltered.
event,A task can receive all of the currently pending events by calling the rtems_event_receive directive with a value of RTEMS_ALL_EVENTS for the input event condition and RTEMS_NO_WAIT | RTEMS_EVENT_ANY for the option set.  The pending events are returned to the calling task and the event set is cleared.  If no events are pending then the RTEMS_UNSATISFIED status code will be returned.
event,"© Copyright 1988, 2024 RTEMS Project and contributors."
fatal-error,"The fatal error manager is called upon detection of an irrecoverable error condition by either RTEMS or the application software.  Fatal errors are also used in case it is difficult or impossible to return an error condition by other means, e.g. a return value of a directive call.  Fatal errors can be detected from various sources, for example"
fatal-error,"the executive (RTEMS), support libraries, user system code, user application code, and processor interrupts and exceptions (data abort, instruction prefetch errors, ECC errors, spurious interrupts, etc.)."
fatal-error,"the executive (RTEMS),"
fatal-error,"support libraries,"
fatal-error,"user system code,"
fatal-error,"user application code, and"
fatal-error,"processor interrupts and exceptions (data abort, instruction prefetch errors, ECC errors, spurious interrupts, etc.)."
fatal-error,"RTEMS automatically invokes the fatal error manager upon detection of an error it considers to be fatal.  Similarly, the user should invoke the fatal error manager upon detection of a fatal error."
fatal-error,"Each user extensions set may include a fatal error handler.  The fatal error handler in the initial extension sets can be used to provide access to debuggers and monitors which may be present on the target hardware. If any user-supplied fatal error handlers are installed, the fatal error manager will invoke them.  Usually, the board support package provides a fatal error extension which resets the board.  If no user handlers are configured or if all the user handler return control to the fatal error manager, then the CPU port provided idle loop executes."
fatal-error,"The _Terminate() handler is invoked to terminate the system.  It is called by all services which determine that a system termination is required. For example, it is called by all higher level directives which announce a fatal error, see Announcing a Fatal Error."
fatal-error,The first action of the system termination handler is to disable maskable interrupts.  This ensures that interrupts on this processor do not interfere with the system termination procedure.  This reduces the likelihood to end up in a recursive system termination procedure.
fatal-error,The second action of the system termination handler is to call the fatal extensions of the user extensions.
fatal-error,The fatal extensions are called with three parameters:
fatal-error,"the fatal source, a legacy parameter which is always set to false, and an error code with a fatal source dependent content."
fatal-error,"the fatal source,"
fatal-error,"a legacy parameter which is always set to false, and"
fatal-error,an error code with a fatal source dependent content.
fatal-error,"The fatal extensions of the initial extension sets are invoked first. For them, the following execution environment is required"
fatal-error,"a valid stack pointer and enough stack space, a valid code memory, and valid read-only data."
fatal-error,"a valid stack pointer and enough stack space,"
fatal-error,"a valid code memory, and"
fatal-error,valid read-only data.
fatal-error,"In uniprocessor configurations, the read-write data (including .bss segment) is not required.  In SMP configurations, however, the read-write data must have been initialized to determine the state of the other processors and request them to shut-down if necessary.  The board support package (BSP) may install an initial extension that performs a system reset.  See the BSP documentation in the RTEMS User Manual for more information how the system reset is done.  The BSP provided fatal extension can be disabled by the CONFIGURE_DISABLE_BSP_SETTINGS application configuration option.  It is recommended to provide an application-specific fatal extension using the CONFIGURE_INITIAL_EXTENSIONS application configuration option."
fatal-error,"In certain error conditions, it may be unreliable to carry out the following steps of the termination procedure since the read-write data may be corrupt. One of the fatal extensions of the initial extension set should reset the system to stop the system termination procedure."
fatal-error,"After invoking the fatal extensions of the initial extension sets, the fatal extensions of the dynamic extension sets are invoked.  For this procedure valid read-write data is required."
fatal-error,"The last action of the system termination handler is to execute the CPU port provided idle loop with maskable interrupts disabled.  Please note, that properly configured applications should not reach this point."
fatal-error,The following fatal sources are defined for RTEMS via the rtems_fatal_source enumeration.  Each symbolic name has the corresponding numeric fatal source in parenthesis.
fatal-error,Errors of the core operating system.  See Internal Error Codes.
fatal-error,Errors of the Classic API.
fatal-error,Errors of the POSIX API.
fatal-error,Fatal source for the block device cache.  See rtems_bdbuf_fatal_code.
fatal-error,Fatal source for application-specific errors.  The fatal code is application-specific.
fatal-error,Fatal source of exit().  The fatal code is the exit() status code.
fatal-error,Fatal source for BSP errors.  The fatal codes are defined in <bsp/fatal.h>.  Examples are interrupt and exception initialization.  See bsp_fatal_code and bsp_fatal().
fatal-error,Fatal source of assert().  The fatal code is the pointer value of the assert context.  See rtems_assert_context.
fatal-error,Fatal source of the stack checker.  The fatal code is the object name of the executing task.
fatal-error,Fatal source of the exceptions.  The fatal code is the pointer value of the exception frame pointer.  See rtems_exception_frame and rtems_exception_frame_print.
fatal-error,Fatal source of SMP domain.  See SMP_Fatal_code.
fatal-error,"Fatal source of rtems_panic(), see rtems_panic."
fatal-error,Fatal source for invalid C program heap frees via free().  The fatal code is the bad pointer.
fatal-error,Fatal source for heap errors.  The fatal code is the address to a heap error context.  See Heap_Error_context.
fatal-error,The following error codes are defined for the INTERNAL_ERROR_CORE fatal source.  Each symbolic name has the corresponding numeric error code in parenthesis.
fatal-error,There is not enough memory for the workspace.  This fatal error may occur during system initialization.  It is an application configuration error.
fatal-error,A non-POSIX thread entry function returned.  This is an API usage error.
fatal-error,An example code to provoke this fatal error is:
fatal-error,This fatal error can only occur on MPCI configurations.  The MPCI nodes or global objects configuration is inconsistent.  This fatal error may occur during system initialization.  It is an application configuration error.
fatal-error,This fatal error can only occur on MPCI configurations.  The own MPCI node number is invalid.  This fatal error may occur during system initialization.  It is an application configuration error.
fatal-error,This fatal error can only occur on MPCI configurations.  There is no MPCI configuration table.  This fatal error may occur during system initialization.  It is an application configuration error.
fatal-error,This fatal error can only occur on MPCI configurations.  The MPCI server thread received a bad packet.
fatal-error,This fatal error can only occur on MPCI configurations.  The MPCI packet pool is empty.  It is an application configuration error.
fatal-error,This fatal error can only occur on MPCI configurations.  The MPCI global objects pool is empty.  It is an application configuration error.
fatal-error,This fatal error can only occur on MPCI configurations.  The MPCI thread proxy pool is empty.  It is an application configuration error.
fatal-error,"This fatal error can only occur on MPCI configurations.  The system cannot find the global object for a specific object identifier.  In case this happens, then this is probably an operating system bug."
fatal-error,There is not enough memory for the C program heap.  This fatal error may occur during system initialization.  It is an application configuration error.
fatal-error,The use of _CPU_ISR_install_vector() is illegal on this system.
fatal-error,This fatal error can only occur on debug configurations.  It happens in case a thread which owns mutexes is deleted.  Mutexes owned by a deleted thread are in an inconsistent state.
fatal-error,An RTEMS initialization task entry function is NULL.  This fatal error may occur during system initialization.  It is an application configuration error.
fatal-error,A deadlock was detected during a thread queue enqueue operation.
fatal-error,"This fatal error can only happen in SMP configurations.  It is not allowed to obtain MrsP semaphores in a context with thread dispatching disabled, for example interrupt context."
fatal-error,An example code to provoke this fatal error is:
fatal-error,"It is illegal to call blocking operating system services with thread dispatching disabled, for example in interrupt context."
fatal-error,An example code to provoke this fatal error is:
fatal-error,"In SMP configurations, it is a fatal error to call blocking operating system with interrupts disabled, since this prevents delivery of inter-processor interrupts.  This could lead to executing threads which are not allowed to execute resulting in undefined system behaviour."
fatal-error,"Some CPU ports, for example the ARM Cortex-M port, have a similar problem, since the interrupt state is not a part of the thread context."
fatal-error,This fatal error is detected in the operating system core function _Thread_Do_dispatch() responsible to carry out a thread dispatch.
fatal-error,An example code to provoke this fatal error is:
fatal-error,The creation of the RTEMS initialization task failed.  This fatal error may occur during system initialization.  It is an application configuration error.
fatal-error,The creation of the POSIX initialization thread failed.  This fatal error may occur during system initialization.  It is an application configuration error.
fatal-error,Open of the standard output file descriptor failed or resulted in an unexpected file descriptor number.  This fatal error may occur during system initialization.  It is an application configuration error.
fatal-error,Open of the standard error file descriptor failed or resulted in an unexpected file descriptor number.  This fatal error may occur during system initialization.  It is an application configuration error.
fatal-error,"The floating point unit was used illegally, for example in interrupt context on some architectures."
fatal-error,A getentropy() system call failed in one of the ARC4RANDOM(3) functions.  This fatal error can only be fixed with a different implementation of getentropy().
fatal-error,"This fatal error may happen during workspace initialization.  There is not enough memory available to populate the per-CPU data areas, see <rtems/score/percpudata.h>."
fatal-error,"This fatal error may happen during system initialization.  The actual thread-local storage (TLS) size of the application exceeds the configured maximum, see CONFIGURE_MAXIMUM_THREAD_LOCAL_STORAGE_SIZE. You can get the thread-local storage size of an application using the RTEMS tool rtems-execinfo."
fatal-error,The construction of the RTEMS initialization task failed.  This fatal error may occur during system initialization.  It is an application configuration error.
fatal-error,The creation of an IDLE task failed.  This fatal error may occur during system initialization.  It happens if a task create extension fails for an IDLE task.
fatal-error,There was not enough memory available to allocate an IDLE task stack.  This fatal error may occur during system initialization.  It is an application configuration error.
fatal-error,"The task stack size of an IDLE task would have been less than the configured stack size for IDLE tasks, see CONFIGURE_IDLE_TASK_STACK_SIZE. This fatal error may occur during system initialization.  It is an application configuration error."
fatal-error,"This fatal error may be caused by rtems_cache_disable_data() if the data cache cannot be disabled for a particular target or configuration.  The data cache may be necessary to provide atomic operations.  In SMP configurations, the data cache may be required to ensure data coherency.  See the BSP documentation in the RTEMS User Manual for more information."
fatal-error,"© Copyright 1988, 2024 RTEMS Project and contributors."
fatal-error,"This section details the directives of the Fatal Error Manager. A subsection is dedicated to each of this manager’s directives and lists the calling sequence, parameters, description, return values, and notes of the directive."
fatal-error,Invokes the fatal error handler.
fatal-error,CALLING SEQUENCE:
fatal-error,PARAMETERS:
fatal-error,This parameter is the fatal source.
fatal-error,This parameter is the fatal code.
fatal-error,DESCRIPTION:
fatal-error,This directive processes fatal errors.  The fatal source is set to the value of the fatal_source parameter.  The fatal code is set to the value of the fatal_code parameter.
fatal-error,CONSTRAINTS:
fatal-error,The following constraints apply to this directive:
fatal-error,The directive may be called from within any runtime context. The directive will not return to the caller. The directive invokes the fatal error extensions in extension forward order. The directive does not invoke handlers registered by atexit() or on_exit(). The directive may terminate the system.
fatal-error,The directive may be called from within any runtime context.
fatal-error,The directive will not return to the caller.
fatal-error,The directive invokes the fatal error extensions in extension forward order.
fatal-error,The directive does not invoke handlers registered by atexit() or on_exit().
fatal-error,The directive may terminate the system.
fatal-error,Prints the message and invokes the fatal error handler.
fatal-error,CALLING SEQUENCE:
fatal-error,PARAMETERS:
fatal-error,This parameter is the message format.
fatal-error,This parameter is a list of optional parameters required by the message format.
fatal-error,DESCRIPTION:
fatal-error,This directive prints a message via printk() specified by the fmt parameter and optional parameters and then invokes the fatal error handler.  The fatal source is set to RTEMS_FATAL_SOURCE_PANIC.  The fatal code is set to the value of the fmt parameter value.
fatal-error,CONSTRAINTS:
fatal-error,The following constraints apply to this directive:
fatal-error,The directive may be called from within any runtime context. The directive will not return to the caller. The directive invokes the fatal error extensions in extension forward order. The directive does not invoke handlers registered by atexit() or on_exit(). The directive may terminate the system.
fatal-error,The directive may be called from within any runtime context.
fatal-error,The directive will not return to the caller.
fatal-error,The directive invokes the fatal error extensions in extension forward order.
fatal-error,The directive does not invoke handlers registered by atexit() or on_exit().
fatal-error,The directive may terminate the system.
fatal-error,Invokes the fatal error handler.
fatal-error,CALLING SEQUENCE:
fatal-error,PARAMETERS:
fatal-error,This parameter is the fatal code.
fatal-error,DESCRIPTION:
fatal-error,This directive processes fatal errors.  The fatal source is set to RTEMS_FATAL_SOURCE_EXIT.  The fatal code is set to the value of the fatal_code parameter.
fatal-error,CONSTRAINTS:
fatal-error,The following constraints apply to this directive:
fatal-error,The directive may be called from within any runtime context. The directive will not return to the caller. The directive invokes the fatal error extensions in extension forward order. The directive does not invoke handlers registered by atexit() or on_exit(). The directive may terminate the system.
fatal-error,The directive may be called from within any runtime context.
fatal-error,The directive will not return to the caller.
fatal-error,The directive invokes the fatal error extensions in extension forward order.
fatal-error,The directive does not invoke handlers registered by atexit() or on_exit().
fatal-error,The directive may terminate the system.
fatal-error,Prints the exception frame.
fatal-error,CALLING SEQUENCE:
fatal-error,PARAMETERS:
fatal-error,This parameter is the reference to the exception frame to print.
fatal-error,DESCRIPTION:
fatal-error,The exception frame is printed in an architecture-dependent format using printk().
fatal-error,Returns a descriptive text for the fatal source.
fatal-error,CALLING SEQUENCE:
fatal-error,PARAMETERS:
fatal-error,This parameter is the fatal source.
fatal-error,RETURN VALUES:
fatal-error,The fatal_source parameter value was not a fatal source.
fatal-error,Returns a descriptive text for the fatal source.  The text for the fatal source is the enumerator constant name.
fatal-error,CONSTRAINTS:
fatal-error,The following constraints apply to this directive:
fatal-error,The directive may be called from within any runtime context.
fatal-error,The directive may be called from within any runtime context.
fatal-error,Returns a descriptive text for the internal error code.
fatal-error,CALLING SEQUENCE:
fatal-error,PARAMETERS:
fatal-error,This parameter is the internal error code.
fatal-error,RETURN VALUES:
fatal-error,The internal_error_code parameter value was not an internal error code.
fatal-error,Returns a descriptive text for the internal error code.  The text for the internal error code is the enumerator constant name.
fatal-error,CONSTRAINTS:
fatal-error,The following constraints apply to this directive:
fatal-error,The directive may be called from within any runtime context.
fatal-error,The directive may be called from within any runtime context.
fatal-error,Invokes the fatal error handler.
fatal-error,CALLING SEQUENCE:
fatal-error,PARAMETERS:
fatal-error,This parameter is the fatal code.
fatal-error,DESCRIPTION:
fatal-error,This directive processes fatal errors.  The fatal source is set to INTERNAL_ERROR_RTEMS_API.  The fatal code is set to the value of the fatal_code parameter.
fatal-error,NOTES:
fatal-error,This directive is deprecated and should not be used in new code.  It is recommended to not use this directive since error locations cannot be uniquely identified.  A recommended alternative directive is rtems_fatal().
fatal-error,CONSTRAINTS:
fatal-error,The following constraints apply to this directive:
fatal-error,The directive may be called from within any runtime context. The directive will not return to the caller. The directive invokes the fatal error extensions in extension forward order. The directive does not invoke handlers registered by atexit() or on_exit(). The directive may terminate the system.
fatal-error,The directive may be called from within any runtime context.
fatal-error,The directive will not return to the caller.
fatal-error,The directive invokes the fatal error extensions in extension forward order.
fatal-error,The directive does not invoke handlers registered by atexit() or on_exit().
fatal-error,The directive may terminate the system.
fatal-error,"© Copyright 1988, 2024 RTEMS Project and contributors."
fatal-error,The Fatal Error Manager processes all fatal or irrecoverable errors and other sources of system termination (for example after exit()).  Fatal errors are identified by the fatal source and code pair. The directives provided by the Fatal Error Manager are:
fatal-error,rtems_fatal() - Invokes the fatal error handler. rtems_panic() - Prints the message and invokes the fatal error handler. rtems_shutdown_executive() - Invokes the fatal error handler. rtems_exception_frame_print() - Prints the exception frame. rtems_fatal_source_text() - Returns a descriptive text for the fatal source. rtems_internal_error_text() - Returns a descriptive text for the internal error code. rtems_fatal_error_occurred() - Invokes the fatal error handler.
fatal-error,rtems_fatal() - Invokes the fatal error handler.
fatal-error,rtems_panic() - Prints the message and invokes the fatal error handler.
fatal-error,rtems_shutdown_executive() - Invokes the fatal error handler.
fatal-error,rtems_exception_frame_print() - Prints the exception frame.
fatal-error,rtems_fatal_source_text() - Returns a descriptive text for the fatal source.
fatal-error,rtems_internal_error_text() - Returns a descriptive text for the internal error code.
fatal-error,rtems_fatal_error_occurred() - Invokes the fatal error handler.
fatal-error,"© Copyright 1988, 2024 RTEMS Project and contributors."
fatal-error,"A fatal error can be announced by calling for example rtems_fatal(), rtems_shutdown_executive(), rtems_panic(), rtems_fatal_error_occurred(), or exit()."
fatal-error,"© Copyright 1988, 2024 RTEMS Project and contributors."
initialization,"Initialization task(s) are the mechanism by which RTEMS transfers initial control to the user’s application.  Initialization tasks differ from other application tasks in that they are defined in the User Initialization Tasks Table and automatically created and started by RTEMS as part of its initialization sequence.  Since the initialization tasks are scheduled using the same algorithm as all other RTEMS tasks, they must be configured at a priority and mode which will ensure that they will complete execution before other application tasks execute.  Although there is no upper limit on the number of initialization tasks, an application is required to define at least one."
initialization,A typical initialization task will create and start the static set of application tasks.  It may also create any other objects used by the application.  Initialization tasks which only perform initialization should delete themselves upon completion to free resources for other tasks. Initialization tasks may transform themselves into a “normal” application task. This transformation typically involves changing priority and execution mode. RTEMS does not automatically delete the initialization tasks.
initialization,"The Idle Task is the lowest priority task in a system and executes only when no other task is ready to execute.  The default implementation of this task consists of an infinite loop. RTEMS allows the Idle Task body to be replaced by a CPU specific implementation, a BSP specific implementation or an application specific implementation."
initialization,The Idle Task is preemptible and WILL be preempted when any other task is made ready to execute.  This characteristic is critical to the overall behavior of any application.
initialization,System initialization errors are fatal.  See Internal Error Codes.
initialization,"© Copyright 1988, 2024 RTEMS Project and contributors."
initialization,"This section details the directives of the Initialization Manager. A subsection is dedicated to each of this manager’s directives and lists the calling sequence, parameters, description, return values, and notes of the directive."
initialization,Initializes the system and starts multitasking.
initialization,CALLING SEQUENCE:
initialization,DESCRIPTION:
initialization,Iterates through the system initialization linker set and invokes the registered handlers.  The final step is to start multitasking.
initialization,NOTES:
initialization,Errors in the initialization sequence are usually fatal and lead to a system termination.
initialization,CONSTRAINTS:
initialization,The following constraints apply to this directive:
initialization,The directive should be called by boot_card() only. The directive will not return to the caller.
initialization,The directive should be called by boot_card() only.
initialization,The directive will not return to the caller.
initialization,"© Copyright 1988, 2024 RTEMS Project and contributors."
initialization,The Initialization Manager is responsible for initializing the system.
initialization,"The system initialization includes the initialization of the Board Support Package, RTEMS, device drivers, the root filesystem, and the application. The Fatal Error Manager is responsible for the system shutdown. The directives provided by the Initialization Manager are:"
initialization,rtems_initialize_executive() - Initializes the system and starts multitasking.
initialization,rtems_initialize_executive() - Initializes the system and starts multitasking.
initialization,"© Copyright 1988, 2024 RTEMS Project and contributors."
initialization,The Initialization Manager rtems_initialize_executive() directives is called by the boot_card() routine which is invoked by the Board Support Package once a basic C run-time environment is set up.  This consists of
initialization,"a valid and accessible text section, read-only data, read-write data and zero-initialized data, an initialization stack large enough to initialize the rest of the Board Support Package, RTEMS and the device drivers, all registers and components mandated by Application Binary Interface, and disabled interrupts."
initialization,"a valid and accessible text section, read-only data, read-write data and zero-initialized data,"
initialization,"an initialization stack large enough to initialize the rest of the Board Support Package, RTEMS and the device drivers,"
initialization,"all registers and components mandated by Application Binary Interface, and"
initialization,disabled interrupts.
initialization,The rtems_initialize_executive() directive uses a system initialization linker set to initialize only those parts of the overall RTEMS feature set that is necessary for a particular application.  Each RTEMS feature used the application may optionally register an initialization handler.  The system initialization API is available via #included <rtems/sysinit.h>.
initialization,A list of all initialization steps follows.  Some steps are optional depending on the requested feature set of the application.  The initialization steps are execute in the order presented here.
initialization,Initialization of the event recording is the first initialization step. This allows to record the further system initialization.  This step is optional and depends on the CONFIGURE_RECORD_PER_PROCESSOR_ITEMS configuration option.
initialization,The Board Support Package may perform an early platform initialization in this step.  This step is optional.
initialization,The Board Support Package should initialize everything so that calls to _Memory_Get() can be made after this step.  This step is optional.
initialization,The free memory is dirtied in this step.  This step is optional and depends on the BSP_DIRTY_MEMORY BSP option.
initialization,The stack checker initializes the ISR stacks in this step.  This step is optional and depends on the CONFIGURE_STACK_CHECKER_ENABLED configuration option.
initialization,The per-CPU data is initialized in this step.  This step is mandatory.
initialization,The Board Support Package may initialize the sbrk() support in this step.  This step is optional.
initialization,The workspace is initialized in this step.  This step is optional and depends on the application configuration.
initialization,The C program heap is initialized in this step.  This step is optional and depends on the application configuration.
initialization,The Board Support Package should perform a general platform initialization in this step (e.g. interrupt controller initialization).  This step is mandatory.
initialization,Initialization of the CPU counter hardware and support functions.  The CPU counter is initialized early to allow its use in the tracing and profiling of the system initialization sequence.  This step is optional and depends on the application configuration.
initialization,Registers the initial extensions.  This step is optional and depends on the application configuration.
initialization,"In MPCI configurations, an early MPCI initialization is performed in this step.  This step is mandatory in MPCI configurations."
initialization,"This directive is called when the Board Support Package has completed its basic initialization and allows RTEMS to initialize the application environment based upon the information in the Configuration Table, User Initialization Tasks Table, Device Driver Table, User Extension Table, Multiprocessor Configuration Table, and the Multiprocessor Communications Interface (MPCI) Table."
initialization,"In MPCI configurations, a general MPCI initialization is performed in this step.  This step is mandatory in MPCI configurations."
initialization,Initialization of the User Extensions object class.  This step is optional and depends on the application configuration.
initialization,Initialization of the Classic Tasks object class.  This step is optional and depends on the application configuration.
initialization,"In MPCI configurations, the Classic Tasks MPCI support is initialized in this step.  This step is optional and depends on the application configuration."
initialization,Initialization of the Classic Timer object class.  This step is optional and depends on the application configuration.
initialization,Initialization of the Classic Signal support.  This step is optional and depends on the application configuration.
initialization,"In MPCI configurations, the Classic Signal MPCI support is initialized in this step.  This step is optional and depends on the application configuration."
initialization,Initialization of the Classic Event support.  This step is optional and depends on the application configuration.  This step is only used on MPCI configurations.
initialization,"In MPCI configurations, the Classic Event MPCI support is initialized in this step.  This step is optional and depends on the application configuration."
initialization,Initialization of the Classic Message Queue object class.  This step is optional and depends on the application configuration.
initialization,Initialization of the Classic Semaphore object class.  This step is optional and depends on the application configuration.
initialization,"In MPCI configurations, the Classic Semaphore MPCI support is initialized in this step.  This step is optional and depends on the application configuration."
initialization,Initialization of the Classic Partition object class.  This step is optional and depends on the application configuration.
initialization,"In MPCI configurations, the Classic Partition MPCI support is initialized in this step.  This step is optional and depends on the application configuration."
initialization,Initialization of the Classic Region object class.  This step is optional and depends on the application configuration.
initialization,Initialization of the Classic Dual-Ported Memory object class.  This step is optional and depends on the application configuration.
initialization,Initialization of the Classic Rate-Monotonic object class.  This step is optional and depends on the application configuration.
initialization,Initialization of the Classic Barrier object class.  This step is optional and depends on the application configuration.
initialization,Initialization of the POSIX Signals support.  This step is optional and depends on the application configuration.
initialization,Initialization of the POSIX Threads object class.  This step is optional and depends on the application configuration.
initialization,Initialization of the POSIX Message Queue object class.  This step is optional and depends on the application configuration.
initialization,Initialization of the POSIX Semaphore object class.  This step is optional and depends on the application configuration.
initialization,Initialization of the POSIX Timer object class.  This step is optional and depends on the application configuration.
initialization,Initialization of the POSIX Shared Memory object class.  This step is optional and depends on the application configuration.
initialization,Initialization of the POSIX Keys object class.  This step is optional and depends on the application configuration.
initialization,Initialization of the POSIX Cleanup support.  This step is optional and depends on the application configuration.
initialization,Initialization of idle threads.  This step is mandatory.
initialization,Initialization of IO library.  This step is optional and depends on the application configuration.
initialization,Initialization of the root filesystem.  This step is optional and depends on the application configuration.
initialization,Driver manager initialization.  This step is optional and depends on the application configuration.  Only available if the driver manager is enabled.
initialization,"In MPCI configurations, the MPCI server is initialized in this step.  This step is mandatory in MPCI configurations."
initialization,Initialization step performed right before device drivers are initialized. This step is mandatory.
initialization,Driver manager level 1 initialization.  This step is optional and depends on the application configuration.  Only available if the driver manager is enabled.
initialization,"This step initializes all statically configured device drivers and performs all RTEMS initialization which requires device drivers to be initialized. This step is mandatory.  In a multiprocessor configuration, this service will initialize the Multiprocessor Communications Interface (MPCI) and synchronize with the other nodes in the system."
initialization,Driver manager level 2 initialization.  This step is optional and depends on the application configuration.  Only available if the driver manager is enabled.
initialization,Driver manager level 3 initialization.  This step is optional and depends on the application configuration.  Only available if the driver manager is enabled.
initialization,Driver manager level 4 initialization.  This step is optional and depends on the application configuration.  Only available if the driver manager is enabled.
initialization,Finalize MPCI initialization.  This step is mandatory on MPCI configurations.
initialization,Creates and starts the Classic initialization tasks.  This step is optional and depends on the application configuration.
initialization,Creates POSIX initialization threads.  This step is optional and depends on the application configuration.
initialization,"Open the standard input, output and error file descriptors.  This step is optional and depends on the application configuration."
initialization,The final action of the rtems_initialize_executive() directive is to start multitasking and switch to the highest priority ready thread.  RTEMS does not return to the initialization context and the initialization stack may be re-used for interrupt processing.
initialization,"Many of RTEMS actions during initialization are based upon the contents of the Configuration Table.  For more information regarding the format and contents of this table, please refer to the chapter Configuring a System."
initialization,"The global construction is carried out by the Classic API initialization task.  If no Classic API initialization task exists, then it is carried out by the POSIX API initialization thread.  If no initialization task or thread exists, then no global construction is performed.  The Classic API task or POSIX API thread which carries out global construction is called the main thread.  For configuration options related to initialization tasks, see CONFIGURE_RTEMS_INIT_TASKS_TABLE, CONFIGURE_POSIX_INIT_THREAD_TABLE, and CONFIGURE_IDLE_TASK_INITIALIZES_APPLICATION."
initialization,"Global construction runs before the task entry of the main thread.  The configuration of the main thread must take the global construction into account.  In particular, the main thread stack size, priority, attributes and initial modes must be set accordingly.  Thread-local objects and POSIX key values created during global construction are accessible by the main thread. If other initialization tasks are configured, and one of them has a higher priority than the main thread and the main thread is preemptible, this task executes before the global construction.  In case the main thread blocks during global construction, then other tasks may run.  In SMP configurations, other initialization tasks may run in parallel with global construction.  Tasks created during global construction may preempt the main thread or run in parallel in SMP configurations.  All RTEMS services allowed in task context are allowed during global construction."
initialization,"Global constructors are C++ global object constructors or functions with the constructor attribute.  For example, the following test program"
initialization,should output:
initialization,"© Copyright 1988, 2024 RTEMS Project and contributors."
interrupt,"The interrupt manager allows the application to connect a function to a hardware interrupt vector.  When an interrupt occurs, the processor will automatically vector to RTEMS.  RTEMS saves and restores all registers which are not preserved by the normal C calling convention for the target processor and invokes the user’s ISR.  The user’s ISR is responsible for processing the interrupt, clearing the interrupt if necessary, and device specific manipulation."
interrupt,The rtems_interrupt_catch directive connects a procedure to an interrupt vector.  The vector number is managed using the rtems_vector_number data type.
interrupt,The interrupt service routine is assumed to abide by these conventions and have a prototype similar to the following:
interrupt,"The vector number argument is provided by RTEMS to allow the application to identify the interrupt source.  This could be used to allow a single routine to service interrupts from multiple instances of the same device.  For example, a single routine could service interrupts from multiple serial ports and use the vector number to identify which port requires servicing."
interrupt,"To minimize the masking of lower or equal priority level interrupts, the ISR should perform the minimum actions required to service the interrupt.  Other non-essential actions should be handled by application tasks.  Once the user’s ISR has completed, it returns control to the RTEMS interrupt manager which will perform task dispatching and restore the registers saved before the ISR was invoked."
interrupt,"The RTEMS interrupt manager guarantees that proper task scheduling and dispatching are performed at the conclusion of an ISR.  A system call made by the ISR may have readied a task of higher priority than the interrupted task. Therefore, when the ISR completes, the postponed dispatch processing must be performed.  No dispatch processing is performed as part of directives which have been invoked by an ISR."
interrupt,Applications must adhere to the following rule if proper task scheduling and dispatching is to be performed:
interrupt,Note
interrupt,The interrupt manager must be used for all ISRs which may be interrupted by the highest priority ISR which invokes an RTEMS directive.
interrupt,"Consider a processor which allows a numerically low interrupt level to interrupt a numerically greater interrupt level.  In this example, if an RTEMS directive is used in a level 4 ISR, then all ISRs which execute at levels 0 through 4 must use the interrupt manager."
interrupt,Interrupts are nested whenever an interrupt occurs during the execution of another ISR.  RTEMS supports efficient interrupt nesting by allowing the nested ISRs to terminate without performing any dispatch processing.  Only when the outermost ISR terminates will the postponed dispatching occur.
interrupt,"Many processors support multiple interrupt levels or priorities.  The exact number of interrupt levels is processor dependent.  RTEMS internally supports 256 interrupt levels which are mapped to the processor’s interrupt levels.  For specific information on the mapping between RTEMS and the target processor’s interrupt levels, refer to the Interrupt Processing chapter of the Applications Supplement document for a specific target processor."
interrupt,"During the execution of directive calls, critical sections of code may be executed.  When these sections are encountered, RTEMS disables all maskable interrupts before the execution of the section and restores them to the previous level upon completion of the section.  RTEMS has been optimized to ensure that interrupts are disabled for a minimum length of time.  The maximum length of time interrupts are disabled by RTEMS is processor dependent and is detailed in the Timing Specification chapter of the Applications Supplement document for a specific target processor."
interrupt,"Non-maskable interrupts (NMI) cannot be disabled, and ISRs which execute at this level MUST NEVER issue RTEMS system calls.  If a directive is invoked, unpredictable results may occur due to the inability of RTEMS to protect its critical sections.  However, ISRs that make no system calls may safely execute as non-maskable interrupts."
interrupt,"© Copyright 1988, 2024 RTEMS Project and contributors."
interrupt,"This section details the directives of the Interrupt Manager. A subsection is dedicated to each of this manager’s directives and lists the calling sequence, parameters, description, return values, and notes of the directive."
interrupt,Establishes an interrupt service routine.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the new interrupt service routine.
interrupt,This parameter is the interrupt vector number.
interrupt,"This parameter is the pointer to an rtems_isr_entry object. When the directive call is successful, the previous interrupt service routine established for this interrupt vector will be stored in this object."
interrupt,DESCRIPTION:
interrupt,This directive establishes an interrupt service routine (ISR) for the interrupt specified by the vector number.  The new_isr_handler parameter specifies the entry point of the ISR.  The entry point of the previous ISR for the specified vector is returned in old_isr_handler.
interrupt,"To release an interrupt vector, pass the old handler’s address obtained when the vector was first capture."
interrupt,RETURN VALUES:
interrupt,The requested operation was successful.
interrupt,The interrupt vector number was illegal.
interrupt,The new_isr_handler parameter was NULL.
interrupt,The old_isr_handler parameter was NULL.
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive will not cause the calling task to be preempted. The directive is only available where the target architecture support enabled simple vectored interrupts.
interrupt,The directive may be called from within interrupt context.
interrupt,The directive may be called from within device driver initialization context.
interrupt,The directive may be called from within task context.
interrupt,The directive will not cause the calling task to be preempted.
interrupt,The directive is only available where the target architecture support enabled simple vectored interrupts.
interrupt,Disables the maskable interrupts on the current processor.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is a variable of type rtems_interrupt_level which will be used to save the previous interrupt level.
interrupt,DESCRIPTION:
interrupt,This directive disables all maskable interrupts on the current processor and returns the previous interrupt level in isr_cookie.
interrupt,NOTES:
interrupt,A later invocation of the rtems_interrupt_enable() directive should be used to restore the previous interrupt level.
interrupt,This directive is implemented as a macro which sets the isr_cookie parameter.
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,"The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. Where the system was built with SMP support enabled, the directive is not available.  Its use will result in compiler warnings and linker errors.  The rtems_interrupt_local_disable() and rtems_interrupt_local_enable() directives are available in all build configurations."
interrupt,The directive may be called from within any runtime context.
interrupt,The directive will not cause the calling task to be preempted.
interrupt,"Where the system was built with SMP support enabled, the directive is not available.  Its use will result in compiler warnings and linker errors.  The rtems_interrupt_local_disable() and rtems_interrupt_local_enable() directives are available in all build configurations."
interrupt,Restores the previous interrupt level on the current processor.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the previous interrupt level to restore.  The value must be obtained by a previous call to rtems_interrupt_disable() or rtems_interrupt_flash().
interrupt,DESCRIPTION:
interrupt,This directive restores the interrupt level specified by isr_cookie on the current processor.
interrupt,NOTES:
interrupt,The isr_cookie parameter value must be obtained by a previous call to rtems_interrupt_disable() or rtems_interrupt_flash(). Using an otherwise obtained value is undefined behaviour.
interrupt,"This directive is unsuitable to enable particular interrupt sources, for example in an interrupt controller."
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,"The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. While at least one maskable interrupt is pending, when the directive enables maskable interrupts, the pending interrupts are immediately serviced.  The interrupt service routines may unblock higher priority tasks which may preempt the calling task. Where the system was built with SMP support enabled, the directive is not available.  Its use will result in compiler warnings and linker errors.  The rtems_interrupt_local_disable() and rtems_interrupt_local_enable() directives are available in all build configurations."
interrupt,The directive may be called from within any runtime context.
interrupt,The directive will not cause the calling task to be preempted.
interrupt,"While at least one maskable interrupt is pending, when the directive enables maskable interrupts, the pending interrupts are immediately serviced.  The interrupt service routines may unblock higher priority tasks which may preempt the calling task."
interrupt,"Where the system was built with SMP support enabled, the directive is not available.  Its use will result in compiler warnings and linker errors.  The rtems_interrupt_local_disable() and rtems_interrupt_local_enable() directives are available in all build configurations."
interrupt,Flashes interrupts on the current processor.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the previous interrupt level.
interrupt,DESCRIPTION:
interrupt,This directive is functionally equivalent to a calling rtems_interrupt_enable() immediately followed by a rtems_interrupt_disable().  On some architectures it is possible to provide an optimized implementation for this sequence.
interrupt,NOTES:
interrupt,The isr_cookie parameter value must be obtained by a previous call to rtems_interrupt_disable() or rtems_interrupt_flash(). Using an otherwise obtained value is undefined behaviour.
interrupt,"Historically, the interrupt flash directive was heavily used in the operating system implementation.  However, this is no longer the case.  The interrupt flash directive is provided for backward compatibility reasons."
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,"The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. Where the system was built with SMP support enabled, the directive is not available.  Its use will result in compiler warnings and linker errors.  The rtems_interrupt_local_disable() and rtems_interrupt_local_enable() directives are available in all build configurations."
interrupt,The directive may be called from within any runtime context.
interrupt,The directive will not cause the calling task to be preempted.
interrupt,"Where the system was built with SMP support enabled, the directive is not available.  Its use will result in compiler warnings and linker errors.  The rtems_interrupt_local_disable() and rtems_interrupt_local_enable() directives are available in all build configurations."
interrupt,Disables the maskable interrupts on the current processor.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is a variable of type rtems_interrupt_level which will be used to save the previous interrupt level.
interrupt,DESCRIPTION:
interrupt,This directive disables all maskable interrupts on the current processor and returns the previous interrupt level in isr_cookie.
interrupt,NOTES:
interrupt,A later invocation of the rtems_interrupt_local_enable() directive should be used to restore the previous interrupt level.
interrupt,This directive is implemented as a macro which sets the isr_cookie parameter.
interrupt,"Where the system was built with SMP support enabled, this will not ensure system wide mutual exclusion.  Use interrupt locks instead, see rtems_interrupt_lock_acquire().  Interrupt disabled critical sections may be used to access processor-specific data structures or disable thread dispatching."
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
interrupt,The directive may be called from within any runtime context.
interrupt,The directive will not cause the calling task to be preempted.
interrupt,Restores the previous interrupt level on the current processor.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the previous interrupt level to restore.  The value must be obtained by a previous call to rtems_interrupt_local_disable().
interrupt,DESCRIPTION:
interrupt,This directive restores the interrupt level specified by isr_cookie on the current processor.
interrupt,NOTES:
interrupt,The isr_cookie parameter value must be obtained by a previous call to rtems_interrupt_local_disable().  Using an otherwise obtained value is undefined behaviour.
interrupt,"This directive is unsuitable to enable particular interrupt sources, for example in an interrupt controller."
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,"The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. While at least one maskable interrupt is pending, when the directive enables maskable interrupts, the pending interrupts are immediately serviced.  The interrupt service routines may unblock higher priority tasks which may preempt the calling task."
interrupt,The directive may be called from within any runtime context.
interrupt,The directive will not cause the calling task to be preempted.
interrupt,"While at least one maskable interrupt is pending, when the directive enables maskable interrupts, the pending interrupts are immediately serviced.  The interrupt service routines may unblock higher priority tasks which may preempt the calling task."
interrupt,Checks if an ISR is in progress on the current processor.
interrupt,CALLING SEQUENCE:
interrupt,DESCRIPTION:
interrupt,"This directive returns true, if the current processor is currently servicing an interrupt, and false otherwise.  A return value of true indicates that the caller is an interrupt service routine, not a task. The directives available to an interrupt service routine are restricted."
interrupt,RETURN VALUES:
interrupt,"Returns true, if the current processor is currently servicing an interrupt, otherwise false."
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
interrupt,The directive may be called from within any runtime context.
interrupt,The directive will not cause the calling task to be preempted.
interrupt,Initializes the ISR lock.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the ISR lock to initialize.
interrupt,This parameter is the ISR lock name.  It shall be a string.  The name is only used where the system was built with profiling support enabled.
interrupt,NOTES:
interrupt,ISR locks may also be statically defined by RTEMS_INTERRUPT_LOCK_DEFINE() or statically initialized by RTEMS_INTERRUPT_LOCK_INITIALIZER().
interrupt,Destroys the ISR lock.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the ISR lock to destroy.
interrupt,NOTES:
interrupt,"The lock must have been dynamically initialized by rtems_interrupt_lock_initialize(), statically defined by RTEMS_INTERRUPT_LOCK_DEFINE(), or statically initialized by RTEMS_INTERRUPT_LOCK_INITIALIZER()."
interrupt,Concurrent lock use during the destruction or concurrent destruction leads to unpredictable results.
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
interrupt,The directive may be called from within any runtime context.
interrupt,The directive will not cause the calling task to be preempted.
interrupt,Acquires the ISR lock.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the ISR lock to acquire.
interrupt,This parameter is the ISR lock context.  This lock context shall be used to release the lock by calling rtems_interrupt_lock_release().
interrupt,DESCRIPTION:
interrupt,This directive acquires the ISR lock specified by lock using the lock context provided by lock_context.  Maskable interrupts will be disabled on the current processor.
interrupt,NOTES:
interrupt,"A caller-specific lock context shall be provided for each acquire/release pair, for example an automatic variable."
interrupt,"Where the system was built with SMP support enabled, this directive acquires an SMP lock.  An attempt to recursively acquire the lock may result in an infinite loop with maskable interrupts disabled."
interrupt,This directive establishes a non-preemptive critical section with system wide mutual exclusion on the local node in all RTEMS build configurations.
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
interrupt,The directive may be called from within any runtime context.
interrupt,The directive will not cause the calling task to be preempted.
interrupt,Releases the ISR lock.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the ISR lock to release.
interrupt,This parameter is the ISR lock context.  This lock context shall have been used to acquire the lock by calling rtems_interrupt_lock_acquire().
interrupt,DESCRIPTION:
interrupt,This directive releases the ISR lock specified by lock using the lock context provided by lock_context.  The previous interrupt level will be restored on the current processor.
interrupt,NOTES:
interrupt,"The lock context shall be the one used to acquire the lock, otherwise the result is unpredictable."
interrupt,"Where the system was built with SMP support enabled, this directive releases an SMP lock."
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,"The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. While at least one maskable interrupt is pending, when the directive enables maskable interrupts, the pending interrupts are immediately serviced.  The interrupt service routines may unblock higher priority tasks which may preempt the calling task."
interrupt,The directive may be called from within any runtime context.
interrupt,The directive will not cause the calling task to be preempted.
interrupt,"While at least one maskable interrupt is pending, when the directive enables maskable interrupts, the pending interrupts are immediately serviced.  The interrupt service routines may unblock higher priority tasks which may preempt the calling task."
interrupt,Acquires the ISR lock from within an ISR.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the ISR lock to acquire within an ISR.
interrupt,This parameter is the ISR lock context.  This lock context shall be used to release the lock by calling rtems_interrupt_lock_release_isr().
interrupt,DESCRIPTION:
interrupt,This directive acquires the ISR lock specified by lock using the lock context provided by lock_context.  The interrupt level will remain unchanged.
interrupt,NOTES:
interrupt,"A caller-specific lock context shall be provided for each acquire/release pair, for example an automatic variable."
interrupt,"Where the system was built with SMP support enabled, this directive acquires an SMP lock.  An attempt to recursively acquire the lock may result in an infinite loop."
interrupt,This directive is intended for device drivers and should be called from the corresponding interrupt service routine.
interrupt,"In case the corresponding interrupt service routine can be interrupted by higher priority interrupts and these interrupts enter the critical section protected by this lock, then the result is unpredictable.  This directive may be used under specific circumstances as an optimization.  In doubt, use rtems_interrupt_lock_acquire() and rtems_interrupt_lock_release()."
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
interrupt,The directive may be called from within any runtime context.
interrupt,The directive will not cause the calling task to be preempted.
interrupt,Releases the ISR lock from within an ISR.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the ISR lock to release within an ISR.
interrupt,This parameter is the ISR lock context.  This lock context shall have been used to acquire the lock by calling rtems_interrupt_lock_acquire_isr().
interrupt,DESCRIPTION:
interrupt,This directive releases the ISR lock specified by lock using the lock context provided by lock_context.  The interrupt level will remain unchanged.
interrupt,NOTES:
interrupt,"The lock context shall be the one used to acquire the lock, otherwise the result is unpredictable."
interrupt,"Where the system was built with SMP support enabled, this directive releases an SMP lock."
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
interrupt,The directive may be called from within any runtime context.
interrupt,The directive will not cause the calling task to be preempted.
interrupt,Disables maskable interrupts on the current processor.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the ISR lock context for an acquire and release pair.
interrupt,DESCRIPTION:
interrupt,This directive disables maskable interrupts on the current processor and stores the previous interrupt level in lock_context.
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
interrupt,The directive may be called from within any runtime context.
interrupt,The directive will not cause the calling task to be preempted.
interrupt,Declares an ISR lock object.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,"This parameter is the storage-class specifier for the ISR lock to declare, for example extern or static."
interrupt,This parameter is the ISR lock object designator.
interrupt,NOTES:
interrupt,Do not add a “;” after this macro.
interrupt,Defines an ISR lock object.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,"This parameter is the storage-class specifier for the ISR lock to declare, for example extern or static."
interrupt,This parameter is the ISR lock object designator.
interrupt,This parameter is the ISR lock name.  It shall be a string.  The name is only used where the system was built with profiling support enabled.
interrupt,NOTES:
interrupt,Do not add a “;” after this macro.
interrupt,ISR locks may also be dynamically initialized by rtems_interrupt_lock_initialize() or statically by RTEMS_INTERRUPT_LOCK_INITIALIZER().
interrupt,Statically initializes an ISR lock object.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the ISR lock name.  It shall be a string.  The name is only used where the system was built with profiling support enabled.
interrupt,NOTES:
interrupt,ISR locks may also be dynamically initialized by rtems_interrupt_lock_initialize() or statically defined by RTEMS_INTERRUPT_LOCK_DEFINE().
interrupt,Defines an ISR lock member.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the ISR lock member designator.
interrupt,NOTES:
interrupt,Do not add a “;” after this macro.
interrupt,Defines an ISR lock object reference.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the ISR lock reference designator.
interrupt,This parameter is the target object to reference.
interrupt,NOTES:
interrupt,Do not add a “;” after this macro.
interrupt,Statically initializes an interrupt entry object.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the interrupt handler routine for the entry.
interrupt,This parameter is the interrupt handler argument for the entry.
interrupt,This parameter is the descriptive information for the entry.
interrupt,NOTES:
interrupt,"Alternatively, rtems_interrupt_entry_initialize() may be used to dynamically initialize an interrupt entry."
interrupt,Initializes the interrupt entry.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the interrupt entry to initialize.
interrupt,This parameter is the interrupt handler routine for the entry.
interrupt,This parameter is the interrupt handler argument for the entry.
interrupt,This parameter is the descriptive information for the entry.
interrupt,NOTES:
interrupt,"Alternatively, RTEMS_INTERRUPT_ENTRY_INITIALIZER() may be used to statically initialize an interrupt entry."
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
interrupt,The directive may be called from within any runtime context.
interrupt,The directive will not cause the calling task to be preempted.
interrupt,Installs the interrupt entry at the interrupt vector.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the interrupt vector number.
interrupt,This parameter is the interrupt entry install option set.
interrupt,This parameter is the interrupt entry to install.
interrupt,DESCRIPTION:
interrupt,One of the following mutually exclusive options
interrupt,"RTEMS_INTERRUPT_UNIQUE, and RTEMS_INTERRUPT_SHARED"
interrupt,"RTEMS_INTERRUPT_UNIQUE, and"
interrupt,RTEMS_INTERRUPT_SHARED
interrupt,shall be set in the options parameter.
interrupt,The handler routine of the entry specified by entry will be called with the handler argument of the entry when dispatched.  The order in which shared interrupt handlers are dispatched for one vector is defined by the installation order.  The first installed handler is dispatched first.
interrupt,"If the option RTEMS_INTERRUPT_UNIQUE is set, then it will be ensured that the handler will be the only one for the interrupt vector."
interrupt,"If the option RTEMS_INTERRUPT_SHARED is set, then multiple handlers may be installed for the interrupt vector."
interrupt,RETURN VALUES:
interrupt,The requested operation was successful.
interrupt,The entry parameter was NULL.
interrupt,The service was not initialized.
interrupt,The handler routine of the entry was NULL.
interrupt,There was no interrupt vector associated with the number specified by vector.
interrupt,The directive was called from within interrupt context.
interrupt,An option specified by options was not applicable.
interrupt,The RTEMS_INTERRUPT_UNIQUE option was set in entry and the interrupt vector was already occupied by a handler.
interrupt,The RTEMS_INTERRUPT_SHARED option was set in entry and the interrupt vector was already occupied by a unique handler.
interrupt,The handler routine of the entry specified by entry was already installed for the interrupt vector specified by vector with an argument equal to the handler argument of the entry.
interrupt,NOTES:
interrupt,"When the directive call was successful, the ownership of the interrupt entry has been transferred from the caller to the interrupt service.  An installed interrupt entry may be removed from the interrupt service by calling rtems_interrupt_entry_remove()."
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted. The interrupt entry shall have been initialized by rtems_interrupt_entry_initialize() or RTEMS_INTERRUPT_ENTRY_INITIALIZER().
interrupt,The directive may be called from within device driver initialization context.
interrupt,The directive may be called from within task context.
interrupt,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
interrupt,The interrupt entry shall have been initialized by rtems_interrupt_entry_initialize() or RTEMS_INTERRUPT_ENTRY_INITIALIZER().
interrupt,Removes the interrupt entry from the interrupt vector.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the interrupt vector number.
interrupt,This parameter is the interrupt entry to remove.
interrupt,RETURN VALUES:
interrupt,The requested operation was successful.
interrupt,The service was not initialized.
interrupt,The entry parameter was NULL.
interrupt,There was no interrupt vector associated with the number specified by vector.
interrupt,The directive was called from within interrupt context.
interrupt,The entry specified by entry was not installed at the interrupt vector specified by vector.
interrupt,NOTES:
interrupt,"When the directive call was successful, the ownership of the interrupt entry has been transferred from the interrupt service to the caller."
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted. The interrupt entry shall have been installed by rtems_interrupt_entry_install().
interrupt,The directive may be called from within device driver initialization context.
interrupt,The directive may be called from within task context.
interrupt,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
interrupt,The interrupt entry shall have been installed by rtems_interrupt_entry_install().
interrupt,Installs the interrupt handler routine and argument at the interrupt vector.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the interrupt vector number.
interrupt,This parameter is the descriptive information of the interrupt handler to install.
interrupt,This parameter is the interrupt handler install option set.
interrupt,This parameter is the interrupt handler routine to install.
interrupt,This parameter is the interrupt handler argument to install.
interrupt,DESCRIPTION:
interrupt,One of the following mutually exclusive options
interrupt,"RTEMS_INTERRUPT_UNIQUE, RTEMS_INTERRUPT_SHARED, and RTEMS_INTERRUPT_REPLACE"
interrupt,"RTEMS_INTERRUPT_UNIQUE,"
interrupt,"RTEMS_INTERRUPT_SHARED, and"
interrupt,RTEMS_INTERRUPT_REPLACE
interrupt,shall be set in the options parameter.
interrupt,The handler routine will be called with the argument specified by arg when dispatched.  The order in which shared interrupt handlers are dispatched for one vector is defined by the installation order.  The first installed handler is dispatched first.
interrupt,"If the option RTEMS_INTERRUPT_UNIQUE is set, then it will be ensured that the handler will be the only one for the interrupt vector."
interrupt,"If the option RTEMS_INTERRUPT_SHARED is set, then multiple handler may be installed for the interrupt vector."
interrupt,"If the option RTEMS_INTERRUPT_REPLACE is set, then the handler specified by routine will replace the first handler with the same argument for the interrupt vector if it exists, otherwise an error status will be returned.  A second handler with the same argument for the interrupt vector will remain unchanged.  The new handler will inherit the unique or shared options from the replaced handler."
interrupt,An informative description may be provided in info.  It may be used for system debugging and diagnostic tools.  The referenced string has to be persistent as long as the handler is installed.
interrupt,RETURN VALUES:
interrupt,The requested operation was successful.
interrupt,The service was not initialized.
interrupt,The routine parameter was NULL.
interrupt,There was no interrupt vector associated with the number specified by vector.
interrupt,The directive was called from within interrupt context.
interrupt,There was not enough memory available to allocate data structures to install the handler.
interrupt,The RTEMS_INTERRUPT_UNIQUE option was set in options and the interrupt vector was already occupied by a handler.
interrupt,The RTEMS_INTERRUPT_SHARED option was set in options and the interrupt vector was already occupied by a unique handler.
interrupt,The handler specified by routine was already installed for the interrupt vector specified by vector with an argument equal to the argument specified by arg.
interrupt,The RTEMS_INTERRUPT_REPLACE option was set in options and no handler to replace was installed.
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
interrupt,The directive may be called from within device driver initialization context.
interrupt,The directive may be called from within task context.
interrupt,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
interrupt,Removes the interrupt handler routine and argument from the interrupt vector.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the interrupt vector number.
interrupt,This parameter is the interrupt handler routine to remove.
interrupt,This parameter is the interrupt handler argument to remove.
interrupt,RETURN VALUES:
interrupt,The requested operation was successful.
interrupt,The service was not initialized.
interrupt,The routine parameter was NULL.
interrupt,There was no interrupt vector associated with the number specified by vector.
interrupt,The directive was called from within interrupt context.
interrupt,There was no handler routine and argument pair installed specified by routine and arg.
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
interrupt,The directive may be called from within device driver initialization context.
interrupt,The directive may be called from within task context.
interrupt,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
interrupt,Checks if the interrupt vector is enabled.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the interrupt vector number.
interrupt,"This parameter is the pointer to a bool object.  When the directive call is successful, the enabled status of the interrupt associated with the interrupt vector specified by vector will be stored in this object. When the interrupt was enabled for the processor executing the directive call at some time point during the call, the object value will be set to true, otherwise to false."
interrupt,DESCRIPTION:
interrupt,The directive checks if the interrupt associated with the interrupt vector specified by vector was enabled for the processor executing the directive call at some time point during the call.
interrupt,RETURN VALUES:
interrupt,The requested operation was successful.
interrupt,The enabled parameter was NULL.
interrupt,There was no interrupt vector associated with the number specified by vector.
interrupt,NOTES:
interrupt,Interrupt vectors may be enabled by rtems_interrupt_vector_enable() and disabled by rtems_interrupt_vector_disable().
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive will not cause the calling task to be preempted.
interrupt,The directive may be called from within interrupt context.
interrupt,The directive may be called from within device driver initialization context.
interrupt,The directive may be called from within task context.
interrupt,The directive will not cause the calling task to be preempted.
interrupt,Enables the interrupt vector.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the number of the interrupt vector to enable.
interrupt,DESCRIPTION:
interrupt,"The directive enables the interrupt vector specified by vector. This allows that interrupt service requests are issued to the target processors of the interrupt vector.  Interrupt service requests for an interrupt vector may be raised by rtems_interrupt_raise(), rtems_interrupt_raise_on(), external signals, or messages."
interrupt,RETURN VALUES:
interrupt,The requested operation was successful.
interrupt,There was no interrupt vector associated with the number specified by vector.
interrupt,The request to enable the interrupt vector has not been satisfied.
interrupt,NOTES:
interrupt,The rtems_interrupt_get_attributes() directive may be used to check if an interrupt vector can be enabled.  Interrupt vectors may be disabled by rtems_interrupt_vector_disable().
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive will not cause the calling task to be preempted.
interrupt,The directive may be called from within interrupt context.
interrupt,The directive may be called from within device driver initialization context.
interrupt,The directive may be called from within task context.
interrupt,The directive will not cause the calling task to be preempted.
interrupt,Disables the interrupt vector.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the number of the interrupt vector to disable.
interrupt,DESCRIPTION:
interrupt,The directive disables the interrupt vector specified by vector.  This prevents that an interrupt service request is issued to the target processors of the interrupt vector.
interrupt,RETURN VALUES:
interrupt,The requested operation was successful.
interrupt,There was no interrupt vector associated with the number specified by vector.
interrupt,The request to disable the interrupt vector has not been satisfied.
interrupt,NOTES:
interrupt,"The rtems_interrupt_get_attributes() directive may be used to check if an interrupt vector can be disabled.  Interrupt vectors may be enabled by rtems_interrupt_vector_enable().  There may be targets on which some interrupt vectors cannot be disabled, for example a hardware watchdog interrupt or software generated interrupts."
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive will not cause the calling task to be preempted.
interrupt,The directive may be called from within interrupt context.
interrupt,The directive may be called from within device driver initialization context.
interrupt,The directive may be called from within task context.
interrupt,The directive will not cause the calling task to be preempted.
interrupt,Checks if the interrupt is pending.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the interrupt vector number.
interrupt,"This parameter is the pointer to a bool object.  When the directive call is successful, the pending status of the interrupt associated with the interrupt vector specified by vector will be stored in this object. When the interrupt was pending for the processor executing the directive call at some time point during the call, the object value will be set to true, otherwise to false."
interrupt,DESCRIPTION:
interrupt,The directive checks if the interrupt associated with the interrupt vector specified by vector was pending for the processor executing the directive call at some time point during the call.
interrupt,RETURN VALUES:
interrupt,The requested operation was successful.
interrupt,The pending parameter was NULL.
interrupt,There was no interrupt vector associated with the number specified by vector.
interrupt,The request to get the pending status has not been satisfied.
interrupt,NOTES:
interrupt,Interrupts may be made pending by calling the rtems_interrupt_raise() or rtems_interrupt_raise_on() directives or due to external signals or messages.  The pending state may be cleared by rtems_interrupt_clear().
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive will not cause the calling task to be preempted.
interrupt,The directive may be called from within interrupt context.
interrupt,The directive may be called from within device driver initialization context.
interrupt,The directive may be called from within task context.
interrupt,The directive will not cause the calling task to be preempted.
interrupt,Raises the interrupt vector.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the number of the interrupt vector to raise.
interrupt,RETURN VALUES:
interrupt,The requested operation was successful.
interrupt,There was no interrupt vector associated with the number specified by vector.
interrupt,The request to raise the interrupt vector has not been satisfied.
interrupt,NOTES:
interrupt,The rtems_interrupt_get_attributes() directive may be used to check if an interrupt vector can be raised.
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive will not cause the calling task to be preempted.
interrupt,The directive may be called from within interrupt context.
interrupt,The directive may be called from within device driver initialization context.
interrupt,The directive may be called from within task context.
interrupt,The directive will not cause the calling task to be preempted.
interrupt,Raises the interrupt vector on the processor.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the number of the interrupt vector to raise.
interrupt,This parameter is the index of the target processor of the interrupt vector to raise.
interrupt,RETURN VALUES:
interrupt,The requested operation was successful.
interrupt,There was no interrupt vector associated with the number specified by vector.
interrupt,The processor specified by cpu_index was not configured to be used by the application.
interrupt,"The processor specified by cpu_index was configured to be used by the application, however, it was not online."
interrupt,The request to raise the interrupt vector has not been satisfied.
interrupt,NOTES:
interrupt,The rtems_interrupt_get_attributes() directive may be used to check if an interrupt vector can be raised on a processor.
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive will not cause the calling task to be preempted.
interrupt,The directive may be called from within interrupt context.
interrupt,The directive may be called from within device driver initialization context.
interrupt,The directive may be called from within task context.
interrupt,The directive will not cause the calling task to be preempted.
interrupt,Clears the interrupt vector.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the number of the interrupt vector to clear.
interrupt,RETURN VALUES:
interrupt,The requested operation was successful.
interrupt,There was no interrupt vector associated with the number specified by vector.
interrupt,The request to raise the interrupt vector has not been satisfied.
interrupt,NOTES:
interrupt,The rtems_interrupt_get_attributes() directive may be used to check if an interrupt vector can be cleared.
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive will not cause the calling task to be preempted.
interrupt,The directive may be called from within interrupt context.
interrupt,The directive may be called from within device driver initialization context.
interrupt,The directive may be called from within task context.
interrupt,The directive will not cause the calling task to be preempted.
interrupt,Gets the priority of the interrupt vector.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the interrupt vector number.
interrupt,"This parameter is the pointer to an uint32_t object.  When the directive call is successful, the priority of the interrupt vector will be stored in this object."
interrupt,RETURN VALUES:
interrupt,The requested operation was successful.
interrupt,The priority parameter was NULL.
interrupt,There was no interrupt vector associated with the number specified by vector.
interrupt,There is no priority associated with the interrupt vector.
interrupt,NOTES:
interrupt,The rtems_interrupt_set_priority() directive may be used to set the priority associated with an interrupt vector.
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive will not cause the calling task to be preempted.
interrupt,The directive may be called from within interrupt context.
interrupt,The directive may be called from within device driver initialization context.
interrupt,The directive may be called from within task context.
interrupt,The directive will not cause the calling task to be preempted.
interrupt,Sets the priority of the interrupt vector.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the interrupt vector number.
interrupt,This parameter is the new priority for the interrupt vector.
interrupt,DESCRIPTION:
interrupt,This directive sets the priority of the interrupt specified by vector to the priority specified by priority.
interrupt,"For processor-specific interrupts, the priority of the interrupt specific to a processor executing the directive call will be set."
interrupt,RETURN VALUES:
interrupt,The requested operation was successful.
interrupt,There was no interrupt vector associated with the number specified by vector.
interrupt,The priority specified by priority was not a valid new priority for the interrupt vector.
interrupt,The request to set the priority of the interrupt vector has not been satisfied.
interrupt,NOTES:
interrupt,The rtems_interrupt_get_priority() directive may be used to get the priority associated with an interrupt vector.
interrupt,"The interrupt prioritization support depends on the interrupt controller of the target.  It is strongly recommended to read the relevant hardware documentation.  What happens when the priority of a pending or active interrupt is changed, depends on the interrupt controller.  In general, you should set the interrupt priority of an interrupt vector before a handler is installed. On some interrupt controllers, setting the priority to the maximum value (lowest importance) effectively disables the interrupt."
interrupt,"On some architectures, a range of interrupt priority values may be not disabled by the interrupt disable directives such as rtems_interrupt_disable() and rtems_interrupt_local_disable().  These interrupts are called non-maskable interrupts. Handlers of non-maskable interrupts shall not use operating system services. In addition, non-maskable interrupts may be not installable through rtems_interrupt_entry_install() or rtems_interrupt_handler_install(), and may require architecture-specific prologue and epilogue code."
interrupt,"The interrupt priority settings affect the maximum nesting depth while servicing interrupts.  The interrupt stack size calculation needs to take this into account, see also CONFIGURE_INTERRUPT_STACK_SIZE."
interrupt,"For the ARM Generic Interrupt Controller (GIC), an 8-bit priority value is supported.  The granularity of the priority levels depends on the interrupt controller configuration.  Some low-order bits of a priority value may be read-as-zero (RAZ) and writes are ignored (WI).  Where group 0 (FIQ) and group 1 (IRQ) interrupts are used, it is recommended to use the lower half of the supported priority value range for the group 0 interrupts and the upper half for group 1 interrupts.  This ensures that group 1 interrupts cannot preempt group 0 interrupts."
interrupt,"For the Armv7-M Nested Vector Interrupt Controller (NVIC), an 8-bit priority value is supported.  The granularity of the priority levels depends on the interrupt controller configuration.  Some lower bits of a priority value may be read-as-zero (RAZ) and writes are ignored (WI).  Interrupts with a priority value less than 128 are not disabled by the RTEMS interrupt disable directives. Handlers of such interrupts shall not use operating system services."
interrupt,"For the RISC-V Platform-Level Interrupt Controller (PLIC), all priority values from 0 up to and including the 0xffffffff are supported since the priority for the PLIC is defined by a write-any-read-legal (WARL) register. Please note that for this directive in contrast to the PLIC, a higher priority value is associated with a lower importance.  The maximum priority value (mapped to the value 0 for the PLIC) is reserved to mean “never interrupt” and effectively disables the interrupt."
interrupt,"For the QorIQ Multicore Programmable Interrupt Controller (MPIC), a 4-bit priority value is supported.  Please note that for this directive in contrast to the MPIC, a higher priority value is associated with a lower importance. The maximum priority value of 15 (mapped to the value 0 for the MPIC) inhibits signalling of this interrupt."
interrupt,Consult the RTEMS CPU Architecture Supplement and the BSP documentation in the RTEMS User Manual for further information.
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive will not cause the calling task to be preempted.
interrupt,The directive may be called from within interrupt context.
interrupt,The directive may be called from within device driver initialization context.
interrupt,The directive may be called from within task context.
interrupt,The directive will not cause the calling task to be preempted.
interrupt,Gets the processor affinity set of the interrupt vector.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the interrupt vector number.
interrupt,This parameter is the size of the processor set referenced by affinity in bytes.
interrupt,"This parameter is the pointer to a cpu_set_t object.  When the directive call is successful, the processor affinity set of the interrupt vector will be stored in this object.  A set bit in the processor set means that the corresponding processor is in the processor affinity set of the interrupt vector, otherwise the bit is cleared."
interrupt,RETURN VALUES:
interrupt,The requested operation was successful.
interrupt,The affinity parameter was NULL.
interrupt,There was no interrupt vector associated with the number specified by vector.
interrupt,The size specified by affinity_size of the processor set was too small for the processor affinity set of the interrupt vector.
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive will not cause the calling task to be preempted.
interrupt,The directive may be called from within interrupt context.
interrupt,The directive may be called from within device driver initialization context.
interrupt,The directive may be called from within task context.
interrupt,The directive will not cause the calling task to be preempted.
interrupt,Sets the processor affinity set of the interrupt vector.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the interrupt vector number.
interrupt,This parameter is the size of the processor set referenced by affinity in bytes.
interrupt,"This parameter is the pointer to a cpu_set_t object.  The processor set defines the new processor affinity set of the interrupt vector.  A set bit in the processor set means that the corresponding processor shall be in the processor affinity set of the interrupt vector, otherwise the bit shall be cleared."
interrupt,RETURN VALUES:
interrupt,The requested operation was successful.
interrupt,The affinity parameter was NULL.
interrupt,There was no interrupt vector associated with the number specified by vector.
interrupt,The referenced processor set was not a valid new processor affinity set for the interrupt vector.
interrupt,The request to set the processor affinity of the interrupt vector has not been satisfied.
interrupt,NOTES:
interrupt,The rtems_interrupt_get_attributes() directive may be used to check if the processor affinity of an interrupt vector can be set.
interrupt,"Only online processors of the affinity set specified by affinity_size and affinity are considered by the directive.  Other processors of the set are ignored.  If the set contains no online processor, then the set is invalid and an error status is returned."
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive will not cause the calling task to be preempted.
interrupt,The directive may be called from within interrupt context.
interrupt,The directive may be called from within device driver initialization context.
interrupt,The directive may be called from within task context.
interrupt,The directive will not cause the calling task to be preempted.
interrupt,Gets the attributes of the interrupt vector.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the interrupt vector number.
interrupt,"This parameter is the pointer to an rtems_interrupt_attributes object.  When the directive call is successful, the attributes of the interrupt vector will be stored in this object."
interrupt,RETURN VALUES:
interrupt,The requested operation was successful.
interrupt,The attributes parameter was NULL.
interrupt,There was no interrupt vector associated with the number specified by vector.
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive will not cause the calling task to be preempted.
interrupt,The directive may be called from within interrupt context.
interrupt,The directive may be called from within device driver initialization context.
interrupt,The directive may be called from within task context.
interrupt,The directive will not cause the calling task to be preempted.
interrupt,Iterates over all interrupt handler installed at the interrupt vector.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the interrupt vector number.
interrupt,This parameter is the visitor routine.
interrupt,This parameter is the visitor argument.
interrupt,DESCRIPTION:
interrupt,"For each installed handler at the interrupt vector the visitor function specified by routine will be called with the argument specified by arg and the handler information, options, routine and argument."
interrupt,RETURN VALUES:
interrupt,The requested operation was successful.
interrupt,The service was not initialized.
interrupt,The routine parameter was NULL.
interrupt,There was no interrupt vector associated with the number specified by vector.
interrupt,The directive was called from within interrupt context.
interrupt,NOTES:
interrupt,The directive is intended for system information and diagnostics.
interrupt,Never install or remove an interrupt handler within the visitor function. This may result in a deadlock.
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
interrupt,The directive may be called from within device driver initialization context.
interrupt,The directive may be called from within task context.
interrupt,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
interrupt,Initializes the interrupt server tasks.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the initial task priority of the created interrupt servers.
interrupt,This parameter is the task stack size of the created interrupt servers.
interrupt,This parameter is the initial mode set of the created interrupt servers.
interrupt,This parameter is the attribute set of the created interrupt servers.
interrupt,"This parameter is the pointer to an uint32_t object or NULL. When the pointer is not equal to NULL, the count of successfully created interrupt servers is stored in this object regardless of the return status."
interrupt,DESCRIPTION:
interrupt,"The directive tries to create an interrupt server task for each online processor in the system.  The tasks will have the initial priority specified by priority, the stack size specified by stack_size, the initial mode set specified by modes, and the attribute set specified by attributes.  The count of successfully created server tasks will be returned in server_count if the pointer is not equal to NULL."
interrupt,RETURN VALUES:
interrupt,The requested operation was successful.
interrupt,The interrupt servers were already initialized.
interrupt,"The directive uses rtems_task_create().  If this directive fails, then its error status will be returned."
interrupt,NOTES:
interrupt,"Interrupt handlers may be installed on an interrupt server with rtems_interrupt_server_handler_install() and removed with rtems_interrupt_server_handler_remove() using a server index.  In case of an interrupt, the request will be forwarded to the interrupt server. The handlers are executed within the interrupt server context.  If one handler blocks on something this may delay the processing of other handlers."
interrupt,Interrupt servers may be deleted by rtems_interrupt_server_delete().
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
interrupt,The directive may be called from within device driver initialization context.
interrupt,The directive may be called from within task context.
interrupt,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
interrupt,Creates an interrupt server.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,"This parameter is the pointer to an rtems_interrupt_server_control object.  When the directive call was successful, the ownership of the object was transferred from the caller of the directive to the interrupt server management."
interrupt,This parameter is the interrupt server configuration.
interrupt,"This parameter is the pointer to an uint32_t object.  When the directive call was successful, the index of the created interrupt server will be stored in this object."
interrupt,RETURN VALUES:
interrupt,The requested operation was successful.
interrupt,"The directive uses rtems_task_create().  If this directive fails, then its error status will be returned."
interrupt,NOTES:
interrupt,See also rtems_interrupt_server_initialize() and rtems_interrupt_server_delete().
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
interrupt,The directive may be called from within device driver initialization context.
interrupt,The directive may be called from within task context.
interrupt,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
interrupt,Installs the interrupt handler routine and argument at the interrupt vector on the interrupt server.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the interrupt server index.  The constant RTEMS_INTERRUPT_SERVER_DEFAULT may be used to specify the default interrupt server.
interrupt,This parameter is the interrupt vector number.
interrupt,This parameter is the descriptive information of the interrupt handler to install.
interrupt,This parameter is the interrupt handler install option set.
interrupt,This parameter is the interrupt handler routine to install.
interrupt,This parameter is the interrupt handler argument to install.
interrupt,DESCRIPTION:
interrupt,The handler routine specified by routine will be executed within the context of the interrupt server task specified by server_index.
interrupt,RETURN VALUES:
interrupt,The requested operation was successful.
interrupt,There was no interrupt server associated with the index specified by server_index.
interrupt,The directive was called from within interrupt context.
interrupt,The routine parameter was NULL.
interrupt,There was no interrupt vector associated with the number specified by vector.
interrupt,An option specified by info was not applicable.
interrupt,The RTEMS_INTERRUPT_UNIQUE option was set in info and the interrupt vector was already occupied by a handler.
interrupt,The RTEMS_INTERRUPT_SHARED option was set in info and the interrupt vector was already occupied by a unique handler.
interrupt,The handler specified by routine was already installed for the interrupt vector specified by vector with an argument equal to the argument specified by arg.
interrupt,The RTEMS_INTERRUPT_REPLACE option was set in info and no handler to replace was installed.
interrupt,NOTES:
interrupt,See also rtems_interrupt_handler_install().
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
interrupt,The directive may be called from within device driver initialization context.
interrupt,The directive may be called from within task context.
interrupt,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
interrupt,Removes the interrupt handler routine and argument from the interrupt vector and the interrupt server.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the interrupt server index.  The constant RTEMS_INTERRUPT_SERVER_DEFAULT may be used to specify the default interrupt server.
interrupt,This parameter is the interrupt vector number.
interrupt,This parameter is the interrupt handler routine to remove.
interrupt,This parameter is the interrupt handler argument to remove.
interrupt,RETURN VALUES:
interrupt,The requested operation was successful.
interrupt,There was no interrupt server associated with the index specified by server_index.
interrupt,There was no interrupt vector associated with the number specified by vector.
interrupt,There was no handler routine and argument pair installed specified by routine and arg.
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted. The directive sends a request to another task and waits for a response.  This may cause the calling task to be blocked and unblocked. The directive shall not be called from within the context of an interrupt server.  Calling the directive from within the context of an interrupt server is undefined behaviour.
interrupt,The directive may be called from within task context.
interrupt,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
interrupt,The directive sends a request to another task and waits for a response.  This may cause the calling task to be blocked and unblocked.
interrupt,The directive shall not be called from within the context of an interrupt server.  Calling the directive from within the context of an interrupt server is undefined behaviour.
interrupt,Sets the processor affinity of the interrupt server.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the interrupt server index.  The constant RTEMS_INTERRUPT_SERVER_DEFAULT may be used to specify the default interrupt server.
interrupt,This parameter is the size of the processor set referenced by affinity in bytes.
interrupt,"This parameter is the pointer to a cpu_set_t object.  The processor set defines the new processor affinity set of the interrupt server.  A set bit in the processor set means that the corresponding processor shall be in the processor affinity set of the task, otherwise the bit shall be cleared."
interrupt,This parameter is the new real priority for the interrupt server.
interrupt,RETURN VALUES:
interrupt,The requested operation was successful.
interrupt,There was no interrupt server associated with the index specified by server_index.
interrupt,"The directive uses rtems_scheduler_ident_by_processor_set(), rtems_task_set_scheduler(), and rtems_task_set_affinity().  If one of these directive fails, then its error status will be returned."
interrupt,NOTES:
interrupt,The scheduler is set determined by the highest numbered processor in the affinity set specified by affinity.
interrupt,This operation is only reliable in case the interrupt server was suspended via rtems_interrupt_server_suspend().
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may change the processor affinity of a task.  This may cause the calling task to be preempted. The directive may change the priority of a task.  This may cause the calling task to be preempted.
interrupt,The directive may be called from within interrupt context.
interrupt,The directive may be called from within device driver initialization context.
interrupt,The directive may be called from within task context.
interrupt,The directive may change the processor affinity of a task.  This may cause the calling task to be preempted.
interrupt,The directive may change the priority of a task.  This may cause the calling task to be preempted.
interrupt,Deletes the interrupt server.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the index of the interrupt server to delete.
interrupt,RETURN VALUES:
interrupt,The requested operation was successful.
interrupt,There was no interrupt server associated with the server index specified by server_index.
interrupt,NOTES:
interrupt,"The interrupt server deletes itself, so after the return of the directive the interrupt server may be still in the termination process depending on the task priorities of the system."
interrupt,See also rtems_interrupt_server_create().
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within task context. The directive shall not be called from within the context of an interrupt server.  Calling the directive from within the context of an interrupt server is undefined behaviour. The directive sends a request to another task and waits for a response.  This may cause the calling task to be blocked and unblocked.
interrupt,The directive may be called from within task context.
interrupt,The directive shall not be called from within the context of an interrupt server.  Calling the directive from within the context of an interrupt server is undefined behaviour.
interrupt,The directive sends a request to another task and waits for a response.  This may cause the calling task to be blocked and unblocked.
interrupt,Suspends the interrupt server.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the index of the interrupt server to suspend.  The constant RTEMS_INTERRUPT_SERVER_DEFAULT may be used to specify the default interrupt server.
interrupt,RETURN VALUES:
interrupt,The requested operation was successful.
interrupt,There was no interrupt server associated with the index specified by server_index.
interrupt,NOTES:
interrupt,Interrupt server may be resumed by rtems_interrupt_server_resume().
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within task context. The directive shall not be called from within the context of an interrupt server.  Calling the directive from within the context of an interrupt server is undefined behaviour. The directive sends a request to another task and waits for a response.  This may cause the calling task to be blocked and unblocked.
interrupt,The directive may be called from within task context.
interrupt,The directive shall not be called from within the context of an interrupt server.  Calling the directive from within the context of an interrupt server is undefined behaviour.
interrupt,The directive sends a request to another task and waits for a response.  This may cause the calling task to be blocked and unblocked.
interrupt,Resumes the interrupt server.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the index of the interrupt server to resume.  The constant RTEMS_INTERRUPT_SERVER_DEFAULT may be used to specify the default interrupt server.
interrupt,RETURN VALUES:
interrupt,The requested operation was successful.
interrupt,There was no interrupt server associated with the index specified by server_index.
interrupt,NOTES:
interrupt,Interrupt server may be suspended by rtems_interrupt_server_suspend().
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within task context. The directive shall not be called from within the context of an interrupt server.  Calling the directive from within the context of an interrupt server is undefined behaviour. The directive sends a request to another task and waits for a response.  This may cause the calling task to be blocked and unblocked.
interrupt,The directive may be called from within task context.
interrupt,The directive shall not be called from within the context of an interrupt server.  Calling the directive from within the context of an interrupt server is undefined behaviour.
interrupt,The directive sends a request to another task and waits for a response.  This may cause the calling task to be blocked and unblocked.
interrupt,Moves the interrupt handlers installed at the interrupt vector and the source interrupt server to the destination interrupt server.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the index of the source interrupt server.  The constant RTEMS_INTERRUPT_SERVER_DEFAULT may be used to specify the default interrupt server.
interrupt,This parameter is the interrupt vector number.
interrupt,This parameter is the index of the destination interrupt server.  The constant RTEMS_INTERRUPT_SERVER_DEFAULT may be used to specify the default interrupt server.
interrupt,RETURN VALUES:
interrupt,The requested operation was successful.
interrupt,There was no interrupt server associated with the index specified by source_server_index.
interrupt,There was no interrupt server associated with the index specified by destination_server_index.
interrupt,There was no interrupt vector associated with the number specified by vector.
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within task context. The directive shall not be called from within the context of an interrupt server.  Calling the directive from within the context of an interrupt server is undefined behaviour. The directive sends a request to another task and waits for a response.  This may cause the calling task to be blocked and unblocked.
interrupt,The directive may be called from within task context.
interrupt,The directive shall not be called from within the context of an interrupt server.  Calling the directive from within the context of an interrupt server is undefined behaviour.
interrupt,The directive sends a request to another task and waits for a response.  This may cause the calling task to be blocked and unblocked.
interrupt,Iterates over all interrupt handler installed at the interrupt vector and interrupt server.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the index of the interrupt server.
interrupt,This parameter is the interrupt vector number.
interrupt,This parameter is the visitor routine.
interrupt,This parameter is the visitor argument.
interrupt,DESCRIPTION:
interrupt,"For each installed handler at the interrupt vector and interrupt server the visitor function specified by vector will be called with the argument specified by routine and the handler information, options, routine and argument."
interrupt,RETURN VALUES:
interrupt,The requested operation was successful.
interrupt,There was no interrupt server associated with the index specified by server_index.
interrupt,There was no interrupt vector associated with the number specified by vector.
interrupt,NOTES:
interrupt,The directive is intended for system information and diagnostics.
interrupt,Never install or remove an interrupt handler within the visitor function. This may result in a deadlock.
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
interrupt,The directive may be called from within device driver initialization context.
interrupt,The directive may be called from within task context.
interrupt,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
interrupt,Initializes the interrupt server entry.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the interrupt server index.  The constant RTEMS_INTERRUPT_SERVER_DEFAULT may be used to specify the default interrupt server.
interrupt,This parameter is the interrupt server entry to initialize.
interrupt,RETURN VALUES:
interrupt,The requested operation was successful.
interrupt,There was no interrupt server associated with the index specified by server_index.
interrupt,NOTES:
interrupt,"After initialization, the list of actions of the interrupt server entry is empty.  Actions may be prepended by rtems_interrupt_server_action_prepend(). Interrupt server entries may be moved to another interrupt vector with rtems_interrupt_server_entry_move().  Server entries may be submitted to get serviced by the interrupt server with rtems_interrupt_server_entry_submit().  Server entries may be destroyed by rtems_interrupt_server_entry_destroy()."
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
interrupt,The directive may be called from within device driver initialization context.
interrupt,The directive may be called from within task context.
interrupt,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
interrupt,Prepends the interrupt server action to the list of actions of the interrupt server entry.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the interrupt server entry to prepend the interrupt server action.  It shall have been initialized via rtems_interrupt_server_entry_initialize().
interrupt,This parameter is the interrupt server action to initialize and prepend to the list of actions of the entry.
interrupt,This parameter is the interrupt handler routine to set in the action.
interrupt,This parameter is the interrupt handler argument to set in the action.
interrupt,NOTES:
interrupt,No error checking is performed by the directive.
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive will not cause the calling task to be preempted. The interrupt server entry shall have been initialized by rtems_interrupt_server_entry_initialize() and further optional calls to rtems_interrupt_server_action_prepend(). The directive shall not be called concurrently with rtems_interrupt_server_action_prepend() with the same interrupt server entry. Calling the directive under this condition is undefined behaviour. The directive shall not be called concurrently with rtems_interrupt_server_entry_move() with the same interrupt server entry. Calling the directive under this condition is undefined behaviour. The directive shall not be called concurrently with rtems_interrupt_server_entry_submit() with the same interrupt server entry. Calling the directive under this condition is undefined behaviour. The directive shall not be called while the interrupt server entry is pending on or serviced by its current interrupt server.  Calling the directive under these conditions is undefined behaviour.
interrupt,The directive may be called from within interrupt context.
interrupt,The directive may be called from within device driver initialization context.
interrupt,The directive may be called from within task context.
interrupt,The directive will not cause the calling task to be preempted.
interrupt,The interrupt server entry shall have been initialized by rtems_interrupt_server_entry_initialize() and further optional calls to rtems_interrupt_server_action_prepend().
interrupt,The directive shall not be called concurrently with rtems_interrupt_server_action_prepend() with the same interrupt server entry. Calling the directive under this condition is undefined behaviour.
interrupt,The directive shall not be called concurrently with rtems_interrupt_server_entry_move() with the same interrupt server entry. Calling the directive under this condition is undefined behaviour.
interrupt,The directive shall not be called concurrently with rtems_interrupt_server_entry_submit() with the same interrupt server entry. Calling the directive under this condition is undefined behaviour.
interrupt,The directive shall not be called while the interrupt server entry is pending on or serviced by its current interrupt server.  Calling the directive under these conditions is undefined behaviour.
interrupt,Destroys the interrupt server entry.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the interrupt server entry to destroy.
interrupt,NOTES:
interrupt,No error checking is performed by the directive.
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within task context. The directive shall not be called from within the context of an interrupt server.  Calling the directive from within the context of an interrupt server is undefined behaviour. The directive sends a request to another task and waits for a response.  This may cause the calling task to be blocked and unblocked. The interrupt server entry shall have been initialized by rtems_interrupt_server_entry_initialize() and further optional calls to rtems_interrupt_server_action_prepend().
interrupt,The directive may be called from within task context.
interrupt,The directive shall not be called from within the context of an interrupt server.  Calling the directive from within the context of an interrupt server is undefined behaviour.
interrupt,The directive sends a request to another task and waits for a response.  This may cause the calling task to be blocked and unblocked.
interrupt,The interrupt server entry shall have been initialized by rtems_interrupt_server_entry_initialize() and further optional calls to rtems_interrupt_server_action_prepend().
interrupt,Submits the interrupt server entry to be serviced by the interrupt server.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the interrupt server entry to submit.
interrupt,DESCRIPTION:
interrupt,The directive appends the entry to the pending entries of the interrupt server. The interrupt server is notified that a new entry is pending.  Once the interrupt server is scheduled it services the actions of all pending entries.
interrupt,NOTES:
interrupt,This directive may be used to do a two-step interrupt processing.  The first step is done from within interrupt context by a call to this directive.  The second step is then done from within the context of the interrupt server.
interrupt,No error checking is performed by the directive.
interrupt,A submitted entry may be destroyed by rtems_interrupt_server_entry_destroy().
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may unblock a task.  This may cause the calling task to be preempted. The interrupt server entry shall have been initialized by rtems_interrupt_server_entry_initialize() and further optional calls to rtems_interrupt_server_action_prepend(). The directive shall not be called concurrently with rtems_interrupt_server_action_prepend() with the same interrupt server entry. Calling the directive under this condition is undefined behaviour. The directive shall not be called concurrently with rtems_interrupt_server_entry_move() with the same interrupt server entry. Calling the directive under this condition is undefined behaviour.
interrupt,The directive may be called from within interrupt context.
interrupt,The directive may be called from within device driver initialization context.
interrupt,The directive may be called from within task context.
interrupt,The directive may unblock a task.  This may cause the calling task to be preempted.
interrupt,The interrupt server entry shall have been initialized by rtems_interrupt_server_entry_initialize() and further optional calls to rtems_interrupt_server_action_prepend().
interrupt,The directive shall not be called concurrently with rtems_interrupt_server_action_prepend() with the same interrupt server entry. Calling the directive under this condition is undefined behaviour.
interrupt,The directive shall not be called concurrently with rtems_interrupt_server_entry_move() with the same interrupt server entry. Calling the directive under this condition is undefined behaviour.
interrupt,Moves the interrupt server entry to the interrupt server.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the interrupt server entry to move.
interrupt,This parameter is the index of the destination interrupt server.  The constant RTEMS_INTERRUPT_SERVER_DEFAULT may be used to specify the default interrupt server.
interrupt,RETURN VALUES:
interrupt,The requested operation was successful.
interrupt,There was no interrupt server associated with the index specified by server_index.
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted. The interrupt server entry shall have been initialized by rtems_interrupt_server_entry_initialize() and further optional calls to rtems_interrupt_server_action_prepend(). The directive shall not be called concurrently with rtems_interrupt_server_action_prepend() with the same interrupt server entry. Calling the directive under this condition is undefined behaviour. The directive shall not be called concurrently with rtems_interrupt_server_entry_move() with the same interrupt server entry. Calling the directive under this condition is undefined behaviour. The directive shall not be called concurrently with rtems_interrupt_server_entry_submit() with the same interrupt server entry. Calling the directive under this condition is undefined behaviour. The directive shall not be called while the interrupt server entry is pending on or serviced by its current interrupt server.  Calling the directive under these conditions is undefined behaviour.
interrupt,The directive may be called from within device driver initialization context.
interrupt,The directive may be called from within task context.
interrupt,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
interrupt,The interrupt server entry shall have been initialized by rtems_interrupt_server_entry_initialize() and further optional calls to rtems_interrupt_server_action_prepend().
interrupt,The directive shall not be called concurrently with rtems_interrupt_server_action_prepend() with the same interrupt server entry. Calling the directive under this condition is undefined behaviour.
interrupt,The directive shall not be called concurrently with rtems_interrupt_server_entry_move() with the same interrupt server entry. Calling the directive under this condition is undefined behaviour.
interrupt,The directive shall not be called concurrently with rtems_interrupt_server_entry_submit() with the same interrupt server entry. Calling the directive under this condition is undefined behaviour.
interrupt,The directive shall not be called while the interrupt server entry is pending on or serviced by its current interrupt server.  Calling the directive under these conditions is undefined behaviour.
interrupt,Initializes the interrupt server request.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the interrupt server index.  The constant RTEMS_INTERRUPT_SERVER_DEFAULT may be used to specify the default interrupt server.
interrupt,This parameter is the interrupt server request to initialize.
interrupt,This parameter is the interrupt handler routine for the request action.
interrupt,This parameter is the interrupt handler argument for the request action.
interrupt,RETURN VALUES:
interrupt,The requested operation was successful.
interrupt,There was no interrupt server associated with the index specified by server_index.
interrupt,NOTES:
interrupt,An interrupt server requests consists of an interrupt server entry and exactly one interrupt server action.  The interrupt vector of the request may be changed with rtems_interrupt_server_request_set_vector().  Interrupt server requests may be submitted to get serviced by the interrupt server with rtems_interrupt_server_request_submit().  Requests may be destroyed by rtems_interrupt_server_request_destroy().
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
interrupt,The directive may be called from within device driver initialization context.
interrupt,The directive may be called from within task context.
interrupt,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
interrupt,Sets the interrupt vector in the interrupt server request.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the interrupt server request to change.
interrupt,This parameter is the interrupt vector number to be used by the request.
interrupt,NOTES:
interrupt,"By default, the interrupt vector of an interrupt server request is set to a special value which is outside the range of vectors supported by the interrupt controller hardware."
interrupt,Calls to rtems_interrupt_server_request_submit() will disable the interrupt vector of the request.  After processing of the request by the interrupt server the interrupt vector will be enabled again.
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive will not cause the calling task to be preempted. The interrupt server request shall have been initialized by rtems_interrupt_server_request_initialize(). The directive shall not be called concurrently with rtems_interrupt_server_request_set_vector() with the same interrupt server request.  Calling the directive under this condition is undefined behaviour. The directive shall not be called concurrently with rtems_interrupt_server_request_submit() with the same interrupt server request. Calling the directive under this condition is undefined behaviour. The directive shall not be called while the interrupt server entry is pending on or serviced by its current interrupt server.  Calling the directive under these conditions is undefined behaviour.
interrupt,The directive may be called from within interrupt context.
interrupt,The directive may be called from within device driver initialization context.
interrupt,The directive may be called from within task context.
interrupt,The directive will not cause the calling task to be preempted.
interrupt,The interrupt server request shall have been initialized by rtems_interrupt_server_request_initialize().
interrupt,The directive shall not be called concurrently with rtems_interrupt_server_request_set_vector() with the same interrupt server request.  Calling the directive under this condition is undefined behaviour.
interrupt,The directive shall not be called concurrently with rtems_interrupt_server_request_submit() with the same interrupt server request. Calling the directive under this condition is undefined behaviour.
interrupt,The directive shall not be called while the interrupt server entry is pending on or serviced by its current interrupt server.  Calling the directive under these conditions is undefined behaviour.
interrupt,Destroys the interrupt server request.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the interrupt server request to destroy.
interrupt,NOTES:
interrupt,No error checking is performed by the directive.
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within task context. The directive shall not be called from within the context of an interrupt server.  Calling the directive from within the context of an interrupt server is undefined behaviour. The directive sends a request to another task and waits for a response.  This may cause the calling task to be blocked and unblocked. The interrupt server request shall have been initialized by rtems_interrupt_server_request_initialize().
interrupt,The directive may be called from within task context.
interrupt,The directive shall not be called from within the context of an interrupt server.  Calling the directive from within the context of an interrupt server is undefined behaviour.
interrupt,The directive sends a request to another task and waits for a response.  This may cause the calling task to be blocked and unblocked.
interrupt,The interrupt server request shall have been initialized by rtems_interrupt_server_request_initialize().
interrupt,Submits the interrupt server request to be serviced by the interrupt server.
interrupt,CALLING SEQUENCE:
interrupt,PARAMETERS:
interrupt,This parameter is the interrupt server request to submit.
interrupt,DESCRIPTION:
interrupt,The directive appends the interrupt server entry of the request to the pending entries of the interrupt server.  The interrupt server is notified that a new entry is pending.  Once the interrupt server is scheduled it services the actions of all pending entries.
interrupt,NOTES:
interrupt,This directive may be used to do a two-step interrupt processing.  The first step is done from within interrupt context by a call to this directive.  The second step is then done from within the context of the interrupt server.
interrupt,No error checking is performed by the directive.
interrupt,A submitted request may be destroyed by rtems_interrupt_server_request_destroy().
interrupt,CONSTRAINTS:
interrupt,The following constraints apply to this directive:
interrupt,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may unblock a task.  This may cause the calling task to be preempted. The interrupt server request shall have been initialized by rtems_interrupt_server_request_initialize(). The directive shall not be called concurrently with rtems_interrupt_server_request_set_vector() with the same interrupt server request.  Calling the directive under this condition is undefined behaviour.
interrupt,The directive may be called from within interrupt context.
interrupt,The directive may be called from within device driver initialization context.
interrupt,The directive may be called from within task context.
interrupt,The directive may unblock a task.  This may cause the calling task to be preempted.
interrupt,The interrupt server request shall have been initialized by rtems_interrupt_server_request_initialize().
interrupt,The directive shall not be called concurrently with rtems_interrupt_server_request_set_vector() with the same interrupt server request.  Calling the directive under this condition is undefined behaviour.
interrupt,"© Copyright 1988, 2024 RTEMS Project and contributors."
interrupt,Any real-time executive must provide a mechanism for quick response to externally generated interrupts to satisfy the critical time constraints of the application.  The Interrupt Manager provides this mechanism for RTEMS. This manager permits quick interrupt response times by providing the critical ability to alter task execution which allows a task to be preempted upon exit from an ISR. The directives provided by the Interrupt Manager are:
interrupt,rtems_interrupt_catch() - Establishes an interrupt service routine. rtems_interrupt_disable() - Disables the maskable interrupts on the current processor. rtems_interrupt_enable() - Restores the previous interrupt level on the current processor. rtems_interrupt_flash() - Flashes interrupts on the current processor. rtems_interrupt_local_disable() - Disables the maskable interrupts on the current processor. rtems_interrupt_local_enable() - Restores the previous interrupt level on the current processor. rtems_interrupt_is_in_progress() - Checks if an ISR is in progress on the current processor. rtems_interrupt_lock_initialize() - Initializes the ISR lock. rtems_interrupt_lock_destroy() - Destroys the ISR lock. rtems_interrupt_lock_acquire() - Acquires the ISR lock. rtems_interrupt_lock_release() - Releases the ISR lock. rtems_interrupt_lock_acquire_isr() - Acquires the ISR lock from within an ISR. rtems_interrupt_lock_release_isr() - Releases the ISR lock from within an ISR. rtems_interrupt_lock_interrupt_disable() - Disables maskable interrupts on the current processor. RTEMS_INTERRUPT_LOCK_DECLARE() - Declares an ISR lock object. RTEMS_INTERRUPT_LOCK_DEFINE() - Defines an ISR lock object. RTEMS_INTERRUPT_LOCK_INITIALIZER() - Statically initializes an ISR lock object. RTEMS_INTERRUPT_LOCK_MEMBER() - Defines an ISR lock member. RTEMS_INTERRUPT_LOCK_REFERENCE() - Defines an ISR lock object reference. RTEMS_INTERRUPT_ENTRY_INITIALIZER() - Statically initializes an interrupt entry object. rtems_interrupt_entry_initialize() - Initializes the interrupt entry. rtems_interrupt_entry_install() - Installs the interrupt entry at the interrupt vector. rtems_interrupt_entry_remove() - Removes the interrupt entry from the interrupt vector. rtems_interrupt_handler_install() - Installs the interrupt handler routine and argument at the interrupt vector. rtems_interrupt_handler_remove() - Removes the interrupt handler routine and argument from the interrupt vector. rtems_interrupt_vector_is_enabled() - Checks if the interrupt vector is enabled. rtems_interrupt_vector_enable() - Enables the interrupt vector. rtems_interrupt_vector_disable() - Disables the interrupt vector. rtems_interrupt_is_pending() - Checks if the interrupt is pending. rtems_interrupt_raise() - Raises the interrupt vector. rtems_interrupt_raise_on() - Raises the interrupt vector on the processor. rtems_interrupt_clear() - Clears the interrupt vector. rtems_interrupt_get_priority() - Gets the priority of the interrupt vector. rtems_interrupt_set_priority() - Sets the priority of the interrupt vector. rtems_interrupt_get_affinity() - Gets the processor affinity set of the interrupt vector. rtems_interrupt_set_affinity() - Sets the processor affinity set of the interrupt vector. rtems_interrupt_get_attributes() - Gets the attributes of the interrupt vector. rtems_interrupt_handler_iterate() - Iterates over all interrupt handler installed at the interrupt vector. rtems_interrupt_server_initialize() - Initializes the interrupt server tasks. rtems_interrupt_server_create() - Creates an interrupt server. rtems_interrupt_server_handler_install() - Installs the interrupt handler routine and argument at the interrupt vector on the interrupt server. rtems_interrupt_server_handler_remove() - Removes the interrupt handler routine and argument from the interrupt vector and the interrupt server. rtems_interrupt_server_set_affinity() - Sets the processor affinity of the interrupt server. rtems_interrupt_server_delete() - Deletes the interrupt server. rtems_interrupt_server_suspend() - Suspends the interrupt server. rtems_interrupt_server_resume() - Resumes the interrupt server. rtems_interrupt_server_move() - Moves the interrupt handlers installed at the interrupt vector and the source interrupt server to the destination interrupt server. rtems_interrupt_server_handler_iterate() - Iterates over all interrupt handler installed at the interrupt vector and interrupt server. rtems_interrupt_server_entry_initialize() - Initializes the interrupt server entry. rtems_interrupt_server_action_prepend() - Prepends the interrupt server action to the list of actions of the interrupt server entry. rtems_interrupt_server_entry_destroy() - Destroys the interrupt server entry. rtems_interrupt_server_entry_submit() - Submits the interrupt server entry to be serviced by the interrupt server. rtems_interrupt_server_entry_move() - Moves the interrupt server entry to the interrupt server. rtems_interrupt_server_request_initialize() - Initializes the interrupt server request. rtems_interrupt_server_request_set_vector() - Sets the interrupt vector in the interrupt server request. rtems_interrupt_server_request_destroy() - Destroys the interrupt server request. rtems_interrupt_server_request_submit() - Submits the interrupt server request to be serviced by the interrupt server.
interrupt,rtems_interrupt_catch() - Establishes an interrupt service routine.
interrupt,rtems_interrupt_disable() - Disables the maskable interrupts on the current processor.
interrupt,rtems_interrupt_enable() - Restores the previous interrupt level on the current processor.
interrupt,rtems_interrupt_flash() - Flashes interrupts on the current processor.
interrupt,rtems_interrupt_local_disable() - Disables the maskable interrupts on the current processor.
interrupt,rtems_interrupt_local_enable() - Restores the previous interrupt level on the current processor.
interrupt,rtems_interrupt_is_in_progress() - Checks if an ISR is in progress on the current processor.
interrupt,rtems_interrupt_lock_initialize() - Initializes the ISR lock.
interrupt,rtems_interrupt_lock_destroy() - Destroys the ISR lock.
interrupt,rtems_interrupt_lock_acquire() - Acquires the ISR lock.
interrupt,rtems_interrupt_lock_release() - Releases the ISR lock.
interrupt,rtems_interrupt_lock_acquire_isr() - Acquires the ISR lock from within an ISR.
interrupt,rtems_interrupt_lock_release_isr() - Releases the ISR lock from within an ISR.
interrupt,rtems_interrupt_lock_interrupt_disable() - Disables maskable interrupts on the current processor.
interrupt,RTEMS_INTERRUPT_LOCK_DECLARE() - Declares an ISR lock object.
interrupt,RTEMS_INTERRUPT_LOCK_DEFINE() - Defines an ISR lock object.
interrupt,RTEMS_INTERRUPT_LOCK_INITIALIZER() - Statically initializes an ISR lock object.
interrupt,RTEMS_INTERRUPT_LOCK_MEMBER() - Defines an ISR lock member.
interrupt,RTEMS_INTERRUPT_LOCK_REFERENCE() - Defines an ISR lock object reference.
interrupt,RTEMS_INTERRUPT_ENTRY_INITIALIZER() - Statically initializes an interrupt entry object.
interrupt,rtems_interrupt_entry_initialize() - Initializes the interrupt entry.
interrupt,rtems_interrupt_entry_install() - Installs the interrupt entry at the interrupt vector.
interrupt,rtems_interrupt_entry_remove() - Removes the interrupt entry from the interrupt vector.
interrupt,rtems_interrupt_handler_install() - Installs the interrupt handler routine and argument at the interrupt vector.
interrupt,rtems_interrupt_handler_remove() - Removes the interrupt handler routine and argument from the interrupt vector.
interrupt,rtems_interrupt_vector_is_enabled() - Checks if the interrupt vector is enabled.
interrupt,rtems_interrupt_vector_enable() - Enables the interrupt vector.
interrupt,rtems_interrupt_vector_disable() - Disables the interrupt vector.
interrupt,rtems_interrupt_is_pending() - Checks if the interrupt is pending.
interrupt,rtems_interrupt_raise() - Raises the interrupt vector.
interrupt,rtems_interrupt_raise_on() - Raises the interrupt vector on the processor.
interrupt,rtems_interrupt_clear() - Clears the interrupt vector.
interrupt,rtems_interrupt_get_priority() - Gets the priority of the interrupt vector.
interrupt,rtems_interrupt_set_priority() - Sets the priority of the interrupt vector.
interrupt,rtems_interrupt_get_affinity() - Gets the processor affinity set of the interrupt vector.
interrupt,rtems_interrupt_set_affinity() - Sets the processor affinity set of the interrupt vector.
interrupt,rtems_interrupt_get_attributes() - Gets the attributes of the interrupt vector.
interrupt,rtems_interrupt_handler_iterate() - Iterates over all interrupt handler installed at the interrupt vector.
interrupt,rtems_interrupt_server_initialize() - Initializes the interrupt server tasks.
interrupt,rtems_interrupt_server_create() - Creates an interrupt server.
interrupt,rtems_interrupt_server_handler_install() - Installs the interrupt handler routine and argument at the interrupt vector on the interrupt server.
interrupt,rtems_interrupt_server_handler_remove() - Removes the interrupt handler routine and argument from the interrupt vector and the interrupt server.
interrupt,rtems_interrupt_server_set_affinity() - Sets the processor affinity of the interrupt server.
interrupt,rtems_interrupt_server_delete() - Deletes the interrupt server.
interrupt,rtems_interrupt_server_suspend() - Suspends the interrupt server.
interrupt,rtems_interrupt_server_resume() - Resumes the interrupt server.
interrupt,rtems_interrupt_server_move() - Moves the interrupt handlers installed at the interrupt vector and the source interrupt server to the destination interrupt server.
interrupt,rtems_interrupt_server_handler_iterate() - Iterates over all interrupt handler installed at the interrupt vector and interrupt server.
interrupt,rtems_interrupt_server_entry_initialize() - Initializes the interrupt server entry.
interrupt,rtems_interrupt_server_action_prepend() - Prepends the interrupt server action to the list of actions of the interrupt server entry.
interrupt,rtems_interrupt_server_entry_destroy() - Destroys the interrupt server entry.
interrupt,rtems_interrupt_server_entry_submit() - Submits the interrupt server entry to be serviced by the interrupt server.
interrupt,rtems_interrupt_server_entry_move() - Moves the interrupt server entry to the interrupt server.
interrupt,rtems_interrupt_server_request_initialize() - Initializes the interrupt server request.
interrupt,rtems_interrupt_server_request_set_vector() - Sets the interrupt vector in the interrupt server request.
interrupt,rtems_interrupt_server_request_destroy() - Destroys the interrupt server request.
interrupt,rtems_interrupt_server_request_submit() - Submits the interrupt server request to be serviced by the interrupt server.
interrupt,"© Copyright 1988, 2024 RTEMS Project and contributors."
interrupt,The rtems_interrupt_catch directive establishes an ISR for the system.  The address of the ISR and its associated CPU vector number are specified to this directive.  This directive installs the RTEMS interrupt wrapper in the processor’s Interrupt Vector Table and the address of the user’s ISR in the RTEMS’ Vector Table.  This directive returns the previous contents of the specified vector in the RTEMS’ Vector Table.
interrupt,"Using the interrupt manager ensures that RTEMS knows when a directive is being called from an ISR.  The ISR may then use system calls to synchronize itself with an application task.  The synchronization may involve messages, events or signals being passed by the ISR to the desired task.  Directives invoked by an ISR must operate only on objects which reside on the local node.  The following is a list of RTEMS system calls that may be made from an ISR:"
interrupt,"Task Management Although it is acceptable to operate on the RTEMS_SELF task (e.g.  the currently executing task), while in an ISR, this will refer to the interrupted task.  Most of the time, it is an application implementation error to use RTEMS_SELF from an ISR. rtems_task_suspend rtems_task_resume rtems_task_suspend rtems_task_resume Interrupt Management rtems_interrupt_enable rtems_interrupt_disable rtems_interrupt_flash rtems_interrupt_lock_acquire rtems_interrupt_lock_release rtems_interrupt_lock_acquire_isr rtems_interrupt_lock_release_isr rtems_interrupt_is_in_progress rtems_interrupt_catch rtems_interrupt_enable rtems_interrupt_disable rtems_interrupt_flash rtems_interrupt_lock_acquire rtems_interrupt_lock_release rtems_interrupt_lock_acquire_isr rtems_interrupt_lock_release_isr rtems_interrupt_is_in_progress rtems_interrupt_catch Clock Management rtems_clock_set rtems_clock_get_tod rtems_clock_get_tod_timeval rtems_clock_get_seconds_since_epoch rtems_clock_get_ticks_per_second rtems_clock_get_ticks_since_boot rtems_clock_get_uptime rtems_clock_set rtems_clock_get_tod rtems_clock_get_tod_timeval rtems_clock_get_seconds_since_epoch rtems_clock_get_ticks_per_second rtems_clock_get_ticks_since_boot rtems_clock_get_uptime Timer Management rtems_timer_cancel rtems_timer_reset rtems_timer_fire_after rtems_timer_fire_when rtems_timer_server_fire_after rtems_timer_server_fire_when rtems_timer_cancel rtems_timer_reset rtems_timer_fire_after rtems_timer_fire_when rtems_timer_server_fire_after rtems_timer_server_fire_when Event Management rtems_event_send rtems_event_system_send rtems_event_transient_send rtems_event_send rtems_event_system_send rtems_event_transient_send Semaphore Management rtems_semaphore_release rtems_semaphore_release Message Management rtems_message_queue_broadcast rtems_message_queue_send rtems_message_queue_urgent rtems_message_queue_broadcast rtems_message_queue_send rtems_message_queue_urgent Signal Management rtems_signal_send rtems_signal_send Dual-Ported Memory Management rtems_port_external_to_internal rtems_port_internal_to_external rtems_port_external_to_internal rtems_port_internal_to_external IO Management The following services are safe to call from an ISR if and only if the device driver service invoked is also safe.  The IO Manager itself is safe but the invoked driver entry point may or may not be. rtems_io_initialize rtems_io_open rtems_io_close rtems_io_read rtems_io_write rtems_io_control rtems_io_initialize rtems_io_open rtems_io_close rtems_io_read rtems_io_write rtems_io_control Fatal Error Management rtems_fatal rtems_fatal_error_occurred rtems_fatal rtems_fatal_error_occurred Multiprocessing rtems_multiprocessing_announce rtems_multiprocessing_announce"
interrupt,"Task Management Although it is acceptable to operate on the RTEMS_SELF task (e.g.  the currently executing task), while in an ISR, this will refer to the interrupted task.  Most of the time, it is an application implementation error to use RTEMS_SELF from an ISR."
interrupt,rtems_task_suspend rtems_task_resume
interrupt,rtems_task_suspend
interrupt,rtems_task_resume
interrupt,Interrupt Management
interrupt,rtems_interrupt_enable rtems_interrupt_disable rtems_interrupt_flash rtems_interrupt_lock_acquire rtems_interrupt_lock_release rtems_interrupt_lock_acquire_isr rtems_interrupt_lock_release_isr rtems_interrupt_is_in_progress rtems_interrupt_catch
interrupt,rtems_interrupt_enable
interrupt,rtems_interrupt_disable
interrupt,rtems_interrupt_flash
interrupt,rtems_interrupt_lock_acquire
interrupt,rtems_interrupt_lock_release
interrupt,rtems_interrupt_lock_acquire_isr
interrupt,rtems_interrupt_lock_release_isr
interrupt,rtems_interrupt_is_in_progress
interrupt,rtems_interrupt_catch
interrupt,Clock Management
interrupt,rtems_clock_set rtems_clock_get_tod rtems_clock_get_tod_timeval rtems_clock_get_seconds_since_epoch rtems_clock_get_ticks_per_second rtems_clock_get_ticks_since_boot rtems_clock_get_uptime
interrupt,rtems_clock_set
interrupt,rtems_clock_get_tod
interrupt,rtems_clock_get_tod_timeval
interrupt,rtems_clock_get_seconds_since_epoch
interrupt,rtems_clock_get_ticks_per_second
interrupt,rtems_clock_get_ticks_since_boot
interrupt,rtems_clock_get_uptime
interrupt,Timer Management
interrupt,rtems_timer_cancel rtems_timer_reset rtems_timer_fire_after rtems_timer_fire_when rtems_timer_server_fire_after rtems_timer_server_fire_when
interrupt,rtems_timer_cancel
interrupt,rtems_timer_reset
interrupt,rtems_timer_fire_after
interrupt,rtems_timer_fire_when
interrupt,rtems_timer_server_fire_after
interrupt,rtems_timer_server_fire_when
interrupt,Event Management
interrupt,rtems_event_send rtems_event_system_send rtems_event_transient_send
interrupt,rtems_event_send
interrupt,rtems_event_system_send
interrupt,rtems_event_transient_send
interrupt,Semaphore Management
interrupt,rtems_semaphore_release
interrupt,rtems_semaphore_release
interrupt,Message Management
interrupt,rtems_message_queue_broadcast rtems_message_queue_send rtems_message_queue_urgent
interrupt,rtems_message_queue_broadcast
interrupt,rtems_message_queue_send
interrupt,rtems_message_queue_urgent
interrupt,Signal Management
interrupt,rtems_signal_send
interrupt,rtems_signal_send
interrupt,Dual-Ported Memory Management
interrupt,rtems_port_external_to_internal rtems_port_internal_to_external
interrupt,rtems_port_external_to_internal
interrupt,rtems_port_internal_to_external
interrupt,IO Management The following services are safe to call from an ISR if and only if the device driver service invoked is also safe.  The IO Manager itself is safe but the invoked driver entry point may or may not be.
interrupt,rtems_io_initialize rtems_io_open rtems_io_close rtems_io_read rtems_io_write rtems_io_control
interrupt,rtems_io_initialize
interrupt,rtems_io_open
interrupt,rtems_io_close
interrupt,rtems_io_read
interrupt,rtems_io_write
interrupt,rtems_io_control
interrupt,Fatal Error Management
interrupt,rtems_fatal rtems_fatal_error_occurred
interrupt,rtems_fatal
interrupt,rtems_fatal_error_occurred
interrupt,Multiprocessing
interrupt,rtems_multiprocessing_announce
interrupt,rtems_multiprocessing_announce
interrupt,"© Copyright 1988, 2024 RTEMS Project and contributors."
io,Each application utilizing the RTEMS I/O manager must specify the address of a Device Driver Table in its Configuration Table. This table contains each device driver’s entry points that is to be initialised by RTEMS during initialization. Each device driver may contain the following entry points:
io,Initialization Open Close Read Write Control
io,Initialization
io,Open
io,Close
io,Read
io,Write
io,Control
io,"If the device driver does not support a particular entry point, then that entry in the Configuration Table should be NULL.  RTEMS will return RTEMS_SUCCESSFUL as the executive’s and zero (0) as the device driver’s return code for these device driver entry points."
io,Applications can register and unregister drivers with the RTEMS I/O manager avoiding the need to have all drivers statically defined and linked into this table.
io,The confdefs.h entry CONFIGURE_MAXIMUM_DRIVERS configures the number of driver slots available to the application.
io,"Each call to the I/O manager must provide a device’s major and minor numbers as arguments.  The major number is the index of the requested driver’s entry points in the Device Driver Table, and is used to select a specific device driver.  The exact usage of the minor number is driver specific, but is commonly used to distinguish between a number of devices controlled by the same driver."
io,"The data types rtems_device_major_number and rtems_device_minor_number are used to manipulate device major and minor numbers, respectively."
io,The I/O Manager provides facilities to associate a name with a particular device.  Directives are provided to register the name of a device and to look up the major/minor number pair associated with a device name.
io,"Application developers, as well as device driver developers, must be aware of the following regarding the RTEMS I/O Manager:"
io,"A device driver routine executes in the context of the invoking task.  Thus if the driver blocks, the invoking task blocks. The device driver is free to change the modes of the invoking task, although the driver should restore them to their original values. Device drivers may be invoked from ISRs. Only local device drivers are accessible through the I/O manager. A device driver routine may invoke all other RTEMS directives, including I/O directives, on both local and global objects."
io,"A device driver routine executes in the context of the invoking task.  Thus if the driver blocks, the invoking task blocks."
io,"The device driver is free to change the modes of the invoking task, although the driver should restore them to their original values."
io,Device drivers may be invoked from ISRs.
io,Only local device drivers are accessible through the I/O manager.
io,"A device driver routine may invoke all other RTEMS directives, including I/O directives, on both local and global objects."
io,"Although the RTEMS I/O manager provides a framework for device drivers, it makes no assumptions regarding the construction or operation of a device driver."
io,Board support package and application developers can select wether a device driver is statically entered into the default device table or registered at runtime.
io,Dynamic registration helps applications where:
io,The BSP and kernel libraries are common to a range of applications for a specific target platform. An application may be built upon a common library with all drivers. The application selects and registers the drivers. Uniform driver name lookup protects the application. The type and range of drivers may vary as the application probes a bus during initialization. Support for hot swap bus system such as Compact PCI. Support for runtime loadable driver modules.
io,The BSP and kernel libraries are common to a range of applications for a specific target platform. An application may be built upon a common library with all drivers. The application selects and registers the drivers. Uniform driver name lookup protects the application.
io,The type and range of drivers may vary as the application probes a bus during initialization.
io,Support for hot swap bus system such as Compact PCI.
io,Support for runtime loadable driver modules.
io,"When an application invokes an I/O manager directive, RTEMS determines which device driver entry point must be invoked.  The information passed by the application to RTEMS is then passed to the correct device driver entry point. RTEMS will invoke each device driver entry point assuming it is compatible with the following prototype:"
io,The format and contents of the parameter block are device driver and entry point dependent.
io,It is recommended that a device driver avoid generating error codes which conflict with those used by application components.  A common technique used to generate driver specific error codes is to make the most significant part of the status indicate a driver specific code.
io,RTEMS automatically initializes all device drivers when multitasking is initiated via the rtems_initialize_executive directive.  RTEMS initializes the device drivers by invoking each device driver initialization entry point with the following parameters:
io,the major device number for this device driver.
io,zero.
io,will point to  the Configuration Table.
io,"The returned status will be ignored by RTEMS.  If the driver cannot successfully initialize the device, then it should invoke the fatal_error_occurred directive."
io,"© Copyright 1988, 2024 RTEMS Project and contributors."
io,"This section details the directives of the I/O Manager. A subsection is dedicated to each of this manager’s directives and lists the calling sequence, parameters, description, return values, and notes of the directive."
io,Registers and initializes the device with the specified device driver address table and device major number in the Device Driver Table.
io,CALLING SEQUENCE:
io,PARAMETERS:
io,This parameter is the device major number.  Use a value of zero to let the system obtain a device major number automatically.
io,This parameter is the device driver address table.
io,"This parameter is the pointer to an rtems_device_major_number object.  When the directive call is successful, the device major number of the registered device will be stored in this object."
io,RETURN VALUES:
io,The requested operation was successful.
io,The device major number of the device was NULL.
io,The device driver address table was empty.
io,"The device major number of the device was out of range, see CONFIGURE_MAXIMUM_DRIVERS."
io,The system was unable to obtain a device major number.
io,The device major number was already in use.
io,The directive was called from interrupt context.
io,Other status codes may be returned by rtems_io_initialize().
io,NOTES:
io,If the device major number equals zero a device major number will be obtained. The device major number of the registered driver will be returned.
io,"After a successful registration, the rtems_io_initialize() directive will be called to initialize the device."
io,Removes a device driver specified by the device major number from the Device Driver Table.
io,CALLING SEQUENCE:
io,PARAMETERS:
io,This parameter is the major number of the device.
io,RETURN VALUES:
io,The requested operation was successful.
io,The device major number was invalid.
io,The directive was called from interrupt context.
io,NOTES:
io,Currently no specific checks are made and the driver is not closed.
io,Initializes the device specified by the device major and minor numbers.
io,CALLING SEQUENCE:
io,PARAMETERS:
io,This parameter is the major number of the device.
io,This parameter is the minor number of the device.
io,This parameter is the argument passed to the device driver initialization entry.
io,DESCRIPTION:
io,This directive calls the device driver initialization entry registered in the Device Driver Table for the specified device major number.
io,RETURN VALUES:
io,The requested operation was successful.
io,The device major number was invalid.
io,Other status codes may be returned by the device driver initialization entry.
io,NOTES:
io,This directive is automatically invoked for each device driver defined by the application configuration during the system initialization and via the rtems_io_register_driver() directive.
io,"A device driver initialization entry is responsible for initializing all hardware and data structures associated with a device.  If necessary, it can allocate memory to be used during other operations."
io,Registers the device specified by the device major and minor numbers in the file system under the specified name.
io,CALLING SEQUENCE:
io,PARAMETERS:
io,This parameter is the device name in the file system.
io,This parameter is the device major number.
io,This parameter is the device minor number.
io,RETURN VALUES:
io,The requested operation was successful.
io,The name was already in use or other errors occurred.
io,NOTES:
io,The device is registered as a character device.
io,Opens the device specified by the device major and minor numbers.
io,CALLING SEQUENCE:
io,PARAMETERS:
io,This parameter is the major number of the device.
io,This parameter is the minor number of the device.
io,This parameter is the argument passed to the device driver close entry.
io,DESCRIPTION:
io,This directive calls the device driver open entry registered in the Device Driver Table for the specified device major number.
io,RETURN VALUES:
io,The requested operation was successful.
io,The device major number was invalid.
io,Other status codes may be returned by the device driver open entry.
io,NOTES:
io,The open entry point is commonly used by device drivers to provide exclusive access to a device.
io,Closes the device specified by the device major and minor numbers.
io,CALLING SEQUENCE:
io,PARAMETERS:
io,This parameter is the major number of the device.
io,This parameter is the minor number of the device.
io,This parameter is the argument passed to the device driver close entry.
io,DESCRIPTION:
io,This directive calls the device driver close entry registered in the Device Driver Table for the specified device major number.
io,RETURN VALUES:
io,The requested operation was successful.
io,The device major number was invalid.
io,Other status codes may be returned by the device driver close entry.
io,NOTES:
io,The close entry point is commonly used by device drivers to relinquish exclusive access to a device.
io,Reads from the device specified by the device major and minor numbers.
io,CALLING SEQUENCE:
io,PARAMETERS:
io,This parameter is the major number of the device.
io,This parameter is the minor number of the device.
io,This parameter is the argument passed to the device driver read entry.
io,DESCRIPTION:
io,This directive calls the device driver read entry registered in the Device Driver Table for the specified device major number.
io,RETURN VALUES:
io,The requested operation was successful.
io,The device major number was invalid.
io,Other status codes may be returned by the device driver read entry.
io,NOTES:
io,Read operations typically require a buffer address as part of the argument parameter block.  The contents of this buffer will be replaced with data from the device.
io,Writes to the device specified by the device major and minor numbers.
io,CALLING SEQUENCE:
io,PARAMETERS:
io,This parameter is the major number of the device.
io,This parameter is the minor number of the device.
io,This parameter is the argument passed to the device driver write entry.
io,DESCRIPTION:
io,This directive calls the device driver write entry registered in the Device Driver Table for the specified device major number.
io,RETURN VALUES:
io,The requested operation was successful.
io,The device major number was invalid.
io,Other status codes may be returned by the device driver write entry.
io,NOTES:
io,Write operations typically require a buffer address as part of the argument parameter block.  The contents of this buffer will be sent to the device.
io,Controls the device specified by the device major and minor numbers.
io,CALLING SEQUENCE:
io,PARAMETERS:
io,This parameter is the major number of the device.
io,This parameter is the minor number of the device.
io,This parameter is the argument passed to the device driver I/O control entry.
io,DESCRIPTION:
io,This directive calls the device driver I/O control entry registered in the Device Driver Table for the specified device major number.
io,RETURN VALUES:
io,The requested operation was successful.
io,The device major number was invalid.
io,Other status codes may be returned by the device driver I/O control entry.
io,NOTES:
io,"The exact functionality of the driver entry called by this directive is driver dependent.  It should not be assumed that the control entries of two device drivers are compatible.  For example, an RS-232 driver I/O control operation may change the baud of a serial line, while an I/O control operation for a floppy disk driver may cause a seek operation."
io,"© Copyright 1988, 2024 RTEMS Project and contributors."
io,The Input/Output (I/O) Manager provides a well-defined mechanism for accessing device drivers and a structured methodology for organizing device drivers. The directives provided by the I/O Manager are:
io,rtems_io_register_driver() - Registers and initializes the device with the specified device driver address table and device major number in the Device Driver Table. rtems_io_unregister_driver() - Removes a device driver specified by the device major number from the Device Driver Table. rtems_io_initialize() - Initializes the device specified by the device major and minor numbers. rtems_io_register_name() - Registers the device specified by the device major and minor numbers in the file system under the specified name. rtems_io_open() - Opens the device specified by the device major and minor numbers. rtems_io_close() - Closes the device specified by the device major and minor numbers. rtems_io_read() - Reads from the device specified by the device major and minor numbers. rtems_io_write() - Writes to the device specified by the device major and minor numbers. rtems_io_control() - Controls the device specified by the device major and minor numbers.
io,rtems_io_register_driver() - Registers and initializes the device with the specified device driver address table and device major number in the Device Driver Table.
io,rtems_io_unregister_driver() - Removes a device driver specified by the device major number from the Device Driver Table.
io,rtems_io_initialize() - Initializes the device specified by the device major and minor numbers.
io,rtems_io_register_name() - Registers the device specified by the device major and minor numbers in the file system under the specified name.
io,rtems_io_open() - Opens the device specified by the device major and minor numbers.
io,rtems_io_close() - Closes the device specified by the device major and minor numbers.
io,rtems_io_read() - Reads from the device specified by the device major and minor numbers.
io,rtems_io_write() - Writes to the device specified by the device major and minor numbers.
io,rtems_io_control() - Controls the device specified by the device major and minor numbers.
io,"© Copyright 1988, 2024 RTEMS Project and contributors."
io,The rtems_io_register directive associates a name with the specified device (i.e. major/minor number pair).  Device names are typically registered as part of the device driver initialization sequence.  The rtems_io_lookup directive is used to determine the major/minor number pair associated with the specified device name.  The use of these directives frees the application from being dependent on the arbitrary assignment of major numbers in a particular application.  No device naming conventions are dictated by RTEMS.
io,"The I/O manager provides directives which enable the application program to utilize device drivers in a standard manner.  There is a direct correlation between the RTEMS I/O manager directives rtems_io_initialize, rtems_io_open, rtems_io_close, rtems_io_read, rtems_io_write, and rtems_io_control and the underlying device driver entry points."
io,"© Copyright 1988, 2024 RTEMS Project and contributors."
kernel-character-io,"This section details the directives of the Kernel Character I/O Support. A subsection is dedicated to each of this manager’s directives and lists the calling sequence, parameters, description, return values, and notes of the directive."
kernel-character-io,Outputs the character to the kernel character output device.
kernel-character-io,CALLING SEQUENCE:
kernel-character-io,PARAMETERS:
kernel-character-io,This parameter is the character to output.
kernel-character-io,DESCRIPTION:
kernel-character-io,The directive outputs the character specified by c to the kernel character output device using the polled character output implementation provided by BSP_output_char.  The directive performs a character translation from NL to CR followed by NR.
kernel-character-io,"If the kernel character output device is concurrently accessed, then interleaved output may occur."
kernel-character-io,CONSTRAINTS:
kernel-character-io,The following constraints apply to this directive:
kernel-character-io,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
kernel-character-io,The directive may be called from within any runtime context.
kernel-character-io,The directive will not cause the calling task to be preempted.
kernel-character-io,Puts the character using rtems_putc()
kernel-character-io,CALLING SEQUENCE:
kernel-character-io,PARAMETERS:
kernel-character-io,This parameter is the character to output.
kernel-character-io,This parameter is an unused argument.
kernel-character-io,NOTES:
kernel-character-io,The directive is provided to support the RTEMS Testing Framework.
kernel-character-io,CONSTRAINTS:
kernel-character-io,The following constraints apply to this directive:
kernel-character-io,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
kernel-character-io,The directive may be called from within any runtime context.
kernel-character-io,The directive will not cause the calling task to be preempted.
kernel-character-io,Outputs the characters of the string and a newline character to the kernel character output device.
kernel-character-io,CALLING SEQUENCE:
kernel-character-io,PARAMETERS:
kernel-character-io,This parameter is the string to output.
kernel-character-io,RETURN VALUES:
kernel-character-io,Returns the number of characters output to the kernel character output device.
kernel-character-io,NOTES:
kernel-character-io,The directive may be used to print debug and test information.  It uses rtems_putc() to output the characters.  This directive performs a character translation from NL to CR followed by NR.
kernel-character-io,"If the kernel character output device is concurrently accessed, then interleaved output may occur."
kernel-character-io,CONSTRAINTS:
kernel-character-io,The following constraints apply to this directive:
kernel-character-io,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
kernel-character-io,The directive may be called from within any runtime context.
kernel-character-io,The directive will not cause the calling task to be preempted.
kernel-character-io,Outputs the characters defined by the format string and the arguments to the kernel character output device.
kernel-character-io,CALLING SEQUENCE:
kernel-character-io,PARAMETERS:
kernel-character-io,This parameter is a printf()-style format string.
kernel-character-io,This parameter is a list of optional parameters required by the format string.
kernel-character-io,RETURN VALUES:
kernel-character-io,Returns the number of characters output to the kernel character output device.
kernel-character-io,NOTES:
kernel-character-io,The directive may be used to print debug and test information.  It uses rtems_putc() to output the characters.  This directive performs a character translation from NL to CR followed by NR.
kernel-character-io,"If the kernel character output device is concurrently accessed, then interleaved output may occur."
kernel-character-io,CONSTRAINTS:
kernel-character-io,The following constraints apply to this directive:
kernel-character-io,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. Formatting of floating point numbers is not supported.
kernel-character-io,The directive may be called from within any runtime context.
kernel-character-io,The directive will not cause the calling task to be preempted.
kernel-character-io,Formatting of floating point numbers is not supported.
kernel-character-io,Outputs the characters defined by the format string and the variable argument list to the kernel character output device.
kernel-character-io,CALLING SEQUENCE:
kernel-character-io,PARAMETERS:
kernel-character-io,This parameter is a printf()-style format string.
kernel-character-io,This parameter is the variable argument list required by the format string.
kernel-character-io,RETURN VALUES:
kernel-character-io,Returns the number of characters output to the kernel character output device.
kernel-character-io,NOTES:
kernel-character-io,The directive may be used to print debug and test information.  It uses rtems_putc() to output the characters.  This directive performs a character translation from NL to CR followed by NR.
kernel-character-io,"If the kernel character output device is concurrently accessed, then interleaved output may occur."
kernel-character-io,CONSTRAINTS:
kernel-character-io,The following constraints apply to this directive:
kernel-character-io,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. Formatting of floating point numbers is not supported.
kernel-character-io,The directive may be called from within any runtime context.
kernel-character-io,The directive will not cause the calling task to be preempted.
kernel-character-io,Formatting of floating point numbers is not supported.
kernel-character-io,Outputs the characters defined by the format string and the variable argument list to the kernel character output device.
kernel-character-io,CALLING SEQUENCE:
kernel-character-io,PARAMETERS:
kernel-character-io,This parameter is an unused argument.
kernel-character-io,This parameter is a printf()-style format string.
kernel-character-io,This parameter is the variable argument list required by the format string.
kernel-character-io,RETURN VALUES:
kernel-character-io,Returns the number of characters output to the kernel character output device.
kernel-character-io,NOTES:
kernel-character-io,The directive may be used to print debug and test information.  It uses rtems_putc() to output the characters.  This directive performs a character translation from NL to CR followed by NR.
kernel-character-io,"If the kernel character output device is concurrently accessed, then interleaved output may occur."
kernel-character-io,CONSTRAINTS:
kernel-character-io,The following constraints apply to this directive:
kernel-character-io,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted. Formatting of floating point numbers is not supported.
kernel-character-io,The directive may be called from within any runtime context.
kernel-character-io,The directive will not cause the calling task to be preempted.
kernel-character-io,Formatting of floating point numbers is not supported.
kernel-character-io,Tries to dequeue a character from the kernel character input device.
kernel-character-io,CALLING SEQUENCE:
kernel-character-io,DESCRIPTION:
kernel-character-io,The directive tries to dequeue a character from the kernel character input device using the polled character input implementation referenced by BSP_poll_char if it is available.
kernel-character-io,RETURN VALUES:
kernel-character-io,The BSP_poll_char pointer was equal to NULL.
kernel-character-io,There was no character enqueued on the kernel character input device.
kernel-character-io,Returns the character least recently enqueued on the kernel character input device as an unsigned character value.
kernel-character-io,CONSTRAINTS:
kernel-character-io,The following constraints apply to this directive:
kernel-character-io,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
kernel-character-io,The directive may be called from within any runtime context.
kernel-character-io,The directive will not cause the calling task to be preempted.
kernel-character-io,"© Copyright 1988, 2024 RTEMS Project and contributors."
kernel-character-io,The kernel character input/output support is an extension of the I/O Manager to output characters to the kernel character output device and receive characters from the kernel character input device using a polled and non-blocking implementation.
kernel-character-io,"The directives may be used to print debug and test information.  The kernel character input/output support should work even if no Console Driver is configured, see CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER.  The kernel character input and output device is provided by the BSP. Applications may change the device. The directives provided by the Kernel Character I/O Support are:"
kernel-character-io,rtems_putc() - Outputs the character to the kernel character output device. rtems_put_char() - Puts the character using rtems_putc() putk() - Outputs the characters of the string and a newline character to the kernel character output device. printk() - Outputs the characters defined by the format string and the arguments to the kernel character output device. vprintk() - Outputs the characters defined by the format string and the variable argument list to the kernel character output device. rtems_printk_printer() - Outputs the characters defined by the format string and the variable argument list to the kernel character output device. getchark() - Tries to dequeue a character from the kernel character input device.
kernel-character-io,rtems_putc() - Outputs the character to the kernel character output device.
kernel-character-io,rtems_put_char() - Puts the character using rtems_putc()
kernel-character-io,putk() - Outputs the characters of the string and a newline character to the kernel character output device.
kernel-character-io,printk() - Outputs the characters defined by the format string and the arguments to the kernel character output device.
kernel-character-io,vprintk() - Outputs the characters defined by the format string and the variable argument list to the kernel character output device.
kernel-character-io,rtems_printk_printer() - Outputs the characters defined by the format string and the variable argument list to the kernel character output device.
kernel-character-io,getchark() - Tries to dequeue a character from the kernel character input device.
kernel-character-io,"© Copyright 1988, 2024 RTEMS Project and contributors."
message,"A message is a variable length buffer where information can be stored to support communication.  The length of the message and the information stored in that message are user-defined and can be actual data, pointer(s), or empty."
message,"A message queue permits the passing of messages among tasks and ISRs.  Message queues can contain a variable number of messages.  Normally messages are sent to and received from the queue in FIFO order using the rtems_message_queue_send directive.  However, the rtems_message_queue_urgent directive can be used to place messages at the head of a queue in LIFO order."
message,"Synchronization can be accomplished when a task can wait for a message to arrive at a queue.  Also, a task may poll a queue for the arrival of a message."
message,The maximum length message which can be sent is set on a per message queue basis.  The message content must be copied in general to/from an internal buffer of the message queue or directly to a peer in certain cases.  This copy operation is performed with interrupts disabled.  So it is advisable to keep the messages as short as possible.
message,"In general, an attribute set is built by a bitwise OR of the desired attribute components.  The set of valid message queue attributes is provided in the following table:"
message,RTEMS_FIFO tasks wait by FIFO (default) RTEMS_PRIORITY tasks wait by priority RTEMS_LOCAL local message queue (default) RTEMS_GLOBAL global message queue
message,RTEMS_FIFO
message,tasks wait by FIFO (default)
message,RTEMS_PRIORITY
message,tasks wait by priority
message,RTEMS_LOCAL
message,local message queue (default)
message,RTEMS_GLOBAL
message,global message queue
message,"An attribute listed as a default is not required to appear in the attribute list, although it is a good programming practice to specify default attributes. If all defaults are desired, the attribute RTEMS_DEFAULT_ATTRIBUTES should be specified on this call."
message,"This example demonstrates the attribute_set parameter needed to create a local message queue with the task priority waiting queue discipline.  The attribute_set parameter to the rtems_message_queue_create directive could be either RTEMS_PRIORITY or RTEMS_LOCAL | RTEMS_PRIORITY.  The attribute_set parameter can be set to RTEMS_PRIORITY because RTEMS_LOCAL is the default for all created message queues.  If a similar message queue were to be known globally, then the attribute_set parameter would be RTEMS_GLOBAL | RTEMS_PRIORITY."
message,"In general, an option is built by a bitwise OR of the desired option components.  The set of valid options for the rtems_message_queue_receive directive are listed in the following table:"
message,RTEMS_WAIT task will wait for a message (default) RTEMS_NO_WAIT task should not wait
message,RTEMS_WAIT
message,task will wait for a message (default)
message,RTEMS_NO_WAIT
message,task should not wait
message,"An option listed as a default is not required to appear in the option OR list, although it is a good programming practice to specify default options.  If all defaults are desired, the option RTEMS_DEFAULT_OPTIONS should be specified on this call."
message,This example demonstrates the option parameter needed to poll for a message to arrive.  The option parameter passed to the rtems_message_queue_receive directive should be RTEMS_NO_WAIT.
message,"© Copyright 1988, 2024 RTEMS Project and contributors."
message,"This section details the directives of the Message Manager. A subsection is dedicated to each of this manager’s directives and lists the calling sequence, parameters, description, return values, and notes of the directive."
message,Creates a message queue.
message,CALLING SEQUENCE:
message,PARAMETERS:
message,This parameter is the object name of the message queue.
message,This parameter is the maximum count of pending messages supported by the message queue.
message,This parameter is the maximum size in bytes of a message supported by the message queue.
message,This parameter is the attribute set of the message queue.
message,"This parameter is the pointer to an rtems_id object.  When the directive call is successful, the identifier of the created message queue will be stored in this object."
message,DESCRIPTION:
message,"This directive creates a message queue which resides on the local node.  The message queue has the user-defined object name specified in name.  Memory is allocated from the RTEMS Workspace for the count of messages specified in count, each of max_message_size bytes in length.  The assigned object identifier is returned in id.  This identifier is used to access the message queue with other message queue related directives."
message,"The attribute set specified in attribute_set is built through a bitwise or of the attribute constants described below.  Not all combinations of attributes are allowed.  Some attributes are mutually exclusive.  If mutually exclusive attributes are combined, the behaviour is undefined. Attributes not mentioned below are not evaluated by this directive and have no effect.  Default attributes can be selected by using the RTEMS_DEFAULT_ATTRIBUTES constant.  The attribute set defines"
message,the scope of the message queue: RTEMS_LOCAL (default) or RTEMS_GLOBAL and the task wait queue discipline used by the message queue: RTEMS_FIFO (default) or RTEMS_PRIORITY.
message,the scope of the message queue: RTEMS_LOCAL (default) or RTEMS_GLOBAL and
message,the task wait queue discipline used by the message queue: RTEMS_FIFO (default) or RTEMS_PRIORITY.
message,The message queue has a local or global scope in a multiprocessing network (this attribute does not refer to SMP systems).  The scope is selected by the mutually exclusive RTEMS_LOCAL and RTEMS_GLOBAL attributes.
message,A local scope is the default and can be emphasized through the use of the RTEMS_LOCAL attribute.  A local message queue can be only used by the node which created it. A global scope is established if the RTEMS_GLOBAL attribute is set.  Setting the global attribute in a single node system has no effect.
message,A local scope is the default and can be emphasized through the use of the RTEMS_LOCAL attribute.  A local message queue can be only used by the node which created it.
message,A global scope is established if the RTEMS_GLOBAL attribute is set.  Setting the global attribute in a single node system has no effect.
message,The task wait queue discipline is selected by the mutually exclusive RTEMS_FIFO and RTEMS_PRIORITY attributes. The discipline defines the order in which tasks wait for a message to receive on a currently empty message queue.
message,The FIFO discipline is the default and can be emphasized through use of the RTEMS_FIFO attribute. The priority discipline is selected by the RTEMS_PRIORITY attribute.
message,The FIFO discipline is the default and can be emphasized through use of the RTEMS_FIFO attribute.
message,The priority discipline is selected by the RTEMS_PRIORITY attribute.
message,RETURN VALUES:
message,The requested operation was successful.
message,The name parameter was invalid.
message,The id parameter was NULL.
message,The count parameter was invalid.
message,The max_message_size parameter was invalid.
message,There was no inactive object available to create a message queue.  The number of message queue available to the application is configured through the CONFIGURE_MAXIMUM_MESSAGE_QUEUES application configuration option.
message,"In multiprocessing configurations, there was no inactive global object available to create a global message queue.  The number of global objects available to the application is configured through the CONFIGURE_MP_MAXIMUM_GLOBAL_OBJECTS application configuration option."
message,The product of count and max_message_size is greater than the maximum storage size.
message,There was not enough memory available in the RTEMS Workspace to allocate the message buffers for the message queue.
message,NOTES:
message,"For message queues with a global scope, the maximum message size is effectively limited to the longest message which the MPCI is capable of transmitting."
message,"For control and maintenance of the message queue, RTEMS allocates a QCB from the local QCB free pool and initializes it."
message,"The QCB for a global message queue is allocated on the local node.  Message queues should not be made global unless remote tasks must interact with the message queue.  This is to avoid the system overhead incurred by the creation of a global message queue.  When a global message queue is created, the message queue’s name and identifier must be transmitted to every node in the system for insertion in the local copy of the global object table."
message,CONSTRAINTS:
message,The following constraints apply to this directive:
message,"The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted. When the directive operates on a global object, the directive sends a message to remote nodes.  This may preempt the calling task. The number of message queues available to the application is configured through the CONFIGURE_MAXIMUM_MESSAGE_QUEUES application configuration option. Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace. The number of global objects available to the application is configured through the CONFIGURE_MP_MAXIMUM_GLOBAL_OBJECTS application configuration option."
message,The directive may be called from within device driver initialization context.
message,The directive may be called from within task context.
message,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
message,"When the directive operates on a global object, the directive sends a message to remote nodes.  This may preempt the calling task."
message,The number of message queues available to the application is configured through the CONFIGURE_MAXIMUM_MESSAGE_QUEUES application configuration option.
message,"Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace."
message,The number of global objects available to the application is configured through the CONFIGURE_MP_MAXIMUM_GLOBAL_OBJECTS application configuration option.
message,Constructs a message queue from the specified the message queue configuration.
message,CALLING SEQUENCE:
message,PARAMETERS:
message,This parameter is the pointer to an rtems_message_queue_config object.  It configures the message queue.
message,"This parameter is the pointer to an rtems_id object.  When the directive call is successful, the identifier of the constructed message queue will be stored in this object."
message,RETURN VALUES:
message,The requested operation was successful.
message,The config parameter was NULL.
message,The message queue name in the configuration was invalid.
message,The id parameter was NULL.
message,The maximum number of pending messages in the configuration was zero.
message,The maximum message size in the configuration was zero.
message,There was no inactive message queue object available to construct a message queue.
message,"In multiprocessing configurations, there was no inactive global object available to construct a global message queue."
message,The maximum message size in the configuration was too big and resulted in integer overflows in calculations carried out to determine the size of the message buffer area.
message,The maximum number of pending messages in the configuration was too big and resulted in integer overflows in calculations carried out to determine the size of the message buffer area.
message,The message queue storage area begin pointer in the configuration was NULL.
message,The message queue storage area size in the configuration was not equal to the size calculated from the maximum number of pending messages and the maximum message size.
message,NOTES:
message,"In contrast to message queues created by rtems_message_queue_create(), the message queues constructed by this directive use a user-provided message buffer storage area."
message,This directive is intended for applications which do not want to use the RTEMS Workspace and instead statically allocate all operating system resources.  An application based solely on static allocation can avoid any runtime memory allocators.  This can simplify the application architecture as well as any analysis that may be required.
message,The value for CONFIGURE_MESSAGE_BUFFER_MEMORY should not include memory for message queues constructed by rtems_message_queue_construct().
message,CONSTRAINTS:
message,The following constraints apply to this directive:
message,"The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted. When the directive operates on a global object, the directive sends a message to remote nodes.  This may preempt the calling task. The number of message queues available to the application is configured through the CONFIGURE_MAXIMUM_MESSAGE_QUEUES application configuration option. Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace. The number of global objects available to the application is configured through the CONFIGURE_MP_MAXIMUM_GLOBAL_OBJECTS application configuration option."
message,The directive may be called from within device driver initialization context.
message,The directive may be called from within task context.
message,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
message,"When the directive operates on a global object, the directive sends a message to remote nodes.  This may preempt the calling task."
message,The number of message queues available to the application is configured through the CONFIGURE_MAXIMUM_MESSAGE_QUEUES application configuration option.
message,"Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace."
message,The number of global objects available to the application is configured through the CONFIGURE_MP_MAXIMUM_GLOBAL_OBJECTS application configuration option.
message,Identifies a message queue by the object name.
message,CALLING SEQUENCE:
message,PARAMETERS:
message,This parameter is the object name to look up.
message,This parameter is the node or node set to search for a matching object.
message,"This parameter is the pointer to an rtems_id object.  When the directive call is successful, the object identifier of an object with the specified name will be stored in this object."
message,DESCRIPTION:
message,This directive obtains a message queue identifier associated with the message queue name specified in name.
message,The node to search is specified in node.  It shall be
message,"a valid node number, the constant RTEMS_SEARCH_ALL_NODES to search in all nodes, the constant RTEMS_SEARCH_LOCAL_NODE to search in the local node only, or the constant RTEMS_SEARCH_OTHER_NODES to search in all nodes except the local node."
message,"a valid node number,"
message,"the constant RTEMS_SEARCH_ALL_NODES to search in all nodes,"
message,"the constant RTEMS_SEARCH_LOCAL_NODE to search in the local node only, or"
message,the constant RTEMS_SEARCH_OTHER_NODES to search in all nodes except the local node.
message,RETURN VALUES:
message,The requested operation was successful.
message,The id parameter was NULL.
message,The name parameter was 0.
message,There was no object with the specified name on the specified nodes.
message,"In multiprocessing configurations, the specified node was invalid."
message,NOTES:
message,"If the message queue name is not unique, then the message queue identifier will match the first message queue with that name in the search order. However, this message queue identifier is not guaranteed to correspond to the desired message queue."
message,"The objects are searched from lowest to the highest index.  If node is RTEMS_SEARCH_ALL_NODES, all nodes are searched with the local node being searched first.  All other nodes are searched from lowest to the highest node number."
message,"If node is a valid node number which does not represent the local node, then only the message queues exported by the designated node are searched."
message,This directive does not generate activity on remote nodes.  It accesses only the local copy of the global object table.
message,The message queue identifier is used with other message related directives to access the message queue.
message,CONSTRAINTS:
message,The following constraints apply to this directive:
message,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
message,The directive may be called from within any runtime context.
message,The directive will not cause the calling task to be preempted.
message,Deletes the message queue.
message,CALLING SEQUENCE:
message,PARAMETERS:
message,This parameter is the message queue identifier.
message,DESCRIPTION:
message,"This directive deletes the message queue specified by id. As a result of this directive, all tasks blocked waiting to receive a message from this queue will be readied and returned a status code which indicates that the message queue was deleted."
message,RETURN VALUES:
message,The requested operation was successful.
message,There was no message queue associated with the identifier specified by id.
message,The message queue resided on a remote node.
message,NOTES:
message,"When the message queue is deleted, any messages in the queue are returned to the free message buffer pool.  Any information stored in those messages is lost.  The message buffers allocated for the message queue are reclaimed."
message,The QCB for the deleted message queue is reclaimed by RTEMS.
message,"When a global message queue is deleted, the message queue identifier must be transmitted to every node in the system for deletion from the local copy of the global object table."
message,"The message queue must reside on the local node, even if the message queue was created with the RTEMS_GLOBAL attribute."
message,"Proxies, used to represent remote tasks, are reclaimed when the message queue is deleted."
message,CONSTRAINTS:
message,The following constraints apply to this directive:
message,"The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted. When the directive operates on a global object, the directive sends a message to remote nodes.  This may preempt the calling task. The calling task does not have to be the task that created the object.  Any local task that knows the object identifier can delete the object. Where the object class corresponding to the directive is configured to use unlimited objects, the directive may free memory to the RTEMS Workspace."
message,The directive may be called from within device driver initialization context.
message,The directive may be called from within task context.
message,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
message,"When the directive operates on a global object, the directive sends a message to remote nodes.  This may preempt the calling task."
message,The calling task does not have to be the task that created the object.  Any local task that knows the object identifier can delete the object.
message,"Where the object class corresponding to the directive is configured to use unlimited objects, the directive may free memory to the RTEMS Workspace."
message,Puts the message at the rear of the queue.
message,CALLING SEQUENCE:
message,PARAMETERS:
message,This parameter is the queue identifier.
message,This parameter is the begin address of the message buffer to send.
message,This parameter is the size in bytes of the message buffer to send.
message,DESCRIPTION:
message,"This directive sends the message buffer of size bytes in length to the queue specified by id.  If a task is waiting at the queue, then the message is copied to the waiting task’s buffer and the task is unblocked. If no tasks are waiting at the queue, then the message is copied to a message buffer which is obtained from this message queue’s message buffer pool.  The message buffer is then placed at the rear of the queue."
message,RETURN VALUES:
message,The requested operation was successful.
message,There was no queue associated with the identifier specified by id.
message,The buffer parameter was NULL.
message,The size of the message exceeded the maximum message size of the queue as defined by rtems_message_queue_create() or rtems_message_queue_construct().
message,The maximum number of pending messages supported by the queue as defined by rtems_message_queue_create() or rtems_message_queue_construct() has been reached.
message,CONSTRAINTS:
message,The following constraints apply to this directive:
message,"The directive may be called from within task context. The directive may be called from within interrupt context. The directive may unblock a task.  This may cause the calling task to be preempted. When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply.  This will preempt the calling task."
message,The directive may be called from within task context.
message,The directive may be called from within interrupt context.
message,The directive may unblock a task.  This may cause the calling task to be preempted.
message,"When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply.  This will preempt the calling task."
message,Puts the message at the front of the queue.
message,CALLING SEQUENCE:
message,PARAMETERS:
message,This parameter is the queue identifier.
message,This parameter is the begin address of the message buffer to send urgently.
message,This parameter is the size in bytes of the message buffer to send urgently.
message,DESCRIPTION:
message,"This directive sends the message buffer of size bytes in length to the queue specified by id.  If a task is waiting at the queue, then the message is copied to the waiting task’s buffer and the task is unblocked. If no tasks are waiting at the queue, then the message is copied to a message buffer which is obtained from this message queue’s message buffer pool.  The message buffer is then placed at the front of the queue."
message,RETURN VALUES:
message,The requested operation was successful.
message,There was no queue associated with the identifier specified by id.
message,The buffer parameter was NULL.
message,The size of the message exceeded the maximum message size of the queue as defined by rtems_message_queue_create() or rtems_message_queue_construct().
message,The maximum number of pending messages supported by the queue as defined by rtems_message_queue_create() or rtems_message_queue_construct() has been reached.
message,CONSTRAINTS:
message,The following constraints apply to this directive:
message,"The directive may be called from within task context. The directive may be called from within interrupt context. The directive may unblock a task.  This may cause the calling task to be preempted. When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply.  This will preempt the calling task."
message,The directive may be called from within task context.
message,The directive may be called from within interrupt context.
message,The directive may unblock a task.  This may cause the calling task to be preempted.
message,"When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply.  This will preempt the calling task."
message,Broadcasts the messages to the tasks waiting at the queue.
message,CALLING SEQUENCE:
message,PARAMETERS:
message,This parameter is the queue identifier.
message,This parameter is the begin address of the message buffer to broadcast.
message,This parameter is the size in bytes of the message buffer to broadcast.
message,"This parameter is the pointer to an uint32_t object.  When the directive call is successful, the number of unblocked tasks will be stored in this object."
message,DESCRIPTION:
message,"This directive causes all tasks that are waiting at the queue specified by id to be unblocked and sent the message contained in buffer.  Before a task is unblocked, the message buffer of size bytes in length is copied to that task’s message buffer.  The number of tasks that were unblocked is returned in count."
message,RETURN VALUES:
message,The requested operation was successful.
message,There was no queue associated with the identifier specified by id.
message,The buffer parameter was NULL.
message,The count parameter was NULL.
message,The size of the message exceeded the maximum message size of the queue as defined by rtems_message_queue_create() or rtems_message_queue_construct().
message,NOTES:
message,"The execution time of this directive is directly related to the number of tasks waiting on the message queue, although it is more efficient than the equivalent number of invocations of rtems_message_queue_send()."
message,CONSTRAINTS:
message,The following constraints apply to this directive:
message,"The directive may be called from within task context. The directive may be called from within interrupt context. The directive may unblock a task.  This may cause the calling task to be preempted. When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply.  This will preempt the calling task."
message,The directive may be called from within task context.
message,The directive may be called from within interrupt context.
message,The directive may unblock a task.  This may cause the calling task to be preempted.
message,"When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply.  This will preempt the calling task."
message,Receives a message from the queue.
message,CALLING SEQUENCE:
message,PARAMETERS:
message,This parameter is the queue identifier.
message,This parameter is the begin address of the buffer to receive the message. The buffer shall be large enough to receive a message of the maximum length of the queue as defined by rtems_message_queue_create() or rtems_message_queue_construct().  The size parameter cannot be used to specify the size of the buffer.
message,"This parameter is the pointer to a size_t object.  When the directive call is successful, the size in bytes of the received messages will be stored in this object.  This parameter cannot be used to specify the size of the buffer."
message,This parameter is the option set.
message,This parameter is the timeout in clock ticks if the RTEMS_WAIT option is set.  Use RTEMS_NO_TIMEOUT to wait potentially forever.
message,DESCRIPTION:
message,This directive receives a message from the queue specified by id.
message,"The option set specified in option_set is built through a bitwise or of the option constants described below.  Not all combinations of options are allowed.  Some options are mutually exclusive.  If mutually exclusive options are combined, the behaviour is undefined.  Options not mentioned below are not evaluated by this directive and have no effect. Default options can be selected by using the RTEMS_DEFAULT_OPTIONS constant."
message,The calling task can wait or try to receive a message from the queue according to the mutually exclusive RTEMS_WAIT and RTEMS_NO_WAIT options.
message,"Waiting to receive a message from the queue is the default and can be emphasized through the use of the RTEMS_WAIT option. The timeout parameter defines how long the calling task is willing to wait. Use RTEMS_NO_TIMEOUT to wait potentially forever, otherwise set a timeout interval in clock ticks. Trying to receive a message from the queue is selected by the RTEMS_NO_WAIT option.  If this option is defined, then the timeout parameter is ignored.  When a message from the queue cannot be immediately received, then the RTEMS_UNSATISFIED status is returned."
message,"Waiting to receive a message from the queue is the default and can be emphasized through the use of the RTEMS_WAIT option. The timeout parameter defines how long the calling task is willing to wait. Use RTEMS_NO_TIMEOUT to wait potentially forever, otherwise set a timeout interval in clock ticks."
message,"Trying to receive a message from the queue is selected by the RTEMS_NO_WAIT option.  If this option is defined, then the timeout parameter is ignored.  When a message from the queue cannot be immediately received, then the RTEMS_UNSATISFIED status is returned."
message,"With either RTEMS_WAIT or RTEMS_NO_WAIT if there is at least one message in the queue, then it is copied to the buffer, the size is set to return the length of the message in bytes, and this directive returns immediately with the RTEMS_SUCCESSFUL status code.  The buffer has to be big enough to receive a message of the maximum length with respect to this message queue."
message,"If the calling task chooses to return immediately and the queue is empty, then the directive returns immediately with the RTEMS_UNSATISFIED status code.  If the calling task chooses to wait at the message queue and the queue is empty, then the calling task is placed on the message wait queue and blocked.  If the queue was created with the RTEMS_PRIORITY option specified, then the calling task is inserted into the wait queue according to its priority.  But, if the queue was created with the RTEMS_FIFO option specified, then the calling task is placed at the rear of the wait queue."
message,RETURN VALUES:
message,The requested operation was successful.
message,There was no queue associated with the identifier specified by id.
message,The buffer parameter was NULL.
message,The size parameter was NULL.
message,The queue was empty.
message,The timeout happened while the calling task was waiting to receive a message
message,The queue was deleted while the calling task was waiting to receive a message.
message,CONSTRAINTS:
message,The following constraints apply to this directive:
message,"When a local queue is accessed and the RTEMS_NO_WAIT option is set, the directive may be called from within interrupt context. The directive may be called from within task context. When the request cannot be immediately satisfied and the RTEMS_WAIT option is set, the calling task blocks at some point during the directive call. The timeout functionality of the directive requires a clock tick. When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply.  This will preempt the calling task."
message,"When a local queue is accessed and the RTEMS_NO_WAIT option is set, the directive may be called from within interrupt context."
message,The directive may be called from within task context.
message,"When the request cannot be immediately satisfied and the RTEMS_WAIT option is set, the calling task blocks at some point during the directive call."
message,The timeout functionality of the directive requires a clock tick.
message,"When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply.  This will preempt the calling task."
message,Gets the number of messages pending on the queue.
message,CALLING SEQUENCE:
message,PARAMETERS:
message,This parameter is the queue identifier.
message,"This parameter is the pointer to an uint32_t object.  When the directive call is successful, the number of pending messages will be stored in this object."
message,DESCRIPTION:
message,"This directive returns the number of messages pending on the queue specified by id in count.  If no messages are present on the queue, count is set to zero."
message,RETURN VALUES:
message,The requested operation was successful.
message,There was no queue associated with the identifier specified by id.
message,The count parameter was NULL.
message,CONSTRAINTS:
message,The following constraints apply to this directive:
message,"The directive may be called from within task context. The directive may be called from within interrupt context. When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply.  This will preempt the calling task."
message,The directive may be called from within task context.
message,The directive may be called from within interrupt context.
message,"When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply.  This will preempt the calling task."
message,Flushes all messages on the queue.
message,CALLING SEQUENCE:
message,PARAMETERS:
message,This parameter is the queue identifier.
message,"This parameter is the pointer to an uint32_t object.  When the directive call is successful, the number of pending messages removed from the queue will be stored in this object."
message,DESCRIPTION:
message,"This directive removes all pending messages from the queue specified by id. The number of messages removed is returned in count.  If no messages are present on the queue, count is set to zero."
message,RETURN VALUES:
message,The requested operation was successful.
message,There was no queue associated with the identifier specified by id.
message,The count parameter was NULL.
message,NOTES:
message,The directive does not flush tasks waiting to receive a message from the wait queue of the message queue.
message,CONSTRAINTS:
message,The following constraints apply to this directive:
message,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive will not cause the calling task to be preempted.
message,The directive may be called from within interrupt context.
message,The directive may be called from within device driver initialization context.
message,The directive may be called from within task context.
message,The directive will not cause the calling task to be preempted.
message,Defines a structure which can be used as a message queue buffer for messages of the specified maximum size.
message,CALLING SEQUENCE:
message,PARAMETERS:
message,This parameter is the maximum message size in bytes.
message,NOTES:
message,Use this macro to define the message buffer storage area for rtems_message_queue_construct().
message,"© Copyright 1988, 2024 RTEMS Project and contributors."
message,The Message Manager provides communication and synchronization capabilities using RTEMS message queues. The directives provided by the Message Manager are:
message,rtems_message_queue_create() - Creates a message queue. rtems_message_queue_construct() - Constructs a message queue from the specified the message queue configuration. rtems_message_queue_ident() - Identifies a message queue by the object name. rtems_message_queue_delete() - Deletes the message queue. rtems_message_queue_send() - Puts the message at the rear of the queue. rtems_message_queue_urgent() - Puts the message at the front of the queue. rtems_message_queue_broadcast() - Broadcasts the messages to the tasks waiting at the queue. rtems_message_queue_receive() - Receives a message from the queue. rtems_message_queue_get_number_pending() - Gets the number of messages pending on the queue. rtems_message_queue_flush() - Flushes all messages on the queue. RTEMS_MESSAGE_QUEUE_BUFFER() - Defines a structure which can be used as a message queue buffer for messages of the specified maximum size.
message,rtems_message_queue_create() - Creates a message queue.
message,rtems_message_queue_construct() - Constructs a message queue from the specified the message queue configuration.
message,rtems_message_queue_ident() - Identifies a message queue by the object name.
message,rtems_message_queue_delete() - Deletes the message queue.
message,rtems_message_queue_send() - Puts the message at the rear of the queue.
message,rtems_message_queue_urgent() - Puts the message at the front of the queue.
message,rtems_message_queue_broadcast() - Broadcasts the messages to the tasks waiting at the queue.
message,rtems_message_queue_receive() - Receives a message from the queue.
message,rtems_message_queue_get_number_pending() - Gets the number of messages pending on the queue.
message,rtems_message_queue_flush() - Flushes all messages on the queue.
message,RTEMS_MESSAGE_QUEUE_BUFFER() - Defines a structure which can be used as a message queue buffer for messages of the specified maximum size.
message,"© Copyright 1988, 2024 RTEMS Project and contributors."
message,The rtems_message_queue_create directive creates a message queue with the user-defined name.  The user specifies the maximum message size and maximum number of messages which can be placed in the message queue at one time.  The user may select FIFO or task priority as the method for placing waiting tasks in the task wait queue.  RTEMS allocates a Queue Control Block (QCB) from the QCB free list to maintain the newly created queue as well as memory for the message buffer pool associated with this message queue.  RTEMS also generates a message queue ID which is returned to the calling task.
message,"For GLOBAL message queues, the maximum message size is effectively limited to the longest message which the MPCI is capable of transmitting."
message,"When a message queue is created, RTEMS generates a unique message queue ID. The message queue ID may be obtained by either of two methods.  First, as the result of an invocation of the rtems_message_queue_create directive, the queue ID is stored in a user provided location.  Second, the queue ID may be obtained later using the rtems_message_queue_ident directive.  The queue ID is used by other message manager directives to access this message queue."
message,"The rtems_message_queue_receive directive attempts to retrieve a message from the specified message queue.  If at least one message is in the queue, then the message is removed from the queue, copied to the caller’s message buffer, and returned immediately along with the length of the message.  When messages are unavailable, one of the following situations applies:"
message,"By default, the calling task will wait forever for the message to arrive. Specifying the RTEMS_NO_WAIT option forces an immediate return with an error status code. Specifying a timeout limits the period the task will wait before returning with an error status."
message,"By default, the calling task will wait forever for the message to arrive."
message,Specifying the RTEMS_NO_WAIT option forces an immediate return with an error status code.
message,Specifying a timeout limits the period the task will wait before returning with an error status.
message,"If the task waits for a message, then it is placed in the message queue’s task wait queue in either FIFO or task priority order.  All tasks waiting on a message queue are returned an error code when the message queue is deleted."
message,"Messages can be sent to a queue with the rtems_message_queue_send and rtems_message_queue_urgent directives.  These directives work identically when tasks are waiting to receive a message.  A task is removed from the task waiting queue, unblocked, and the message is copied to a waiting task’s message buffer."
message,"When no tasks are waiting at the queue, rtems_message_queue_send places the message at the rear of the message queue, while rtems_message_queue_urgent places the message at the front of the queue.  The message is copied to a message buffer from this message queue’s buffer pool and then placed in the message queue.  Neither directive can successfully send a message to a message queue which has a full queue of pending messages."
message,The rtems_message_queue_broadcast directive sends the same message to every task waiting on the specified message queue as an atomic operation.  The message is copied to each waiting task’s message buffer and each task is unblocked.  The number of tasks which were unblocked is returned to the caller.
message,"The rtems_message_queue_delete directive removes a message queue from the system and frees its control block as well as the memory associated with this message queue’s message buffer pool.  A message queue can be deleted by any local task that knows the message queue’s ID.  As a result of this directive, all tasks blocked waiting to receive a message from the message queue will be readied and returned a status code which indicates that the message queue was deleted.  Any subsequent references to the message queue’s name and ID are invalid.  Any messages waiting at the message queue are also deleted and deallocated."
message,"© Copyright 1988, 2024 RTEMS Project and contributors."
multiprocessing,"RTEMS makes no assumptions regarding the connection media or topology of a multiprocessor system.  The tasks which compose a particular application can be spread among as many processors as needed to satisfy the application’s timing requirements.  The application tasks can interact using a subset of the RTEMS directives as if they were on the same processor.  These directives allow application tasks to exchange data, communicate, and synchronize regardless of which processor they reside upon."
multiprocessing,"The RTEMS multiprocessor execution model is multiple instruction streams with multiple data streams (MIMD).  This execution model has each of the processors executing code independent of the other processors.  Because of this parallelism, the application designer can more easily guarantee deterministic behavior."
multiprocessing,"By supporting heterogeneous environments, RTEMS allows the systems designer to select the most efficient processor for each subsystem of the application. Configuring RTEMS for a heterogeneous environment is no more difficult than for a homogeneous one.  In keeping with RTEMS philosophy of providing transparent physical node boundaries, the minimal heterogeneous processing required is isolated in the MPCI layer."
multiprocessing,"A processor in a RTEMS system is referred to as a node.  Each node is assigned a unique non-zero node number by the application designer.  RTEMS assumes that node numbers are assigned consecutively from one to the maximum_nodes configuration parameter.  The node number, node, and the maximum number of nodes, maximum_nodes, in a system are found in the Multiprocessor Configuration Table.  The maximum_nodes field and the number of global objects, maximum_global_objects, is required to be the same on all nodes in a system."
multiprocessing,"The node number is used by RTEMS to identify each node when performing remote operations.  Thus, the Multiprocessor Communications Interface Layer (MPCI) must be able to route messages based on the node number."
multiprocessing,"All RTEMS objects which are created with the GLOBAL attribute will be known on all other nodes.  Global objects can be referenced from any node in the system, although certain directive specific restrictions (e.g. one cannot delete a remote object) may apply.  A task does not have to be global to perform operations involving remote objects.  The maximum number of global objects is the system is user configurable and can be found in the maximum_global_objects field in the Multiprocessor Configuration Table.  The distribution of tasks to processors is performed during the application design phase.  Dynamic task relocation is not supported by RTEMS."
multiprocessing,"RTEMS maintains two tables containing object information on every node in a multiprocessor system: a local object table and a global object table.  The local object table on each node is unique and contains information for all objects created on this node whether those objects are local or global.  The global object table contains information regarding all global objects in the system and, consequently, is the same on every node."
multiprocessing,"Since each node must maintain an identical copy of the global object table, the maximum number of entries in each copy of the table must be the same.  The maximum number of entries in each copy is determined by the maximum_global_objects parameter in the Multiprocessor Configuration Table. This parameter, as well as the maximum_nodes parameter, is required to be the same on all nodes.  To maintain consistency among the table copies, every node in the system must be informed of the creation or deletion of a global object."
multiprocessing,"When an application performs an operation on a remote global object, RTEMS must generate a Remote Request (RQ) message and send it to the appropriate node. After completing the requested operation, the remote node will build a Remote Response (RR) message and send it to the originating node.  Messages generated as a side-effect of a directive (such as deleting a global task) are known as Remote Processes (RP) and do not require the receiving node to respond."
multiprocessing,"Other than taking slightly longer to execute directives on remote objects, the application is unaware of the location of the objects it acts upon.  The exact amount of overhead required for a remote operation is dependent on the media connecting the nodes and, to a lesser degree, on the efficiency of the user-provided MPCI routines."
multiprocessing,The following shows the typical transaction sequence during a remote application:
multiprocessing,The application issues a directive accessing a remote global object.
multiprocessing,RTEMS determines the node on which the object resides.
multiprocessing,RTEMS calls the user-provided MPCI routine GET_PACKET to obtain a packet in which to build a RQ message.
multiprocessing,"After building a message packet, RTEMS calls the user-provided MPCI routine SEND_PACKET to transmit the packet to the node on which the object resides (referred to as the destination node)."
multiprocessing,"The calling task is blocked until the RR message arrives, and control of the processor is transferred to another task."
multiprocessing,"The MPCI layer on the destination node senses the arrival of a packet (commonly in an ISR), and calls the rtems_multiprocessing_announce directive.  This directive readies the Multiprocessing Server."
multiprocessing,"The Multiprocessing Server calls the user-provided MPCI routine RECEIVE_PACKET, performs the requested operation, builds an RR message, and returns it to the originating node."
multiprocessing,"The MPCI layer on the originating node senses the arrival of a packet (typically via an interrupt), and calls the RTEMS rtems_multiprocessing_announce directive.  This directive readies the Multiprocessing Server."
multiprocessing,"The Multiprocessing Server calls the user-provided MPCI routine RECEIVE_PACKET, readies the original requesting task, and blocks until another packet arrives.  Control is transferred to the original task which then completes processing of the directive."
multiprocessing,"If an uncorrectable error occurs in the user-provided MPCI layer, the fatal error handler should be invoked.  RTEMS assumes the reliable transmission and reception of messages by the MPCI and makes no attempt to detect or correct errors."
multiprocessing,"A proxy is an RTEMS data structure which resides on a remote node and is used to represent a task which must block as part of a remote operation. This action can occur as part of the rtems_semaphore_obtain and rtems_message_queue_receive directives.  If the object were local, the task’s control block would be available for modification to indicate it was blocking on a message queue or semaphore.  However, the task’s control block resides only on the same node as the task.  As a result, the remote node must allocate a proxy to represent the task until it can be readied."
multiprocessing,The maximum number of proxies is defined in the Multiprocessor Configuration Table.  Each node in a multiprocessor system may require a different number of proxies to be configured.  The distribution of proxy control blocks is application dependent and is different from the distribution of tasks.
multiprocessing,The Multiprocessor Configuration Table contains information needed by RTEMS when used in a multiprocessor system.  This table is discussed in detail in the section Multiprocessor Configuration Table of the Configuring a System chapter.
multiprocessing,"The Multiprocessor Communications Interface Layer (MPCI) is a set of user-provided procedures which enable the nodes in a multiprocessor system to communicate with one another.  These routines are invoked by RTEMS at various times in the preparation and processing of remote requests.  Interrupts are enabled when an MPCI procedure is invoked.  It is assumed that if the execution mode and/or interrupt level are altered by the MPCI layer, that they will be restored prior to returning to RTEMS."
multiprocessing,"The MPCI layer is responsible for managing a pool of buffers called packets and for sending these packets between system nodes.  Packet buffers contain the messages sent between the nodes.  Typically, the MPCI layer will encapsulate the packet within an envelope which contains the information needed by the MPCI layer.  The number of packets available is dependent on the MPCI layer implementation."
multiprocessing,The entry points to the routines in the user’s MPCI layer should be placed in the Multiprocessor Communications Interface Table.  The user must provide entry points for each of the following table entries in a multiprocessor system:
multiprocessing,initialization initialize the MPCI get_packet obtain a packet buffer return_packet return a packet buffer send_packet send a packet to another node receive_packet called to get an arrived packet
multiprocessing,initialization
multiprocessing,initialize the MPCI
multiprocessing,get_packet
multiprocessing,obtain a packet buffer
multiprocessing,return_packet
multiprocessing,return a packet buffer
multiprocessing,send_packet
multiprocessing,send a packet to another node
multiprocessing,receive_packet
multiprocessing,called to get an arrived packet
multiprocessing,A packet is sent by RTEMS in each of the following situations:
multiprocessing,an RQ is generated on an originating node; an RR is generated on a destination node; a global object is created; a global object is deleted; a local task blocked on a remote object is deleted; during system initialization to check for system consistency.
multiprocessing,an RQ is generated on an originating node;
multiprocessing,an RR is generated on a destination node;
multiprocessing,a global object is created;
multiprocessing,a global object is deleted;
multiprocessing,a local task blocked on a remote object is deleted;
multiprocessing,during system initialization to check for system consistency.
multiprocessing,"If the target hardware supports it, the arrival of a packet at a node may generate an interrupt.  Otherwise, the real-time clock ISR can check for the arrival of a packet.  In any case, the rtems_multiprocessing_announce directive must be called to announce the arrival of a packet.  After exiting the ISR, control will be passed to the Multiprocessing Server to process the packet.  The Multiprocessing Server will call the get_packet entry to obtain a packet buffer and the receive_entry entry to copy the message into the buffer obtained."
multiprocessing,The INITIALIZATION component of the user-provided MPCI layer is called as part of the rtems_initialize_executive directive to initialize the MPCI layer and associated hardware.  It is invoked immediately after all of the device drivers have been initialized.  This component should be adhere to the following prototype:
multiprocessing,"Operations on global objects cannot be performed until this component is invoked.  The INITIALIZATION component is invoked only once in the life of any system.  If the MPCI layer cannot be successfully initialized, the fatal error manager should be invoked by this routine."
multiprocessing,One of the primary functions of the MPCI layer is to provide the executive with packet buffers.  The INITIALIZATION routine must create and initialize a pool of packet buffers.  There must be enough packet buffers so RTEMS can obtain one whenever needed.
multiprocessing,The GET_PACKET component of the user-provided MPCI layer is called when RTEMS must obtain a packet buffer to send or broadcast a message.  This component should be adhere to the following prototype:
multiprocessing,"where packet is the address of a pointer to a packet.  This routine always succeeds and, upon return, packet will contain the address of a packet.  If for any reason, a packet cannot be successfully obtained, then the fatal error manager should be invoked."
multiprocessing,"RTEMS has been optimized to avoid the need for obtaining a packet each time a message is sent or broadcast.  For example, RTEMS sends response messages (RR) back to the originator in the same packet in which the request message (RQ) arrived."
multiprocessing,The RETURN_PACKET component of the user-provided MPCI layer is called when RTEMS needs to release a packet to the free packet buffer pool.  This component should be adhere to the following prototype:
multiprocessing,"where packet is the address of a packet.  If the packet cannot be successfully returned, the fatal error manager should be invoked."
multiprocessing,The RECEIVE_PACKET component of the user-provided MPCI layer is called when RTEMS needs to obtain a packet which has previously arrived.  This component should be adhere to the following prototype:
multiprocessing,"where packet is a pointer to the address of a packet to place the message from another node.  If a message is available, then packet will contain the address of the message from another node.  If no messages are available, this entry packet should contain NULL."
multiprocessing,The SEND_PACKET component of the user-provided MPCI layer is called when RTEMS needs to send a packet containing a message to another node.  This component should be adhere to the following prototype:
multiprocessing,"where node is the node number of the destination and packet is the address of a packet which containing a message.  If the packet cannot be successfully sent, the fatal error manager should be invoked."
multiprocessing,"If node is set to zero, the packet is to be broadcasted to all other nodes in the system.  Although some MPCI layers will be built upon hardware which support a broadcast mechanism, others may be required to generate a copy of the packet for each node in the system."
multiprocessing,Many MPCI layers use the packet_length field of the rtems_packet_prefix portion of the packet to avoid sending unnecessary data.  This is especially useful if the media connecting the nodes is relatively slow.
multiprocessing,The to_convert field of the rtems_packet_prefix portion of the packet indicates how much of the packet in 32-bit units may require conversion in a heterogeneous system.
multiprocessing,Developing an MPCI layer for a heterogeneous system requires a thorough understanding of the differences between the processors which comprise the system.  One difficult problem is the varying data representation schemes used by different processor types.  The most pervasive data representation problem is the order of the bytes which compose a data entity.  Processors which place the least significant byte at the smallest address are classified as little endian processors.  Little endian byte-ordering is shown below:
multiprocessing,"Conversely, processors which place the most significant byte at the smallest address are classified as big endian processors.  Big endian byte-ordering is shown below:"
multiprocessing,"Unfortunately, sharing a data structure between big endian and little endian processors requires translation into a common endian format.  An application designer typically chooses the common endian format to minimize conversion overhead."
multiprocessing,"Another issue in the design of shared data structures is the alignment of data structure elements.  Alignment is both processor and compiler implementation dependent.  For example, some processors allow data elements to begin on any address boundary, while others impose restrictions.  Common restrictions are that data elements must begin on either an even address or on a long word boundary.  Violation of these restrictions may cause an exception or impose a performance penalty."
multiprocessing,"Other issues which commonly impact the design of shared data structures include the representation of floating point numbers, bit fields, decimal data, and character strings.  In addition, the representation method for negative integers could be one’s or two’s complement.  These factors combine to increase the complexity of designing and manipulating data structures shared between processors."
multiprocessing,"RTEMS addressed these issues in the design of the packets used to communicate between nodes.  The RTEMS packet format is designed to allow the MPCI layer to perform all necessary conversion without burdening the developer with the details of the RTEMS packet format.  As a result, the MPCI layer must be aware of the following:"
multiprocessing,All packets must begin on a four byte boundary. Packets are composed of both RTEMS and application data.  All RTEMS data is treated as 32-bit unsigned quantities and is in the first to_convert 32-bit quantities of the packet.  The to_convert field is part of the rtems_packet_prefix portion of the packet. The RTEMS data component of the packet must be in native endian format. Endian conversion may be performed by either the sending or receiving MPCI layer. RTEMS makes no assumptions regarding the application data component of the packet.
multiprocessing,All packets must begin on a four byte boundary.
multiprocessing,Packets are composed of both RTEMS and application data.  All RTEMS data is treated as 32-bit unsigned quantities and is in the first to_convert 32-bit quantities of the packet.  The to_convert field is part of the rtems_packet_prefix portion of the packet.
multiprocessing,The RTEMS data component of the packet must be in native endian format. Endian conversion may be performed by either the sending or receiving MPCI layer.
multiprocessing,RTEMS makes no assumptions regarding the application data component of the packet.
multiprocessing,"© Copyright 1988, 2024 RTEMS Project and contributors."
multiprocessing,"This section details the directives of the Multiprocessing Manager. A subsection is dedicated to each of this manager’s directives and lists the calling sequence, parameters, description, return values, and notes of the directive."
multiprocessing,Announces the arrival of a packet.
multiprocessing,CALLING SEQUENCE:
multiprocessing,DESCRIPTION:
multiprocessing,"This directive informs RTEMS that a multiprocessing communications packet has arrived from another node.  This directive is called by the user-provided MPCI, and is only used in multiprocessing configurations."
multiprocessing,NOTES:
multiprocessing,This directive is typically called from an ISR.
multiprocessing,This directive does not generate activity on remote nodes.
multiprocessing,CONSTRAINTS:
multiprocessing,The following constraints apply to this directive:
multiprocessing,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may unblock a task.  This may cause the calling task to be preempted.
multiprocessing,The directive may be called from within interrupt context.
multiprocessing,The directive may be called from within device driver initialization context.
multiprocessing,The directive may be called from within task context.
multiprocessing,The directive may unblock a task.  This may cause the calling task to be preempted.
multiprocessing,"© Copyright 1988, 2024 RTEMS Project and contributors."
multiprocessing,The Multiprocessing Manager provides support for heterogeneous multiprocessing systems based on message passing in a network of multiprocessing nodes.
multiprocessing,"In multiprocessor real-time systems, new requirements, such as sharing data and global resources between processors, are introduced.  This requires an efficient and reliable communications vehicle which allows all processors to communicate with each other as necessary.  In addition, the ramifications of multiple processors affect each and every characteristic of a real-time system, almost always making them more complicated."
multiprocessing,"RTEMS addresses these issues by providing simple and flexible real-time multiprocessing capabilities.  The executive easily lends itself to both tightly-coupled and loosely-coupled configurations of the target system hardware.  In addition, RTEMS supports systems composed of both homogeneous and heterogeneous mixtures of processors and target boards."
multiprocessing,"A major design goal of the RTEMS executive was to transcend the physical boundaries of the target hardware configuration.  This goal is achieved by presenting the application software with a logical view of the target system where the boundaries between processor nodes are transparent.  As a result, the application developer may designate objects such as tasks, queues, events, signals, semaphores, and memory blocks as global objects.  These global objects may then be accessed by any task regardless of the physical location of the object and the accessing task.  RTEMS automatically determines that the object being accessed resides on another processor and performs the actions required to access the desired object.  Simply stated, RTEMS allows the entire system, both hardware and software, to be viewed logically as a single system. The directives provided by the Multiprocessing Manager are:"
multiprocessing,rtems_multiprocessing_announce() - Announces the arrival of a packet.
multiprocessing,rtems_multiprocessing_announce() - Announces the arrival of a packet.
multiprocessing,"© Copyright 1988, 2024 RTEMS Project and contributors."
multiprocessing,The rtems_multiprocessing_announce directive is called by the MPCI layer to inform RTEMS that a packet has arrived from another node.  This directive can be called from an interrupt service routine or from within a polling routine.
multiprocessing,"© Copyright 1988, 2024 RTEMS Project and contributors."
object-services,"RTEMS implements multiple APIs including an Internal API, the Classic API, and the POSIX API.  These APIs share the common foundation of SuperCore objects and thus share object management code. This includes a common scheme for object Ids and for managing object names whether those names be in the thirty-two bit form used by the Classic API or C strings."
object-services,The object Id contains a field indicating the API that an object instance is associated with.  This field holds a numerically small non-zero integer.
object-services,Each API consists of a collection of managers.  Each manager is responsible for instances of a particular object class.  Classic API Tasks and POSIX Mutexes example classes.
object-services,"The object Id contains a field indicating the class that an object instance is associated with.  This field holds a numerically small non-zero integer.  In all APIs, a class value of one is reserved for tasks or threads."
object-services,"Every RTEMS object which has an Id may also have a name associated with it. Depending on the API, names may be either thirty-two bit integers as in the Classic API or strings as in the POSIX API."
object-services,"Some objects have Ids but do not have a defined way to associate a name with them.  For example, POSIX threads have Ids but per POSIX do not have names. In RTEMS, objects not defined to have thirty-two bit names may have string names assigned to them via the rtems_object_set_name service.  The original impetus in providing this service was so the normally anonymous POSIX threads could have a user defined name in CPU Usage Reports."
object-services,"© Copyright 1988, 2024 RTEMS Project and contributors."
object-services,"This section details the directives of the Object Services. A subsection is dedicated to each of this manager’s directives and lists the calling sequence, parameters, description, return values, and notes of the directive."
object-services,"Builds the object identifier from the API, class, MPCI node, and index components."
object-services,CALLING SEQUENCE:
object-services,PARAMETERS:
object-services,This parameter is the API of the object identifier to build.
object-services,This parameter is the class of the object identifier to build.
object-services,This parameter is the MPCI node of the object identifier to build.
object-services,This parameter is the index of the object identifier to build.
object-services,RETURN VALUES:
object-services,"Returns the object identifier built from the API, class, MPCI node, and index components."
object-services,CONSTRAINTS:
object-services,The following constraints apply to this directive:
object-services,"The directive is implemented by a macro and may be called from within C/C++ constant expressions.  In addition, a function implementation of the directive exists for bindings to other programming languages. The directive will not cause the calling task to be preempted."
object-services,"The directive is implemented by a macro and may be called from within C/C++ constant expressions.  In addition, a function implementation of the directive exists for bindings to other programming languages."
object-services,The directive will not cause the calling task to be preempted.
object-services,Builds the object name composed of the four characters.
object-services,CALLING SEQUENCE:
object-services,PARAMETERS:
object-services,This parameter is the first character of the name.
object-services,This parameter is the second character of the name.
object-services,This parameter is the third character of the name.
object-services,This parameter is the fourth character of the name.
object-services,DESCRIPTION:
object-services,This directive takes the four characters provided as arguments and composes a 32-bit object name with c1 in the most significant 8-bits and c4 in the least significant 8-bits.
object-services,RETURN VALUES:
object-services,Returns the object name composed of the four characters.
object-services,CONSTRAINTS:
object-services,The following constraints apply to this directive:
object-services,"The directive is implemented by a macro and may be called from within C/C++ constant expressions.  In addition, a function implementation of the directive exists for bindings to other programming languages. The directive will not cause the calling task to be preempted."
object-services,"The directive is implemented by a macro and may be called from within C/C++ constant expressions.  In addition, a function implementation of the directive exists for bindings to other programming languages."
object-services,The directive will not cause the calling task to be preempted.
object-services,Gets the object name associated with the object identifier.
object-services,CALLING SEQUENCE:
object-services,PARAMETERS:
object-services,This parameter is the object identifier to get the name.
object-services,"This parameter is the pointer to an rtems_name object.  When the directive call is successful, the object name associated with the object identifier will be stored in this object."
object-services,RETURN VALUES:
object-services,The requested operation was successful.
object-services,The name parameter was NULL.
object-services,There was no object information available for the object identifier.
object-services,The object name associated with the object identifier was a string.
object-services,There was no object associated with the object identifier.
object-services,CONSTRAINTS:
object-services,The following constraints apply to this directive:
object-services,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
object-services,The directive may be called from within any runtime context.
object-services,The directive will not cause the calling task to be preempted.
object-services,Gets the object name associated with the object identifier as a string.
object-services,CALLING SEQUENCE:
object-services,PARAMETERS:
object-services,This parameter is the object identifier to get the name.
object-services,This parameter is the buffer length in bytes.
object-services,This parameter is the pointer to a buffer of the specified length.
object-services,DESCRIPTION:
object-services,"The object name is stored in the name buffer.  If the name buffer length is greater than zero, then the stored object name will be NUL terminated. The stored object name may be truncated to fit the length.  There is no indication if a truncation occurred.  Every attempt is made to return name as a printable string even if the object has the Classic API 32-bit integer style name."
object-services,RETURN VALUES:
object-services,The length parameter was 0.
object-services,The name parameter was NULL.
object-services,There was no object information available for the object identifier.
object-services,There was no object associated with the object identifier.
object-services,"Returns the name parameter value, if there is an object name associated with the object identifier."
object-services,CONSTRAINTS:
object-services,The following constraints apply to this directive:
object-services,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
object-services,The directive may be called from within any runtime context.
object-services,The directive will not cause the calling task to be preempted.
object-services,Sets the object name of the object associated with the object identifier.
object-services,CALLING SEQUENCE:
object-services,PARAMETERS:
object-services,This parameter is the object identifier of the object to set the name.
object-services,This parameter is the object name to set.
object-services,DESCRIPTION:
object-services,This directive will set the object name based upon the user string.
object-services,RETURN VALUES:
object-services,The requested operation was successful.
object-services,The name parameter was NULL.
object-services,There was no object information available for the object identifier.
object-services,There was no object associated with the object identifier.
object-services,There was no memory available to duplicate the name.
object-services,NOTES:
object-services,This directive can be used to set the name of objects which do not have a naming scheme per their API.
object-services,"If the object specified by id is of a class that has a string name, this directive will free the existing name to the RTEMS Workspace and allocate enough memory from the RTEMS Workspace to make a copy of the string located at name."
object-services,"If the object specified by id is of a class that has a 32-bit integer style name, then the first four characters in name will be used to construct the name."
object-services,CONSTRAINTS:
object-services,The following constraints apply to this directive:
object-services,The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
object-services,The directive may be called from within device driver initialization context.
object-services,The directive may be called from within task context.
object-services,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
object-services,Gets the API component of the object identifier.
object-services,CALLING SEQUENCE:
object-services,PARAMETERS:
object-services,This parameter is the object identifier with the API component to get.
object-services,RETURN VALUES:
object-services,Returns the API component of the object identifier.
object-services,NOTES:
object-services,This directive does not validate the object identifier provided in id.
object-services,CONSTRAINTS:
object-services,The following constraints apply to this directive:
object-services,"The directive is implemented by a macro and may be called from within C/C++ constant expressions.  In addition, a function implementation of the directive exists for bindings to other programming languages. The directive will not cause the calling task to be preempted."
object-services,"The directive is implemented by a macro and may be called from within C/C++ constant expressions.  In addition, a function implementation of the directive exists for bindings to other programming languages."
object-services,The directive will not cause the calling task to be preempted.
object-services,Gets the class component of the object identifier.
object-services,CALLING SEQUENCE:
object-services,PARAMETERS:
object-services,This parameter is the object identifier with the class component to get.
object-services,RETURN VALUES:
object-services,Returns the class component of the object identifier.
object-services,NOTES:
object-services,This directive does not validate the object identifier provided in id.
object-services,CONSTRAINTS:
object-services,The following constraints apply to this directive:
object-services,"The directive is implemented by a macro and may be called from within C/C++ constant expressions.  In addition, a function implementation of the directive exists for bindings to other programming languages. The directive will not cause the calling task to be preempted."
object-services,"The directive is implemented by a macro and may be called from within C/C++ constant expressions.  In addition, a function implementation of the directive exists for bindings to other programming languages."
object-services,The directive will not cause the calling task to be preempted.
object-services,Gets the MPCI node component of the object identifier.
object-services,CALLING SEQUENCE:
object-services,PARAMETERS:
object-services,This parameter is the object identifier with the MPCI node component to get.
object-services,RETURN VALUES:
object-services,Returns the MPCI node component of the object identifier.
object-services,NOTES:
object-services,This directive does not validate the object identifier provided in id.
object-services,CONSTRAINTS:
object-services,The following constraints apply to this directive:
object-services,"The directive is implemented by a macro and may be called from within C/C++ constant expressions.  In addition, a function implementation of the directive exists for bindings to other programming languages. The directive will not cause the calling task to be preempted."
object-services,"The directive is implemented by a macro and may be called from within C/C++ constant expressions.  In addition, a function implementation of the directive exists for bindings to other programming languages."
object-services,The directive will not cause the calling task to be preempted.
object-services,Gets the index component of the object identifier.
object-services,CALLING SEQUENCE:
object-services,PARAMETERS:
object-services,This parameter is the object identifier with the index component to get.
object-services,RETURN VALUES:
object-services,Returns the index component of the object identifier.
object-services,NOTES:
object-services,This directive does not validate the object identifier provided in id.
object-services,CONSTRAINTS:
object-services,The following constraints apply to this directive:
object-services,"The directive is implemented by a macro and may be called from within C/C++ constant expressions.  In addition, a function implementation of the directive exists for bindings to other programming languages. The directive will not cause the calling task to be preempted."
object-services,"The directive is implemented by a macro and may be called from within C/C++ constant expressions.  In addition, a function implementation of the directive exists for bindings to other programming languages."
object-services,The directive will not cause the calling task to be preempted.
object-services,Gets the lowest valid value for the API component of an object identifier.
object-services,CALLING SEQUENCE:
object-services,RETURN VALUES:
object-services,Returns the lowest valid value for the API component of an object identifier.
object-services,CONSTRAINTS:
object-services,The following constraints apply to this directive:
object-services,"The directive is implemented by a macro and may be called from within C/C++ constant expressions.  In addition, a function implementation of the directive exists for bindings to other programming languages. The directive will not cause the calling task to be preempted."
object-services,"The directive is implemented by a macro and may be called from within C/C++ constant expressions.  In addition, a function implementation of the directive exists for bindings to other programming languages."
object-services,The directive will not cause the calling task to be preempted.
object-services,Gets the highest valid value for the API component of an object identifier.
object-services,CALLING SEQUENCE:
object-services,RETURN VALUES:
object-services,Returns the highest valid value for the API component of an object identifier.
object-services,CONSTRAINTS:
object-services,The following constraints apply to this directive:
object-services,"The directive is implemented by a macro and may be called from within C/C++ constant expressions.  In addition, a function implementation of the directive exists for bindings to other programming languages. The directive will not cause the calling task to be preempted."
object-services,"The directive is implemented by a macro and may be called from within C/C++ constant expressions.  In addition, a function implementation of the directive exists for bindings to other programming languages."
object-services,The directive will not cause the calling task to be preempted.
object-services,Gets the lowest valid class value of the object API.
object-services,CALLING SEQUENCE:
object-services,PARAMETERS:
object-services,This parameter is the object API to get the lowest valid class value.
object-services,RETURN VALUES:
object-services,The object API was invalid.
object-services,Returns the lowest valid class value of the object API.
object-services,CONSTRAINTS:
object-services,The following constraints apply to this directive:
object-services,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
object-services,The directive may be called from within any runtime context.
object-services,The directive will not cause the calling task to be preempted.
object-services,Gets the highest valid class value of the object API.
object-services,CALLING SEQUENCE:
object-services,PARAMETERS:
object-services,This parameter is the object API to get the highest valid class value.
object-services,RETURN VALUES:
object-services,The object API was invalid.
object-services,Returns the highest valid class value of the object API.
object-services,CONSTRAINTS:
object-services,The following constraints apply to this directive:
object-services,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
object-services,The directive may be called from within any runtime context.
object-services,The directive will not cause the calling task to be preempted.
object-services,Gets a descriptive name of the object API.
object-services,CALLING SEQUENCE:
object-services,PARAMETERS:
object-services,This parameter is the object API to get the name.
object-services,RETURN VALUES:
object-services,The API was invalid.
object-services,"Returns a descriptive name of the API, if the API was valid."
object-services,NOTES:
object-services,The string returned is from constant space.  Do not modify or free it.
object-services,CONSTRAINTS:
object-services,The following constraints apply to this directive:
object-services,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
object-services,The directive may be called from within any runtime context.
object-services,The directive will not cause the calling task to be preempted.
object-services,Gets a descriptive name of the object class of the object API.
object-services,CALLING SEQUENCE:
object-services,PARAMETERS:
object-services,This parameter is the object API of the object class.
object-services,This parameter is the object class of the object API to get the name.
object-services,RETURN VALUES:
object-services,The API was invalid.
object-services,The class of the API was invalid.
object-services,"Returns a descriptive name of the class of the API, if the class of the API and the API were valid."
object-services,NOTES:
object-services,The string returned is from constant space.  Do not modify or free it.
object-services,CONSTRAINTS:
object-services,The following constraints apply to this directive:
object-services,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
object-services,The directive may be called from within any runtime context.
object-services,The directive will not cause the calling task to be preempted.
object-services,Gets the object class information of the object class of the object API.
object-services,CALLING SEQUENCE:
object-services,PARAMETERS:
object-services,This parameter is the object API of the object class.
object-services,This parameter is the object class of the object API to get the class information.
object-services,"This parameter is the pointer to an rtems_object_api_class_information object.  When the directive call is successful, the object class information of the class of the API will be stored in this object."
object-services,RETURN VALUES:
object-services,The requested operation was successful.
object-services,The info parameter was NULL.
object-services,The class of the API or the API was invalid.
object-services,CONSTRAINTS:
object-services,The following constraints apply to this directive:
object-services,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
object-services,The directive may be called from within any runtime context.
object-services,The directive will not cause the calling task to be preempted.
object-services,Gets the local MPCI node number.
object-services,CALLING SEQUENCE:
object-services,RETURN VALUES:
object-services,Returns the local MPCI node number.
object-services,CONSTRAINTS:
object-services,The following constraints apply to this directive:
object-services,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
object-services,The directive may be called from within any runtime context.
object-services,The directive will not cause the calling task to be preempted.
object-services,"Builds the object identifier with the lowest index from the API, class, and MPCI node components."
object-services,CALLING SEQUENCE:
object-services,PARAMETERS:
object-services,This parameter is the API of the object identifier to build.
object-services,This parameter is the class of the object identifier to build.
object-services,This parameter is the MPCI node of the object identifier to build.
object-services,RETURN VALUES:
object-services,"Returns the object identifier with the lowest index built from the API, class, and MPCI node components."
object-services,CONSTRAINTS:
object-services,The following constraints apply to this directive:
object-services,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
object-services,The directive may be called from within any runtime context.
object-services,The directive will not cause the calling task to be preempted.
object-services,"© Copyright 1988, 2024 RTEMS Project and contributors."
object-services,RTEMS provides a collection of services to assist in the management and usage of the objects created and utilized via other managers.  These services assist in the manipulation of RTEMS objects independent of the API used to create them. The directives provided by the Object Services are:
object-services,"rtems_build_id() - Builds the object identifier from the API, class, MPCI node, and index components. rtems_build_name() - Builds the object name composed of the four characters. rtems_object_get_classic_name() - Gets the object name associated with the object identifier. rtems_object_get_name() - Gets the object name associated with the object identifier as a string. rtems_object_set_name() - Sets the object name of the object associated with the object identifier. rtems_object_id_get_api() - Gets the API component of the object identifier. rtems_object_id_get_class() - Gets the class component of the object identifier. rtems_object_id_get_node() - Gets the MPCI node component of the object identifier. rtems_object_id_get_index() - Gets the index component of the object identifier. rtems_object_id_api_minimum() - Gets the lowest valid value for the API component of an object identifier. rtems_object_id_api_maximum() - Gets the highest valid value for the API component of an object identifier. rtems_object_api_minimum_class() - Gets the lowest valid class value of the object API. rtems_object_api_maximum_class() - Gets the highest valid class value of the object API. rtems_object_get_api_name() - Gets a descriptive name of the object API. rtems_object_get_api_class_name() - Gets a descriptive name of the object class of the object API. rtems_object_get_class_information() - Gets the object class information of the object class of the object API. rtems_object_get_local_node() - Gets the local MPCI node number. RTEMS_OBJECT_ID_INITIAL() - Builds the object identifier with the lowest index from the API, class, and MPCI node components."
object-services,"rtems_build_id() - Builds the object identifier from the API, class, MPCI node, and index components."
object-services,rtems_build_name() - Builds the object name composed of the four characters.
object-services,rtems_object_get_classic_name() - Gets the object name associated with the object identifier.
object-services,rtems_object_get_name() - Gets the object name associated with the object identifier as a string.
object-services,rtems_object_set_name() - Sets the object name of the object associated with the object identifier.
object-services,rtems_object_id_get_api() - Gets the API component of the object identifier.
object-services,rtems_object_id_get_class() - Gets the class component of the object identifier.
object-services,rtems_object_id_get_node() - Gets the MPCI node component of the object identifier.
object-services,rtems_object_id_get_index() - Gets the index component of the object identifier.
object-services,rtems_object_id_api_minimum() - Gets the lowest valid value for the API component of an object identifier.
object-services,rtems_object_id_api_maximum() - Gets the highest valid value for the API component of an object identifier.
object-services,rtems_object_api_minimum_class() - Gets the lowest valid class value of the object API.
object-services,rtems_object_api_maximum_class() - Gets the highest valid class value of the object API.
object-services,rtems_object_get_api_name() - Gets a descriptive name of the object API.
object-services,rtems_object_get_api_class_name() - Gets a descriptive name of the object class of the object API.
object-services,rtems_object_get_class_information() - Gets the object class information of the object class of the object API.
object-services,rtems_object_get_local_node() - Gets the local MPCI node number.
object-services,"RTEMS_OBJECT_ID_INITIAL() - Builds the object identifier with the lowest index from the API, class, and MPCI node components."
object-services,"© Copyright 1988, 2024 RTEMS Project and contributors."
object-services,Services are provided to decompose an object Id into its subordinate components. The following services are used to do this:
object-services,rtems_object_id_get_api rtems_object_id_get_class rtems_object_id_get_node rtems_object_id_get_index
object-services,rtems_object_id_get_api
object-services,rtems_object_id_get_class
object-services,rtems_object_id_get_node
object-services,rtems_object_id_get_index
object-services,The following C language example illustrates the decomposition of an Id and printing the values.
object-services,This prints the components of the Ids as integers.
object-services,It is also possible to construct an arbitrary Id using the rtems_build_id service.  The following C language example illustrates how to construct the “next Id.”
object-services,Note that this Id may not be valid in this system or associated with an allocated object.
object-services,RTEMS also provides services to associate the API and Class portions of an Object Id with strings.  This allows the application developer to provide more information about an object in diagnostic messages.
object-services,"In the following C language example, an Id is decomposed into its constituent parts and “pretty-printed.”"
object-services,"© Copyright 1988, 2024 RTEMS Project and contributors."
partition,A partition is a physically contiguous memory area divided into fixed-size buffers that can be dynamically allocated and deallocated.
partition,"Partitions are managed and maintained as a list of buffers.  Buffers are obtained from the front of the partition’s free buffer chain and returned to the rear of the same chain.  When a buffer is on the free buffer chain, RTEMS uses two pointers of memory from each buffer as the free buffer chain.  When a buffer is allocated, the entire buffer is available for application use. Therefore, modifying memory that is outside of an allocated buffer could destroy the free buffer chain or the contents of an adjacent allocated buffer."
partition,"In general, an attribute set is built by a bitwise OR of the desired attribute components.  The set of valid partition attributes is provided in the following table:"
partition,RTEMS_LOCAL local partition (default) RTEMS_GLOBAL global partition
partition,RTEMS_LOCAL
partition,local partition (default)
partition,RTEMS_GLOBAL
partition,global partition
partition,"Attribute values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each attribute appears exactly once in the component list.  An attribute listed as a default is not required to appear in the attribute list, although it is a good programming practice to specify default attributes.  If all defaults are desired, the attribute RTEMS_DEFAULT_ATTRIBUTES should be specified on this call.  The attribute_set parameter should be RTEMS_GLOBAL to indicate that the partition is to be known globally."
partition,"© Copyright 1988, 2024 RTEMS Project and contributors."
partition,"This section details the directives of the Partition Manager. A subsection is dedicated to each of this manager’s directives and lists the calling sequence, parameters, description, return values, and notes of the directive."
partition,Creates a partition.
partition,CALLING SEQUENCE:
partition,PARAMETERS:
partition,This parameter is the object name of the partition.
partition,This parameter is the starting address of the buffer area used by the partition.
partition,This parameter is the length in bytes of the buffer area used by the partition.
partition,This parameter is the size in bytes of a buffer managed by the partition.
partition,This parameter is the attribute set of the partition.
partition,"This parameter is the pointer to an rtems_id object.  When the directive call is successful, the identifier of the created partition will be stored in this object."
partition,DESCRIPTION:
partition,This directive creates a partition of fixed size buffers from a physically contiguous memory space which starts at starting_address and is length bytes in size.  Each allocated buffer is to be of buffer_size in bytes. The partition has the user-defined object name specified in name.  The assigned object identifier is returned in id.  This identifier is used to access the partition with other partition related directives.
partition,"The attribute set specified in attribute_set is built through a bitwise or of the attribute constants described below.  Not all combinations of attributes are allowed.  Some attributes are mutually exclusive.  If mutually exclusive attributes are combined, the behaviour is undefined. Attributes not mentioned below are not evaluated by this directive and have no effect.  Default attributes can be selected by using the RTEMS_DEFAULT_ATTRIBUTES constant."
partition,The partition has a local or global scope in a multiprocessing network (this attribute does not refer to SMP systems).  The scope is selected by the mutually exclusive RTEMS_LOCAL and RTEMS_GLOBAL attributes.
partition,A local scope is the default and can be emphasized through the use of the RTEMS_LOCAL attribute.  A local partition can be only used by the node which created it. A global scope is established if the RTEMS_GLOBAL attribute is set.  The memory space used for the partition must reside in shared memory. Setting the global attribute in a single node system has no effect.
partition,A local scope is the default and can be emphasized through the use of the RTEMS_LOCAL attribute.  A local partition can be only used by the node which created it.
partition,A global scope is established if the RTEMS_GLOBAL attribute is set.  The memory space used for the partition must reside in shared memory. Setting the global attribute in a single node system has no effect.
partition,RETURN VALUES:
partition,The requested operation was successful.
partition,The name parameter was invalid.
partition,The id parameter was NULL.
partition,The length parameter was 0.
partition,The buffer_size parameter was 0.
partition,The length parameter was less than the buffer_size parameter.
partition,The buffer_size parameter was not an integral multiple of the pointer size.
partition,The buffer_size parameter was less than two times the pointer size.
partition,The starting_address parameter was not on a pointer size boundary.
partition,There was no inactive object available to create a partition.  The number of partitions available to the application is configured through the CONFIGURE_MAXIMUM_PARTITIONS application configuration option.
partition,"In multiprocessing configurations, there was no inactive global object available to create a global semaphore.  The number of global objects available to the application is configured through the CONFIGURE_MP_MAXIMUM_GLOBAL_OBJECTS application configuration option."
partition,NOTES:
partition,"The partition buffer area specified by the starting_address must be properly aligned.  It must be possible to directly store target architecture pointers and also the user data.  For example, if the user data contains some long double or vector data types, the partition buffer area and the buffer size must take the alignment of these types into account which is usually larger than the pointer alignment.  A cache line alignment may be also a factor.  Use RTEMS_PARTITION_ALIGNMENT to specify the minimum alignment of a partition buffer type."
partition,"The buffer_size parameter must be an integral multiple of the pointer size on the target architecture.  Additionally, buffer_size must be large enough to hold two pointers on the target architecture.  This is required for RTEMS to manage the buffers when they are free."
partition,"For control and maintenance of the partition, RTEMS allocates a PTCB from the local PTCB free pool and initializes it. Memory from the partition buffer area is not used by RTEMS to store the PTCB."
partition,"The PTCB for a global partition is allocated on the local node.  Partitions should not be made global unless remote tasks must interact with the partition. This is to avoid the overhead incurred by the creation of a global partition. When a global partition is created, the partition’s name and identifier must be transmitted to every node in the system for insertion in the local copy of the global object table."
partition,CONSTRAINTS:
partition,The following constraints apply to this directive:
partition,"The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted. When the directive operates on a global object, the directive sends a message to remote nodes.  This may preempt the calling task. The number of partitions available to the application is configured through the CONFIGURE_MAXIMUM_PARTITIONS application configuration option. Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace. The number of global objects available to the application is configured through the CONFIGURE_MP_MAXIMUM_GLOBAL_OBJECTS application configuration option."
partition,The directive may be called from within device driver initialization context.
partition,The directive may be called from within task context.
partition,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
partition,"When the directive operates on a global object, the directive sends a message to remote nodes.  This may preempt the calling task."
partition,The number of partitions available to the application is configured through the CONFIGURE_MAXIMUM_PARTITIONS application configuration option.
partition,"Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace."
partition,The number of global objects available to the application is configured through the CONFIGURE_MP_MAXIMUM_GLOBAL_OBJECTS application configuration option.
partition,Identifies a partition by the object name.
partition,CALLING SEQUENCE:
partition,PARAMETERS:
partition,This parameter is the object name to look up.
partition,This parameter is the node or node set to search for a matching object.
partition,"This parameter is the pointer to an rtems_id object.  When the directive call is successful, the object identifier of an object with the specified name will be stored in this object."
partition,DESCRIPTION:
partition,This directive obtains a partition identifier associated with the partition name specified in name.
partition,The node to search is specified in node.  It shall be
partition,"a valid node number, the constant RTEMS_SEARCH_ALL_NODES to search in all nodes, the constant RTEMS_SEARCH_LOCAL_NODE to search in the local node only, or the constant RTEMS_SEARCH_OTHER_NODES to search in all nodes except the local node."
partition,"a valid node number,"
partition,"the constant RTEMS_SEARCH_ALL_NODES to search in all nodes,"
partition,"the constant RTEMS_SEARCH_LOCAL_NODE to search in the local node only, or"
partition,the constant RTEMS_SEARCH_OTHER_NODES to search in all nodes except the local node.
partition,RETURN VALUES:
partition,The requested operation was successful.
partition,The id parameter was NULL.
partition,The name parameter was 0.
partition,There was no object with the specified name on the specified nodes.
partition,"In multiprocessing configurations, the specified node was invalid."
partition,NOTES:
partition,"If the partition name is not unique, then the partition identifier will match the first partition with that name in the search order.  However, this partition identifier is not guaranteed to correspond to the desired partition."
partition,"The objects are searched from lowest to the highest index.  If node is RTEMS_SEARCH_ALL_NODES, all nodes are searched with the local node being searched first.  All other nodes are searched from lowest to the highest node number."
partition,"If node is a valid node number which does not represent the local node, then only the partitions exported by the designated node are searched."
partition,This directive does not generate activity on remote nodes.  It accesses only the local copy of the global object table.
partition,The partition identifier is used with other partition related directives to access the partition.
partition,CONSTRAINTS:
partition,The following constraints apply to this directive:
partition,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
partition,The directive may be called from within any runtime context.
partition,The directive will not cause the calling task to be preempted.
partition,Deletes the partition.
partition,CALLING SEQUENCE:
partition,PARAMETERS:
partition,This parameter is the partition identifier.
partition,DESCRIPTION:
partition,This directive deletes the partition specified by id.
partition,RETURN VALUES:
partition,The requested operation was successful.
partition,There was no partition associated with the identifier specified by id.
partition,The partition resided on a remote node.
partition,There were buffers of the partition still in use.
partition,NOTES:
partition,The partition cannot be deleted if any of its buffers are still allocated.
partition,The PTCB for the deleted partition is reclaimed by RTEMS.
partition,"When a global partition is deleted, the partition identifier must be transmitted to every node in the system for deletion from the local copy of the global object table."
partition,"The partition must reside on the local node, even if the partition was created with the RTEMS_GLOBAL attribute."
partition,CONSTRAINTS:
partition,The following constraints apply to this directive:
partition,"The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted. When the directive operates on a global object, the directive sends a message to remote nodes.  This may preempt the calling task. The calling task does not have to be the task that created the object.  Any local task that knows the object identifier can delete the object. Where the object class corresponding to the directive is configured to use unlimited objects, the directive may free memory to the RTEMS Workspace."
partition,The directive may be called from within device driver initialization context.
partition,The directive may be called from within task context.
partition,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
partition,"When the directive operates on a global object, the directive sends a message to remote nodes.  This may preempt the calling task."
partition,The calling task does not have to be the task that created the object.  Any local task that knows the object identifier can delete the object.
partition,"Where the object class corresponding to the directive is configured to use unlimited objects, the directive may free memory to the RTEMS Workspace."
partition,Tries to get a buffer from the partition.
partition,CALLING SEQUENCE:
partition,PARAMETERS:
partition,This parameter is the partition identifier.
partition,"This parameter is the pointer to a void pointer object.  When the directive call is successful, the pointer to the allocated buffer will be stored in this object."
partition,DESCRIPTION:
partition,This directive allows a buffer to be obtained from the partition specified by id.  The address of the allocated buffer is returned through the buffer parameter.
partition,RETURN VALUES:
partition,The requested operation was successful.
partition,There was no partition associated with the identifier specified by id.
partition,The buffer parameter was NULL.
partition,There was no free buffer available to allocate and return.
partition,NOTES:
partition,The buffer start alignment is determined by the memory area and buffer size used to create the partition.
partition,A task cannot wait on a buffer to become available.
partition,Getting a buffer from a global partition which does not reside on the local node will generate a request telling the remote node to allocate a buffer from the partition.
partition,CONSTRAINTS:
partition,The following constraints apply to this directive:
partition,"When the directive operates on a local object, the directive may be called from within interrupt context. The directive may be called from within task context. When the directive operates on a local object, the directive will not cause the calling task to be preempted. When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply.  This will preempt the calling task."
partition,"When the directive operates on a local object, the directive may be called from within interrupt context."
partition,The directive may be called from within task context.
partition,"When the directive operates on a local object, the directive will not cause the calling task to be preempted."
partition,"When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply.  This will preempt the calling task."
partition,Returns the buffer to the partition.
partition,CALLING SEQUENCE:
partition,PARAMETERS:
partition,This parameter is the partition identifier.
partition,This parameter is the pointer to the buffer to return.
partition,DESCRIPTION:
partition,This directive returns the buffer specified by buffer to the partition specified by id.
partition,RETURN VALUES:
partition,The requested operation was successful.
partition,There was no partition associated with the identifier specified by id.
partition,The buffer referenced by buffer was not in the partition.
partition,NOTES:
partition,Returning a buffer multiple times is an error.  It will corrupt the internal state of the partition.
partition,CONSTRAINTS:
partition,The following constraints apply to this directive:
partition,"When the directive operates on a local object, the directive may be called from within interrupt context. The directive may be called from within task context. When the directive operates on a local object, the directive will not cause the calling task to be preempted. When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply.  This will preempt the calling task."
partition,"When the directive operates on a local object, the directive may be called from within interrupt context."
partition,The directive may be called from within task context.
partition,"When the directive operates on a local object, the directive will not cause the calling task to be preempted."
partition,"When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply.  This will preempt the calling task."
partition,"© Copyright 1988, 2024 RTEMS Project and contributors."
partition,The Partition Manager provides facilities to dynamically allocate memory in fixed-size units. The directives provided by the Partition Manager are:
partition,rtems_partition_create() - Creates a partition. rtems_partition_ident() - Identifies a partition by the object name. rtems_partition_delete() - Deletes the partition. rtems_partition_get_buffer() - Tries to get a buffer from the partition. rtems_partition_return_buffer() - Returns the buffer to the partition.
partition,rtems_partition_create() - Creates a partition.
partition,rtems_partition_ident() - Identifies a partition by the object name.
partition,rtems_partition_delete() - Deletes the partition.
partition,rtems_partition_get_buffer() - Tries to get a buffer from the partition.
partition,rtems_partition_return_buffer() - Returns the buffer to the partition.
partition,"© Copyright 1988, 2024 RTEMS Project and contributors."
partition,"The rtems_partition_create directive creates a partition with a user-specified name.  The partition’s name, starting address, length and buffer size are all specified to the rtems_partition_create directive.  RTEMS allocates a Partition Control Block (PTCB) from the PTCB free list.  This data structure is used by RTEMS to manage the newly created partition.  The number of buffers in the partition is calculated based upon the specified partition length and buffer size. If successful,the unique partition ID is returned to the calling task."
partition,"When a partition is created, RTEMS generates a unique partition ID and assigned it to the created partition until it is deleted.  The partition ID may be obtained by either of two methods.  First, as the result of an invocation of the rtems_partition_create directive, the partition ID is stored in a user provided location.  Second, the partition ID may be obtained later using the rtems_partition_ident directive.  The partition ID is used by other partition manager directives to access this partition."
partition,"A buffer can be obtained by calling the rtems_partition_get_buffer directive.  If a buffer is available, then it is returned immediately with a successful return code.  Otherwise, an unsuccessful return code is returned immediately to the caller.  Tasks cannot block to wait for a buffer to become available."
partition,Buffers are returned to a partition’s free buffer chain with the rtems_partition_return_buffer directive.  This directive returns an error status code if the returned buffer was not previously allocated from this partition.
partition,"The rtems_partition_delete directive allows a partition to be removed and returned to RTEMS.  When a partition is deleted, the PTCB for that partition is returned to the PTCB free list.  A partition with buffers still allocated cannot be deleted.  Any task attempting to do so will be returned an error status code."
partition,"© Copyright 1988, 2024 RTEMS Project and contributors."
rate-monotonic,"The rate monotonic manager provides facilities to manage the execution of periodic tasks.  This manager was designed to support application designers who utilize the Rate Monotonic Scheduling Algorithm (RMS) to ensure that their periodic tasks will meet their deadlines, even under transient overload conditions.  Although designed for hard real-time systems, the services provided by the rate monotonic manager may be used by any application which requires periodic tasks."
rate-monotonic,A clock tick is required to support the functionality provided by this manager.
rate-monotonic,This manager maintains a set of statistics on each period object.  These statistics are reset implictly at period creation time and may be reset or obtained at any time by the application.  The following is a list of the information kept:
rate-monotonic,is the id of the thread that owns this period.
rate-monotonic,is the total number of periods executed.
rate-monotonic,is the number of periods that were missed.
rate-monotonic,is the minimum amount of CPU execution time consumed on any execution of the periodic loop.
rate-monotonic,is the maximum amount of CPU execution time consumed on any execution of the periodic loop.
rate-monotonic,is the total amount of CPU execution time consumed by executions of the periodic loop.
rate-monotonic,is the minimum amount of wall time that passed on any execution of the periodic loop.
rate-monotonic,is the maximum amount of wall time that passed on any execution of the periodic loop.
rate-monotonic,is the total amount of wall time that passed during executions of the periodic loop.
rate-monotonic,"Each period is divided into two consecutive phases.  The period starts with the active phase of the task and is followed by the inactive phase of the task.  In the inactive phase the task is blocked and waits for the start of the next period.  The inactive phase is skipped in case of a period miss.  The wall time includes the time during the active phase of the task on which the task is not executing on a processor.  The task is either blocked (for example it waits for a resource) or a higher priority tasks executes, thus preventing it from executing.  In case the wall time exceeds the period time, then this is a period miss.  The gap between the wall time and the period time is the margin between a period miss or success."
rate-monotonic,"The period statistics information is inexpensive to maintain and can provide very useful insights into the execution characteristics of a periodic task loop.  But it is just information.  The period statistics reported must be analyzed by the user in terms of what the applications is.  For example, in an application where priorities are assigned by the Rate Monotonic Algorithm, it would be very undesirable for high priority (i.e. frequency) tasks to miss their period.  Similarly, in nearly any application, if a task were supposed to execute its periodic loop every 10 milliseconds and it averaged 11 milliseconds, then application requirements are not being met."
rate-monotonic,"The information reported can be used to determine the “hot spots” in the application.  Given a period’s id, the user can determine the length of that period.  From that information and the CPU usage, the user can calculate the percentage of CPU time consumed by that periodic task.  For example, a task executing for 20 milliseconds every 200 milliseconds is consuming 10 percent of the processor’s execution time.  This is usually enough to make it a good candidate for optimization."
rate-monotonic,"However, execution time alone is not enough to gauge the value of optimizing a particular task.  It is more important to optimize a task executing 2 millisecond every 10 milliseconds (20 percent of the CPU) than one executing 10 milliseconds every 100 (10 percent of the CPU).  As a general rule of thumb, the higher frequency at which a task executes, the more important it is to optimize that task."
rate-monotonic,"A periodic task is one which must be executed at a regular interval.  The interval between successive iterations of the task is referred to as its period.  Periodic tasks can be characterized by the length of their period and execution time.  The period and execution time of a task can be used to determine the processor utilization for that task.  Processor utilization is the percentage of processor time used and can be calculated on a per-task or system-wide basis.  Typically, the task’s worst-case execution time will be less than its period.  For example, a periodic task’s requirements may state that it should execute for 10 milliseconds every 100 milliseconds.  Although the execution time may be the average, worst, or best case, the worst-case execution time is more appropriate for use when analyzing system behavior under transient overload conditions."
rate-monotonic,"In contrast, an aperiodic task executes at irregular intervals and has only a soft deadline.  In other words, the deadlines for aperiodic tasks are not rigid, but adequate response times are desirable.  For example, an aperiodic task may process user input from a terminal."
rate-monotonic,"Finally, a sporadic task is an aperiodic task with a hard deadline and minimum interarrival time.  The minimum interarrival time is the minimum period of time which exists between successive iterations of the task.  For example, a sporadic task could be used to process the pressing of a fire button on a joystick.  The mechanical action of the fire button ensures a minimum time period between successive activations, but the missile must be launched by a hard deadline."
rate-monotonic,"The Rate Monotonic Scheduling Algorithm (RMS) is important to real-time systems designers because it allows one to sufficiently guarantee that a set of tasks is schedulable (see [LL73], [LSD89], [SG90], [Bur91])."
rate-monotonic,A set of tasks is said to be schedulable if all of the tasks can meet their deadlines.  RMS provides a set of rules which can be used to perform a guaranteed schedulability analysis for a task set.  This analysis determines whether a task set is schedulable under worst-case conditions and emphasizes the predictability of the system’s behavior.  It has been proven that:
rate-monotonic,RMS
rate-monotonic,"RMS is an optimal fixed-priority algorithm for scheduling independent, preemptible, periodic tasks on a single processor."
rate-monotonic,"RMS is optimal in the sense that if a set of tasks can be scheduled by any fixed-priority algorithm, then RMS will be able to schedule that task set. RMS bases it schedulability analysis on the processor utilization level below which all deadlines can be met."
rate-monotonic,"RMS calls for the static assignment of task priorities based upon their period. The shorter a task’s period, the higher its priority.  For example, a task with a 1 millisecond period has higher priority than a task with a 100 millisecond period.  If two tasks have the same period, then RMS does not distinguish between the tasks.  However, RTEMS specifies that when given tasks of equal priority, the task which has been ready longest will execute first.  RMS’s priority assignment scheme does not provide one with exact numeric values for task priorities.  For example, consider the following task set and priority assignments:"
rate-monotonic,"Task Period
(in milliseconds) Priority 1 100 Low 2 50 Medium 3 50 Medium 4 25 High"
rate-monotonic,Task
rate-monotonic,Period (in milliseconds)
rate-monotonic,Priority
rate-monotonic,1
rate-monotonic,100
rate-monotonic,Low
rate-monotonic,2
rate-monotonic,50
rate-monotonic,Medium
rate-monotonic,3
rate-monotonic,50
rate-monotonic,Medium
rate-monotonic,4
rate-monotonic,25
rate-monotonic,High
rate-monotonic,"RMS only calls for task 1 to have the lowest priority, task 4 to have the highest priority, and tasks 2 and 3 to have an equal priority between that of tasks 1 and 4.  The actual RTEMS priorities assigned to the tasks must only adhere to those guidelines."
rate-monotonic,"Many applications have tasks with both hard and soft deadlines.  The tasks with hard deadlines are typically referred to as the critical task set, with the soft deadline tasks being the non-critical task set.  The critical task set can be scheduled using RMS, with the non-critical tasks not executing under transient overload, by simply assigning priorities such that the lowest priority critical task (i.e. longest period) has a higher priority than the highest priority non-critical task.  Although RMS may be used to assign priorities to the non-critical tasks, it is not necessary.  In this instance, schedulability is only guaranteed for the critical task set."
rate-monotonic,"RMS allows application designers to ensure that tasks can meet all deadlines under fixed-priority assignment, even under transient overload, without knowing exactly when any given task will execute by applying proven schedulability analysis rules."
rate-monotonic,The schedulability analysis rules for RMS were developed based on the following assumptions:
rate-monotonic,"The requests for all tasks for which hard deadlines exist are periodic, with a constant interval between requests. Each task must complete before the next request for it occurs. The tasks are independent in that a task does not depend on the initiation or completion of requests for other tasks. The execution time for each task without preemption or interruption is constant and does not vary. Any non-periodic tasks in the system are special.  These tasks should not displace periodic tasks while executing and do not have hard, critical deadlines."
rate-monotonic,"The requests for all tasks for which hard deadlines exist are periodic, with a constant interval between requests."
rate-monotonic,Each task must complete before the next request for it occurs.
rate-monotonic,The tasks are independent in that a task does not depend on the initiation or completion of requests for other tasks.
rate-monotonic,The execution time for each task without preemption or interruption is constant and does not vary.
rate-monotonic,"Any non-periodic tasks in the system are special.  These tasks should not displace periodic tasks while executing and do not have hard, critical deadlines."
rate-monotonic,"Once the basic schedulability analysis is understood, some of the above assumptions can be relaxed and the side-effects accounted for."
rate-monotonic,The Processor Utilization Rule requires that processor utilization be calculated based upon the period and execution time of each task. The fraction of processor time spent executing task index is Time(i) / Period(i).  The processor utilization can be calculated as follows where n is the number of tasks in the set being analyzed:
rate-monotonic,"To ensure schedulability even under transient overload, the processor utilization must adhere to the following rule:"
rate-monotonic,"As the number of tasks increases, the above formula approaches ln(2) for a worst-case utilization factor of approximately 0.693.  Many tasks sets can be scheduled with a greater utilization factor.  In fact, the average processor utilization threshold for a randomly generated task set is approximately 0.88. See more detail in [LL73]."
rate-monotonic,"This example illustrates the application of the Processor Utilization Rule to an application with three critical periodic tasks.  The following table details the RMS priority, period, execution time, and processor utilization for each task:"
rate-monotonic,"Task RMS
Priority Period Execution
Time Processor
Utilization 1 High 100 15 0.15 2 Medium 200 50 0.25 3 Low 300 100 0.33"
rate-monotonic,Task
rate-monotonic,RMS Priority
rate-monotonic,Period
rate-monotonic,Execution Time
rate-monotonic,Processor Utilization
rate-monotonic,1
rate-monotonic,High
rate-monotonic,100
rate-monotonic,15
rate-monotonic,0.15
rate-monotonic,2
rate-monotonic,Medium
rate-monotonic,200
rate-monotonic,50
rate-monotonic,0.25
rate-monotonic,3
rate-monotonic,Low
rate-monotonic,300
rate-monotonic,100
rate-monotonic,0.33
rate-monotonic,"The total processor utilization for this task set is 0.73 which is below the upper bound of 3 * (2**(1/3) - 1), or 0.779, imposed by the Processor Utilization Rule.  Therefore, this task set is guaranteed to be schedulable using RMS."
rate-monotonic,"If a given set of tasks do exceed the processor utilization upper limit imposed by the Processor Utilization Rule, they can still be guaranteed to meet all their deadlines by application of the First Deadline Rule.  This rule can be stated as follows:"
rate-monotonic,"For a given set of independent periodic tasks, if each task meets its first deadline when all tasks are started at the same time, then the deadlines will always be met for any combination of start times."
rate-monotonic,"A key point with this rule is that ALL periodic tasks are assumed to start at the exact same instant in time.  Although this assumption may seem to be invalid, RTEMS makes it quite easy to ensure.  By having a non-preemptible user initialization task, all application tasks, regardless of priority, can be created and started before the initialization deletes itself.  This technique ensures that all tasks begin to compete for execution time at the same instant - when the user initialization task deletes itself. See more detail in [LSD89]."
rate-monotonic,"The First Deadline Rule can ensure schedulability even when the Processor Utilization Rule fails.  The example below is a modification of the Processor Utilization Rule example where task execution time has been increased from 15 to 25 units.  The following table details the RMS priority, period, execution time, and processor utilization for each task:"
rate-monotonic,"Task RMS
Priority Period Execution
Time Processor
Utilization 1 High 100 25 0.25 2 Medium 200 50 0.25 3 Low 300 100 0.33"
rate-monotonic,Task
rate-monotonic,RMS Priority
rate-monotonic,Period
rate-monotonic,Execution Time
rate-monotonic,Processor Utilization
rate-monotonic,1
rate-monotonic,High
rate-monotonic,100
rate-monotonic,25
rate-monotonic,0.25
rate-monotonic,2
rate-monotonic,Medium
rate-monotonic,200
rate-monotonic,50
rate-monotonic,0.25
rate-monotonic,3
rate-monotonic,Low
rate-monotonic,300
rate-monotonic,100
rate-monotonic,0.33
rate-monotonic,"The total processor utilization for the modified task set is 0.83 which is above the upper bound of 3 * (2**(1/3) - 1), or 0.779, imposed by the Processor Utilization Rule.  Therefore, this task set is not guaranteed to be schedulable using RMS.  However, the First Deadline Rule can guarantee the schedulability of this task set.  This rule calls for one to examine each occurrence of deadline until either all tasks have met their deadline or one task failed to meet its first deadline.  The following table details the time of each deadline occurrence, the maximum number of times each task may have run, the total execution time, and whether all the deadlines have been met:"
rate-monotonic,"Deadline
Time Task
1 Task
2 Task
3 Total
Execution Time All Deadlines
Met? 100 1 1 1 25 + 50 + 100 = 175 NO 200 2 1 1 50 + 50 + 100 = 200 YES"
rate-monotonic,Deadline Time
rate-monotonic,Task 1
rate-monotonic,Task 2
rate-monotonic,Task 3
rate-monotonic,Total Execution Time
rate-monotonic,All Deadlines Met?
rate-monotonic,100
rate-monotonic,1
rate-monotonic,1
rate-monotonic,1
rate-monotonic,25 + 50 + 100 = 175
rate-monotonic,NO
rate-monotonic,200
rate-monotonic,2
rate-monotonic,1
rate-monotonic,1
rate-monotonic,50 + 50 + 100 = 200
rate-monotonic,YES
rate-monotonic,"The key to this analysis is to recognize when each task will execute.  For example at time 100, task 1 must have met its first deadline, but tasks 2 and 3 may also have begun execution.  In this example, at time 100 tasks 1 and 2 have completed execution and thus have met their first deadline.  Tasks 1 and 2 have used (25 + 50) = 75 time units, leaving (100 - 75) = 25 time units for task 3 to begin.  Because task 3 takes 100 ticks to execute, it will not have completed execution at time 100.  Thus at time 100, all of the tasks except task 3 have met their first deadline."
rate-monotonic,"At time 200, task 1 must have met its second deadline and task 2 its first deadline.  As a result, of the first 200 time units, task 1 uses (2 * 25) = 50 and task 2 uses 50, leaving (200 - 100) time units for task 3.  Task 3 requires 100 time units to execute, thus it will have completed execution at time 200. Thus, all of the tasks have met their first deadlines at time 200, and the task set is schedulable using the First Deadline Rule."
rate-monotonic,"The assumptions used to develop the RMS schedulability rules are uncommon in most real-time systems.  For example, it was assumed that tasks have constant unvarying execution time.  It is possible to relax this assumption, simply by using the worst-case execution time of each task."
rate-monotonic,"Another assumption is that the tasks are independent.  This means that the tasks do not wait for one another or contend for resources.  This assumption can be relaxed by accounting for the amount of time a task spends waiting to acquire resources.  Similarly, each task’s execution time must account for any I/O performed and any RTEMS directive calls."
rate-monotonic,"In addition, the assumptions did not account for the time spent executing interrupt service routines.  This can be accounted for by including all the processor utilization by interrupt service routines in the utilization calculation.  Similarly, one should also account for the impact of delays in accessing local memory caused by direct memory access and other processors accessing local dual-ported memory."
rate-monotonic,"The assumption that nonperiodic tasks are used only for initialization or failure-recovery can be relaxed by placing all periodic tasks in the critical task set.  This task set can be scheduled and analyzed using RMS.  All nonperiodic tasks are placed in the non-critical task set.  Although the critical task set can be guaranteed to execute even under transient overload, the non-critical task set is not guaranteed to execute."
rate-monotonic,"In conclusion, the application designer must be fully cognizant of the system and its run-time behavior when performing schedulability analysis for a system using RMS.  Every hardware and software factor which impacts the execution time of each task must be accounted for in the schedulability analysis."
rate-monotonic,"© Copyright 1988, 2024 RTEMS Project and contributors."
rate-monotonic,"This section details the directives of the Rate-Monotonic Manager. A subsection is dedicated to each of this manager’s directives and lists the calling sequence, parameters, description, return values, and notes of the directive."
rate-monotonic,Creates a period.
rate-monotonic,CALLING SEQUENCE:
rate-monotonic,PARAMETERS:
rate-monotonic,This parameter is the object name of the period.
rate-monotonic,"This parameter is the pointer to an rtems_id object.  When the directive call is successful, the identifier of the created period will be stored in this object."
rate-monotonic,DESCRIPTION:
rate-monotonic,This directive creates a period which resides on the local node.  The period has the user-defined object name specified in name The assigned object identifier is returned in id.  This identifier is used to access the period with other rate monotonic related directives.
rate-monotonic,RETURN VALUES:
rate-monotonic,The requested operation was successful.
rate-monotonic,The name parameter was invalid.
rate-monotonic,There was no inactive object available to create a period.  The number of periods available to the application is configured through the CONFIGURE_MAXIMUM_PERIODS application configuration option.
rate-monotonic,NOTES:
rate-monotonic,The calling task is registered as the owner of the created period.  Some directives can be only used by this task for the created period.
rate-monotonic,"For control and maintenance of the period, RTEMS allocates a PCB from the local PCB free pool and initializes it."
rate-monotonic,CONSTRAINTS:
rate-monotonic,The following constraints apply to this directive:
rate-monotonic,"The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted. The number of periods available to the application is configured through the CONFIGURE_MAXIMUM_PERIODS application configuration option. Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace."
rate-monotonic,The directive may be called from within device driver initialization context.
rate-monotonic,The directive may be called from within task context.
rate-monotonic,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
rate-monotonic,The number of periods available to the application is configured through the CONFIGURE_MAXIMUM_PERIODS application configuration option.
rate-monotonic,"Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace."
rate-monotonic,Identifies a period by the object name.
rate-monotonic,CALLING SEQUENCE:
rate-monotonic,PARAMETERS:
rate-monotonic,This parameter is the object name to look up.
rate-monotonic,"This parameter is the pointer to an rtems_id object.  When the directive call is successful, the object identifier of an object with the specified name will be stored in this object."
rate-monotonic,DESCRIPTION:
rate-monotonic,This directive obtains a period identifier associated with the period name specified in name.
rate-monotonic,RETURN VALUES:
rate-monotonic,The requested operation was successful.
rate-monotonic,The id parameter was NULL.
rate-monotonic,The name parameter was 0.
rate-monotonic,There was no object with the specified name on the local node.
rate-monotonic,NOTES:
rate-monotonic,"If the period name is not unique, then the period identifier will match the first period with that name in the search order.  However, this period identifier is not guaranteed to correspond to the desired period."
rate-monotonic,The objects are searched from lowest to the highest index.  Only the local node is searched.
rate-monotonic,The period identifier is used with other rate monotonic related directives to access the period.
rate-monotonic,CONSTRAINTS:
rate-monotonic,The following constraints apply to this directive:
rate-monotonic,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
rate-monotonic,The directive may be called from within any runtime context.
rate-monotonic,The directive will not cause the calling task to be preempted.
rate-monotonic,Cancels the period.
rate-monotonic,CALLING SEQUENCE:
rate-monotonic,PARAMETERS:
rate-monotonic,This parameter is the rate monotonic period identifier.
rate-monotonic,DESCRIPTION:
rate-monotonic,This directive cancels the rate monotonic period specified by id.  This period may be reinitiated by the next invocation of rtems_rate_monotonic_period().
rate-monotonic,RETURN VALUES:
rate-monotonic,The requested operation was successful.
rate-monotonic,There was no rate monotonic period associated with the identifier specified by id.
rate-monotonic,The rate monotonic period was not created by the calling task.
rate-monotonic,CONSTRAINTS:
rate-monotonic,The following constraints apply to this directive:
rate-monotonic,The directive may be called from within task context. The directive will not cause the calling task to be preempted. The directive may be used exclusively by the task which created the associated object.
rate-monotonic,The directive may be called from within task context.
rate-monotonic,The directive will not cause the calling task to be preempted.
rate-monotonic,The directive may be used exclusively by the task which created the associated object.
rate-monotonic,Deletes the period.
rate-monotonic,CALLING SEQUENCE:
rate-monotonic,PARAMETERS:
rate-monotonic,This parameter is the period identifier.
rate-monotonic,DESCRIPTION:
rate-monotonic,"This directive deletes the period specified by id.  If the period is running, it is automatically canceled."
rate-monotonic,RETURN VALUES:
rate-monotonic,The requested operation was successful.
rate-monotonic,There was no period associated with the identifier specified by id.
rate-monotonic,NOTES:
rate-monotonic,The PCB for the deleted period is reclaimed by RTEMS.
rate-monotonic,CONSTRAINTS:
rate-monotonic,The following constraints apply to this directive:
rate-monotonic,"The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted. The calling task does not have to be the task that created the object.  Any local task that knows the object identifier can delete the object. Where the object class corresponding to the directive is configured to use unlimited objects, the directive may free memory to the RTEMS Workspace."
rate-monotonic,The directive may be called from within device driver initialization context.
rate-monotonic,The directive may be called from within task context.
rate-monotonic,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
rate-monotonic,The calling task does not have to be the task that created the object.  Any local task that knows the object identifier can delete the object.
rate-monotonic,"Where the object class corresponding to the directive is configured to use unlimited objects, the directive may free memory to the RTEMS Workspace."
rate-monotonic,"Concludes the current period and start the next period, or gets the period status."
rate-monotonic,CALLING SEQUENCE:
rate-monotonic,PARAMETERS:
rate-monotonic,This parameter is the rate monotonic period identifier.
rate-monotonic,This parameter is the period length in clock ticks or RTEMS_PERIOD_STATUS to get the period status.
rate-monotonic,DESCRIPTION:
rate-monotonic,"This directive initiates the rate monotonic period specified by id  with a length of period ticks specified by length.  If the period is running, then the calling task will block for the remainder of the period before reinitiating the period with the specified period length.  If the period was not running (either expired or never initiated), the period is immediately initiated and the directive returns immediately.  If the period has expired, the postponed job will be released immediately and the following calls of this directive will release postponed jobs until there is no more deadline miss."
rate-monotonic,"If invoked with a period length of RTEMS_PERIOD_STATUS ticks, the current state of the period will be returned.  The directive status indicates the current state of the period.  This does not alter the state or period length of the period."
rate-monotonic,RETURN VALUES:
rate-monotonic,The requested operation was successful.
rate-monotonic,There was no rate monotonic period associated with the identifier specified by id.
rate-monotonic,The rate monotonic period was not created by the calling task.
rate-monotonic,The rate monotonic period has never been initiated (only possible when the length parameter was equal to RTEMS_PERIOD_STATUS).
rate-monotonic,The rate monotonic period has expired.
rate-monotonic,NOTES:
rate-monotonic,Resetting the processor usage time of tasks has no impact on the period status and statistics.
rate-monotonic,CONSTRAINTS:
rate-monotonic,The following constraints apply to this directive:
rate-monotonic,The directive may be called from within task context. The directive may be used exclusively by the task which created the associated object.
rate-monotonic,The directive may be called from within task context.
rate-monotonic,The directive may be used exclusively by the task which created the associated object.
rate-monotonic,Gets the detailed status of the period.
rate-monotonic,CALLING SEQUENCE:
rate-monotonic,PARAMETERS:
rate-monotonic,This parameter is the rate monotonic period identifier.
rate-monotonic,"This parameter is the pointer to an rtems_rate_monotonic_period_status object.  When the directive call is successful, the detailed period status will be stored in this object."
rate-monotonic,DESCRIPTION:
rate-monotonic,This directive returns the detailed status of the rate monotonic period specified by id.  The detailed status of the period will be returned in the members of the period status object referenced by status:
rate-monotonic,"The owner member is set to the identifier of the owner task of the period. The state member is set to the current state of the period. The postponed_jobs_count member is set to the count of jobs which are not released yet. If the current state of the period is RATE_MONOTONIC_INACTIVE, the since_last_period and executed_since_last_period members will be set to zero.  Otherwise, both members will contain time information since the last successful invocation of the rtems_rate_monotonic_period() directive by the owner task.  More specifically, the since_last_period member will be set to the time elapsed since the last successful invocation. The executed_since_last_period member will be set to the processor time consumed by the owner task since the last successful invocation."
rate-monotonic,The owner member is set to the identifier of the owner task of the period.
rate-monotonic,The state member is set to the current state of the period.
rate-monotonic,The postponed_jobs_count member is set to the count of jobs which are not released yet.
rate-monotonic,"If the current state of the period is RATE_MONOTONIC_INACTIVE, the since_last_period and executed_since_last_period members will be set to zero.  Otherwise, both members will contain time information since the last successful invocation of the rtems_rate_monotonic_period() directive by the owner task.  More specifically, the since_last_period member will be set to the time elapsed since the last successful invocation. The executed_since_last_period member will be set to the processor time consumed by the owner task since the last successful invocation."
rate-monotonic,RETURN VALUES:
rate-monotonic,The requested operation was successful.
rate-monotonic,There was no rate monotonic period associated with the identifier specified by id.
rate-monotonic,The status parameter was NULL.
rate-monotonic,CONSTRAINTS:
rate-monotonic,The following constraints apply to this directive:
rate-monotonic,The directive may be called from within task context. The directive may be called from within interrupt context. The directive will not cause the calling task to be preempted.
rate-monotonic,The directive may be called from within task context.
rate-monotonic,The directive may be called from within interrupt context.
rate-monotonic,The directive will not cause the calling task to be preempted.
rate-monotonic,Gets the statistics of the period.
rate-monotonic,CALLING SEQUENCE:
rate-monotonic,PARAMETERS:
rate-monotonic,This parameter is the rate monotonic period identifier.
rate-monotonic,"This parameter is the pointer to an rtems_rate_monotonic_period_statistics object.  When the directive call is successful, the period statistics will be stored in this object."
rate-monotonic,DESCRIPTION:
rate-monotonic,This directive returns the statistics of the rate monotonic period specified by id.  The statistics of the period will be returned in the members of the period statistics object referenced by status:
rate-monotonic,The count member is set to the number of periods executed. The missed_count member is set to the number of periods missed. The min_cpu_time member is set to the least amount of processor time used in the period. The max_cpu_time member is set to the highest amount of processor time used in the period. The total_cpu_time member is set to the total amount of processor time used in the period. The min_wall_time member is set to the least amount of CLOCK_MONOTONIC time used in the period. The max_wall_time member is set to the highest amount of CLOCK_MONOTONIC time used in the period. The total_wall_time member is set to the total amount of CLOCK_MONOTONIC time used in the period.
rate-monotonic,The count member is set to the number of periods executed.
rate-monotonic,The missed_count member is set to the number of periods missed.
rate-monotonic,The min_cpu_time member is set to the least amount of processor time used in the period.
rate-monotonic,The max_cpu_time member is set to the highest amount of processor time used in the period.
rate-monotonic,The total_cpu_time member is set to the total amount of processor time used in the period.
rate-monotonic,The min_wall_time member is set to the least amount of CLOCK_MONOTONIC time used in the period.
rate-monotonic,The max_wall_time member is set to the highest amount of CLOCK_MONOTONIC time used in the period.
rate-monotonic,The total_wall_time member is set to the total amount of CLOCK_MONOTONIC time used in the period.
rate-monotonic,RETURN VALUES:
rate-monotonic,The requested operation was successful.
rate-monotonic,There was no rate monotonic period associated with the identifier specified by id.
rate-monotonic,The status parameter was NULL.
rate-monotonic,CONSTRAINTS:
rate-monotonic,The following constraints apply to this directive:
rate-monotonic,The directive may be called from within task context. The directive may be called from within interrupt context. The directive will not cause the calling task to be preempted.
rate-monotonic,The directive may be called from within task context.
rate-monotonic,The directive may be called from within interrupt context.
rate-monotonic,The directive will not cause the calling task to be preempted.
rate-monotonic,Resets the statistics of the period.
rate-monotonic,CALLING SEQUENCE:
rate-monotonic,PARAMETERS:
rate-monotonic,This parameter is the rate monotonic period identifier.
rate-monotonic,DESCRIPTION:
rate-monotonic,This directive resets the statistics of the rate monotonic period specified by id.
rate-monotonic,RETURN VALUES:
rate-monotonic,The requested operation was successful.
rate-monotonic,There was no rate monotonic period associated with the identifier specified by id.
rate-monotonic,CONSTRAINTS:
rate-monotonic,The following constraints apply to this directive:
rate-monotonic,The directive may be called from within task context. The directive may be called from within interrupt context. The directive will not cause the calling task to be preempted.
rate-monotonic,The directive may be called from within task context.
rate-monotonic,The directive may be called from within interrupt context.
rate-monotonic,The directive will not cause the calling task to be preempted.
rate-monotonic,Resets the statistics of all periods.
rate-monotonic,CALLING SEQUENCE:
rate-monotonic,DESCRIPTION:
rate-monotonic,This directive resets the statistics information associated with all rate monotonic period instances.
rate-monotonic,CONSTRAINTS:
rate-monotonic,The following constraints apply to this directive:
rate-monotonic,The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
rate-monotonic,The directive may be called from within task context.
rate-monotonic,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
rate-monotonic,Reports the period statistics using the printk() printer.
rate-monotonic,CALLING SEQUENCE:
rate-monotonic,DESCRIPTION:
rate-monotonic,This directive prints a report on all active periods which have executed at least one period using the printk() printer.
rate-monotonic,CONSTRAINTS:
rate-monotonic,The following constraints apply to this directive:
rate-monotonic,The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
rate-monotonic,The directive may be called from within task context.
rate-monotonic,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
rate-monotonic,Reports the period statistics using the printer plugin.
rate-monotonic,CALLING SEQUENCE:
rate-monotonic,PARAMETERS:
rate-monotonic,This parameter is the printer plugin to output the report.
rate-monotonic,DESCRIPTION:
rate-monotonic,This directive prints a report on all active periods which have executed at least one period using the printer plugin specified by printer.
rate-monotonic,CONSTRAINTS:
rate-monotonic,The following constraints apply to this directive:
rate-monotonic,The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
rate-monotonic,The directive may be called from within task context.
rate-monotonic,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
rate-monotonic,"© Copyright 1988, 2024 RTEMS Project and contributors."
rate-monotonic,"The Rate-Monotonic Manager provides facilities to implement tasks which execute in a periodic fashion.  Critically, it also gathers information about the execution of those periods and can provide important statistics to the user which can be used to analyze and tune the application. The directives provided by the Rate-Monotonic Manager are:"
rate-monotonic,"rtems_rate_monotonic_create() - Creates a period. rtems_rate_monotonic_ident() - Identifies a period by the object name. rtems_rate_monotonic_cancel() - Cancels the period. rtems_rate_monotonic_delete() - Deletes the period. rtems_rate_monotonic_period() - Concludes the current period and start the next period, or gets the period status. rtems_rate_monotonic_get_status() - Gets the detailed status of the period. rtems_rate_monotonic_get_statistics() - Gets the statistics of the period. rtems_rate_monotonic_reset_statistics() - Resets the statistics of the period. rtems_rate_monotonic_reset_all_statistics() - Resets the statistics of all periods. rtems_rate_monotonic_report_statistics() - Reports the period statistics using the printk() printer. rtems_rate_monotonic_report_statistics_with_plugin() - Reports the period statistics using the printer plugin."
rate-monotonic,rtems_rate_monotonic_create() - Creates a period.
rate-monotonic,rtems_rate_monotonic_ident() - Identifies a period by the object name.
rate-monotonic,rtems_rate_monotonic_cancel() - Cancels the period.
rate-monotonic,rtems_rate_monotonic_delete() - Deletes the period.
rate-monotonic,"rtems_rate_monotonic_period() - Concludes the current period and start the next period, or gets the period status."
rate-monotonic,rtems_rate_monotonic_get_status() - Gets the detailed status of the period.
rate-monotonic,rtems_rate_monotonic_get_statistics() - Gets the statistics of the period.
rate-monotonic,rtems_rate_monotonic_reset_statistics() - Resets the statistics of the period.
rate-monotonic,rtems_rate_monotonic_reset_all_statistics() - Resets the statistics of all periods.
rate-monotonic,rtems_rate_monotonic_report_statistics() - Reports the period statistics using the printk() printer.
rate-monotonic,rtems_rate_monotonic_report_statistics_with_plugin() - Reports the period statistics using the printer plugin.
rate-monotonic,"© Copyright 1988, 2024 RTEMS Project and contributors."
rate-monotonic,The rtems_rate_monotonic_create directive creates a rate monotonic period which is to be used by the calling task to delineate a period.  RTEMS allocates a Period Control Block (PCB) from the PCB free list.  This data structure is used by RTEMS to manage the newly created rate monotonic period.  RTEMS returns a unique period ID to the application which is used by other rate monotonic manager directives to access this rate monotonic period.
rate-monotonic,"The rtems_rate_monotonic_period directive is used to establish and maintain periodic execution utilizing a previously created rate monotonic period.  Once initiated by the rtems_rate_monotonic_period directive, the period is said to run until it either expires or is reinitiated.  The state of the rate monotonic period results in one of the following scenarios:"
rate-monotonic,"If the rate monotonic period is running, the calling task will be blocked for the remainder of the outstanding period and, upon completion of that period, the period will be reinitiated with the specified period. If the rate monotonic period is not currently running and has not expired, it is initiated with a length of period ticks and the calling task returns immediately. If the rate monotonic period has expired before the task invokes the rtems_rate_monotonic_period directive, the postponed job will be released until there is no more postponed jobs. The calling task returns immediately with a timeout error status. In the watchdog routine, the period will still be updated periodically and track the count of the postponed jobs [CvdBruggenC16]. Please note, the count of the postponed jobs is only saturated until 0xffffffff."
rate-monotonic,"If the rate monotonic period is running, the calling task will be blocked for the remainder of the outstanding period and, upon completion of that period, the period will be reinitiated with the specified period."
rate-monotonic,"If the rate monotonic period is not currently running and has not expired, it is initiated with a length of period ticks and the calling task returns immediately."
rate-monotonic,"If the rate monotonic period has expired before the task invokes the rtems_rate_monotonic_period directive, the postponed job will be released until there is no more postponed jobs. The calling task returns immediately with a timeout error status. In the watchdog routine, the period will still be updated periodically and track the count of the postponed jobs [CvdBruggenC16]. Please note, the count of the postponed jobs is only saturated until 0xffffffff."
rate-monotonic,"If the rtems_rate_monotonic_period directive is invoked with a period of RTEMS_PERIOD_STATUS ticks, the current state of the specified rate monotonic period will be returned.  The following table details the relationship between the period’s status and the directive status code returned by the rtems_rate_monotonic_period directive:"
rate-monotonic,RTEMS_SUCCESSFUL period is running RTEMS_TIMEOUT period has expired RTEMS_NOT_DEFINED period has never been initiated
rate-monotonic,RTEMS_SUCCESSFUL
rate-monotonic,period is running
rate-monotonic,RTEMS_TIMEOUT
rate-monotonic,period has expired
rate-monotonic,RTEMS_NOT_DEFINED
rate-monotonic,period has never been initiated
rate-monotonic,Obtaining the status of a rate monotonic period does not alter the state or length of that period.
rate-monotonic,The rtems_rate_monotonic_cancel directive is used to stop the period maintained by the specified rate monotonic period.  The period is stopped and the rate monotonic period can be reinitiated using the rtems_rate_monotonic_period directive.
rate-monotonic,"The rtems_rate_monotonic_delete directive is used to delete a rate monotonic period.  If the period is running and has not expired, the period is automatically canceled.  The rate monotonic period’s control block is returned to the PCB free list when it is deleted.  A rate monotonic period can be deleted by a task other than the task which created the period."
rate-monotonic,The following sections illustrate common uses of rate monotonic periods to construct periodic tasks.
rate-monotonic,"This example consists of a single periodic task which, after initialization, executes every 100 clock ticks."
rate-monotonic,"The above task creates a rate monotonic period as part of its initialization. The first time the loop is executed, the rtems_rate_monotonic_period directive will initiate the period for 100 ticks and return immediately. Subsequent invocations of the rtems_rate_monotonic_period directive will result in the task blocking for the remainder of the 100 tick period.  If, for any reason, the body of the loop takes more than 100 ticks to execute, the rtems_rate_monotonic_period directive will return the RTEMS_TIMEOUT status. If the above task misses its deadline, it will delete the rate monotonic period and itself."
rate-monotonic,"This example consists of a single periodic task which, after initialization, performs two sets of actions every 100 clock ticks.  The first set of actions is performed in the first forty clock ticks of every 100 clock ticks, while the second set of actions is performed between the fortieth and seventieth clock ticks.  The last thirty clock ticks are not used by this task."
rate-monotonic,"The above task creates two rate monotonic periods as part of its initialization.  The first time the loop is executed, the rtems_rate_monotonic_period directive will initiate the period_1 period for 100 ticks and return immediately.  Subsequent invocations of the rtems_rate_monotonic_period directive for period_1 will result in the task blocking for the remainder of the 100 tick period.  The period_2 period is used to control the execution time of the two sets of actions within each 100 tick period established by period_1.  The rtems_rate_monotonic_cancel( period_2 ) call is performed to ensure that the period_2 period does not expire while the task is blocked on the period_1 period.  If this cancel operation were not performed, every time the rtems_rate_monotonic_period( period_2, 40 ) call is executed, except for the initial one, a directive status of RTEMS_TIMEOUT is returned.  It is important to note that every time this call is made, the period_2 period will be initiated immediately and the task will not block."
rate-monotonic,"If, for any reason, the task misses any deadline, the rtems_rate_monotonic_period directive will return the RTEMS_TIMEOUT directive status. If the above task misses its deadline, it will delete the rate monotonic periods and itself."
rate-monotonic,"© Copyright 1988, 2024 RTEMS Project and contributors."
region,"A region makes up a physically contiguous memory space with user-defined boundaries from which variable-sized segments are dynamically allocated and deallocated.  A segment is a variable size section of memory which is allocated in multiples of a user-defined page size.  This page size is required to be a multiple of four greater than or equal to four.  For example, if a request for a 350-byte segment is made in a region with 256-byte pages, then a 512-byte segment is allocated."
region,"Regions are organized as doubly linked chains of variable sized memory blocks. Memory requests are allocated using a first-fit algorithm.  If available, the requester receives the number of bytes requested (rounded up to the next page size).  RTEMS requires some overhead from the region’s memory for each segment that is allocated.  Therefore, an application should only modify the memory of a segment that has been obtained from the region.  The application should NOT modify the memory outside of any obtained segments and within the region’s boundaries while the region is currently active in the system."
region,"Upon return to the region, the free block is coalesced with its neighbors (if free) on both sides to produce the largest possible unused block."
region,"In general, an attribute set is built by a bitwise OR of the desired attribute components.  The set of valid region attributes is provided in the following table:"
region,RTEMS_FIFO tasks wait by FIFO (default) RTEMS_PRIORITY tasks wait by priority
region,RTEMS_FIFO
region,tasks wait by FIFO (default)
region,RTEMS_PRIORITY
region,tasks wait by priority
region,"Attribute values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each attribute appears exactly once in the component list.  An attribute listed as a default is not required to appear in the attribute list, although it is a good programming practice to specify default attributes.  If all defaults are desired, the attribute RTEMS_DEFAULT_ATTRIBUTES should be specified on this call."
region,This example demonstrates the attribute_set parameter needed to create a region with the task priority waiting queue discipline.  The attribute_set parameter to the rtems_region_create directive should be RTEMS_PRIORITY.
region,"In general, an option is built by a bitwise OR of the desired option components.  The set of valid options for the rtems_region_get_segment directive are listed in the following table:"
region,RTEMS_WAIT task will wait for segment (default) RTEMS_NO_WAIT task should not wait
region,RTEMS_WAIT
region,task will wait for segment (default)
region,RTEMS_NO_WAIT
region,task should not wait
region,"Option values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each option appears exactly once in the component list.  An option listed as a default is not required to appear in the option list, although it is a good programming practice to specify default options.  If all defaults are desired, the option RTEMS_DEFAULT_OPTIONS should be specified on this call."
region,This example demonstrates the option parameter needed to poll for a segment. The option parameter passed to the rtems_region_get_segment directive should be RTEMS_NO_WAIT.
region,"© Copyright 1988, 2024 RTEMS Project and contributors."
region,"This section details the directives of the Region Manager. A subsection is dedicated to each of this manager’s directives and lists the calling sequence, parameters, description, return values, and notes of the directive."
region,Creates a region.
region,CALLING SEQUENCE:
region,PARAMETERS:
region,This parameter is the object name of the region.
region,This parameter is the starting address of the memory area managed by the region.
region,This parameter is the length in bytes of the memory area managed by the region.
region,This parameter is the alignment of the starting address and length of each allocated segment of the region.
region,This parameter is the attribute set of the region.
region,"This parameter is the pointer to an rtems_id object.  When the directive call is successful, the identifier of the created region will be stored in this object."
region,DESCRIPTION:
region,This directive creates a region which resides on the local node.  The region has the user-defined object name specified in name.  The assigned object identifier is returned in id.  This identifier is used to access the region with other region related directives.
region,The region manages the contiguous memory area which starts at starting_address and is length bytes long.  The memory area shall be large enough to contain some internal region administration data.
region,The starting address and length of segments allocated from the region will be an integral multiple of page_size.  The specified page size will be aligned to an implementation-dependent minimum alignment if necessary.
region,"The attribute set specified in attribute_set is built through a bitwise or of the attribute constants described below.  Not all combinations of attributes are allowed.  Some attributes are mutually exclusive.  If mutually exclusive attributes are combined, the behaviour is undefined. Attributes not mentioned below are not evaluated by this directive and have no effect.  Default attributes can be selected by using the RTEMS_DEFAULT_ATTRIBUTES constant."
region,The task wait queue discipline is selected by the mutually exclusive RTEMS_FIFO and RTEMS_PRIORITY attributes. The discipline defines the order in which tasks wait for allocatable segments on a currently empty region.
region,The FIFO discipline is the default and can be emphasized through use of the RTEMS_FIFO attribute. The priority discipline is selected by the RTEMS_PRIORITY attribute.
region,The FIFO discipline is the default and can be emphasized through use of the RTEMS_FIFO attribute.
region,The priority discipline is selected by the RTEMS_PRIORITY attribute.
region,RETURN VALUES:
region,The requested operation was successful.
region,The name parameter was invalid.
region,The id parameter was NULL.
region,The starting_address parameter was NULL.
region,There was no inactive object available to create a region.  The number of regions available to the application is configured through the CONFIGURE_MAXIMUM_REGIONS application configuration option.
region,The page_size parameter was invalid.
region,The memory area specified in starting_address and length was too small.
region,NOTES:
region,"For control and maintenance of the region, RTEMS allocates a RNCB from the local RNCB free pool and initializes it."
region,CONSTRAINTS:
region,The following constraints apply to this directive:
region,"The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted. The number of regions available to the application is configured through the CONFIGURE_MAXIMUM_REGIONS application configuration option. Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace."
region,The directive may be called from within device driver initialization context.
region,The directive may be called from within task context.
region,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
region,The number of regions available to the application is configured through the CONFIGURE_MAXIMUM_REGIONS application configuration option.
region,"Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace."
region,Identifies a region by the object name.
region,CALLING SEQUENCE:
region,PARAMETERS:
region,This parameter is the object name to look up.
region,"This parameter is the pointer to an rtems_id object.  When the directive call is successful, the object identifier of an object with the specified name will be stored in this object."
region,DESCRIPTION:
region,This directive obtains a region identifier associated with the region name specified in name.
region,RETURN VALUES:
region,The requested operation was successful.
region,The id parameter was NULL.
region,The name parameter was 0.
region,There was no object with the specified name on the local node.
region,NOTES:
region,"If the region name is not unique, then the region identifier will match the first region with that name in the search order.  However, this region identifier is not guaranteed to correspond to the desired region."
region,The objects are searched from lowest to the highest index.  Only the local node is searched.
region,The region identifier is used with other region related directives to access the region.
region,CONSTRAINTS:
region,The following constraints apply to this directive:
region,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
region,The directive may be called from within any runtime context.
region,The directive will not cause the calling task to be preempted.
region,Deletes the region.
region,CALLING SEQUENCE:
region,PARAMETERS:
region,This parameter is the region identifier.
region,DESCRIPTION:
region,This directive deletes the region specified by id.
region,RETURN VALUES:
region,The requested operation was successful.
region,There was no region associated with the identifier specified by id.
region,There were segments of the region still in use.
region,NOTES:
region,The region cannot be deleted if any of its segments are still allocated.
region,The RNCB for the deleted region is reclaimed by RTEMS.
region,CONSTRAINTS:
region,The following constraints apply to this directive:
region,"The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted. The calling task does not have to be the task that created the object.  Any local task that knows the object identifier can delete the object. Where the object class corresponding to the directive is configured to use unlimited objects, the directive may free memory to the RTEMS Workspace."
region,The directive may be called from within device driver initialization context.
region,The directive may be called from within task context.
region,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
region,The calling task does not have to be the task that created the object.  Any local task that knows the object identifier can delete the object.
region,"Where the object class corresponding to the directive is configured to use unlimited objects, the directive may free memory to the RTEMS Workspace."
region,Extends the region.
region,CALLING SEQUENCE:
region,PARAMETERS:
region,This parameter is the region identifier.
region,This parameter is the starting address of the memory area to extend the region.
region,This parameter is the length in bytes of the memory area to extend the region.
region,DESCRIPTION:
region,This directive adds the memory area which starts at starting_address for length bytes to the region specified by id.
region,RETURN VALUES:
region,The requested operation was successful.
region,The starting_address parameter was NULL.
region,There was no region associated with the identifier specified by id.
region,The memory area specified by starting_address and length was insufficient to extend the heap.
region,NOTES:
region,There are no alignment requirements for the memory area.  The memory area must be big enough to contain some maintenance blocks.  It must not overlap parts of the current heap memory areas.  Disconnected memory areas added to the heap will lead to used blocks which cover the gaps.  Extending with an inappropriate memory area will corrupt the heap resulting in undefined behaviour.
region,CONSTRAINTS:
region,The following constraints apply to this directive:
region,The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
region,The directive may be called from within device driver initialization context.
region,The directive may be called from within task context.
region,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
region,Gets a segment from the region.
region,CALLING SEQUENCE:
region,PARAMETERS:
region,This parameter is the region identifier.
region,This parameter is the size in bytes of the segment to allocate.
region,This parameter is the option set.
region,This parameter is the timeout in clock ticks if the RTEMS_WAIT option is set.  Use RTEMS_NO_TIMEOUT to wait potentially forever.
region,"This parameter is the pointer to a void pointer object.  When the directive call is successful, the begin address of the allocated segment will be stored in this object."
region,DESCRIPTION:
region,This directive gets a segment from the region specified by id.
region,"The option set specified in option_set is built through a bitwise or of the option constants described below.  Not all combinations of options are allowed.  Some options are mutually exclusive.  If mutually exclusive options are combined, the behaviour is undefined.  Options not mentioned below are not evaluated by this directive and have no effect. Default options can be selected by using the RTEMS_DEFAULT_OPTIONS constant."
region,The calling task can wait or try to get a segment from the region according to the mutually exclusive RTEMS_WAIT and RTEMS_NO_WAIT options.
region,"Waiting to get a segment from the region is the default and can be emphasized through the use of the RTEMS_WAIT option. The timeout parameter defines how long the calling task is willing to wait. Use RTEMS_NO_TIMEOUT to wait potentially forever, otherwise set a timeout interval in clock ticks. Trying to get a segment from the region is selected by the RTEMS_NO_WAIT option.  If this option is defined, then the timeout parameter is ignored.  When a segment from the region cannot be immediately allocated, then the RTEMS_UNSATISFIED status is returned."
region,"Waiting to get a segment from the region is the default and can be emphasized through the use of the RTEMS_WAIT option. The timeout parameter defines how long the calling task is willing to wait. Use RTEMS_NO_TIMEOUT to wait potentially forever, otherwise set a timeout interval in clock ticks."
region,"Trying to get a segment from the region is selected by the RTEMS_NO_WAIT option.  If this option is defined, then the timeout parameter is ignored.  When a segment from the region cannot be immediately allocated, then the RTEMS_UNSATISFIED status is returned."
region,"With either RTEMS_WAIT or RTEMS_NO_WAIT if there is a segment of the requested size is available, then it is returned in segment and this directive returns immediately with the RTEMS_SUCCESSFUL status code."
region,"If the calling task chooses to return immediately and the region has no segment of the requested size available, then the directive returns immediately with the RTEMS_UNSATISFIED status code.  If the calling task chooses to wait for a segment, then the calling task is placed on the region wait queue and blocked.  If the region was created with the RTEMS_PRIORITY option specified, then the calling task is inserted into the wait queue according to its priority.  But, if the region was created with the RTEMS_FIFO option specified, then the calling task is placed at the rear of the wait queue."
region,RETURN VALUES:
region,The requested operation was successful.
region,The segment parameter was NULL.
region,The size parameter was zero.
region,There was no region associated with the identifier specified by id.
region,The size parameter exceeded the maximum segment size which is possible for the region.
region,The region had no segment of the requested size immediately available.
region,The timeout happened while the calling task was waiting to get a segment from the region.
region,NOTES:
region,The actual length of the allocated segment may be larger than the requested size because a segment size is always a multiple of the region’s page size.
region,CONSTRAINTS:
region,The following constraints apply to this directive:
region,"The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted. When the request cannot be immediately satisfied and the RTEMS_WAIT option is set, the calling task blocks at some point during the directive call. The timeout functionality of the directive requires a clock tick."
region,The directive may be called from within device driver initialization context.
region,The directive may be called from within task context.
region,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
region,"When the request cannot be immediately satisfied and the RTEMS_WAIT option is set, the calling task blocks at some point during the directive call."
region,The timeout functionality of the directive requires a clock tick.
region,Returns the segment to the region.
region,CALLING SEQUENCE:
region,PARAMETERS:
region,This parameter is the region identifier.
region,This parameter is the begin address of the segment to return.
region,DESCRIPTION:
region,"This directive returns the segment specified by segment to the region specified by id.  The returned segment is merged with its neighbors to form the largest possible segment.  The first task on the wait queue is examined to determine if its segment request can now be satisfied.  If so, it is given a segment and unblocked.  This process is repeated until the first task’s segment request cannot be satisfied."
region,RETURN VALUES:
region,The requested operation was successful.
region,There was no region associated with the identifier specified by id.
region,The segment was not within the region.
region,NOTES:
region,This directive will cause the calling task to be preempted if one or more local tasks are waiting for a segment and the following conditions exist:
region,A waiting task has a higher priority than the calling task. The size of the segment required by the waiting task is less than or equal to the size of the segment returned.
region,A waiting task has a higher priority than the calling task.
region,The size of the segment required by the waiting task is less than or equal to the size of the segment returned.
region,CONSTRAINTS:
region,The following constraints apply to this directive:
region,The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may unblock a task.  This may cause the calling task to be preempted. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
region,The directive may be called from within device driver initialization context.
region,The directive may be called from within task context.
region,The directive may unblock a task.  This may cause the calling task to be preempted.
region,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
region,Changes the size of the segment.
region,CALLING SEQUENCE:
region,PARAMETERS:
region,This parameter is the region identifier.
region,This parameter is the begin address of the segment to resize.
region,This parameter is the requested new size of the segment.
region,"This parameter is the pointer to an uintptr_t object.  When the directive call is successful, the old size of the segment will be stored in this object."
region,DESCRIPTION:
region,"This directive is used to increase or decrease the size of the segment of the region specified by id.  When increasing the size of a segment, it is possible that there is no memory available contiguous to the segment.  In this case, the request is unsatisfied."
region,RETURN VALUES:
region,The requested operation was successful.
region,The old_size parameter was NULL.
region,There was no region associated with the identifier specified by id.
region,The segment was not within the region.
region,The region was unable to resize the segment.
region,NOTES:
region,"If an attempt to increase the size of a segment fails, then the application may want to allocate a new segment of the desired size, copy the contents of the original segment to the new, larger segment and then return the original segment."
region,CONSTRAINTS:
region,The following constraints apply to this directive:
region,The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
region,The directive may be called from within device driver initialization context.
region,The directive may be called from within task context.
region,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
region,Gets the region information.
region,CALLING SEQUENCE:
region,PARAMETERS:
region,This parameter is the region identifier.
region,"This parameter is the pointer to a Heap_Information_block object. When the directive call is successful, the information of the region will be stored in this object."
region,DESCRIPTION:
region,This directive is used to obtain information about the used and free memory in the region specified by id. This is a snapshot at the time of the call. The information will be returned in the structure pointed to by the_info.
region,RETURN VALUES:
region,The requested operation was successful.
region,The the_info parameter was NULL.
region,There was no region associated with the identifier specified by id.
region,NOTES:
region,"This is primarily intended as a mechanism to obtain a diagnostic information. This method forms am O(n) scan of the free and an O(n) scan of the used blocks in the region to calculate the information provided. Given that the execution time is driven by the number of used and free blocks, it can take a non-deterministic time to execute."
region,To get only the free information of the region use rtems_region_get_free_information().
region,CONSTRAINTS:
region,The following constraints apply to this directive:
region,The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
region,The directive may be called from within device driver initialization context.
region,The directive may be called from within task context.
region,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
region,Gets the region free information.
region,CALLING SEQUENCE:
region,PARAMETERS:
region,This parameter is the region identifier.
region,"This parameter is the pointer to a Heap_Information_block object. When the directive call is successful, the free information of the region will be stored in this object."
region,DESCRIPTION:
region,This directive is used to obtain information about the free memory in the region specified by id. This is a snapshot at the time of the call. The information will be returned in the structure pointed to by the_info.
region,RETURN VALUES:
region,The requested operation was successful.
region,The the_info parameter was NULL.
region,There was no region associated with the identifier specified by id.
region,NOTES:
region,This directive uses the same structure to return information as the rtems_region_get_information() directive but does not fill in the used information.
region,"This is primarily intended as a mechanism to obtain a diagnostic information. This method forms am O(n) scan of the free in the region to calculate the information provided. Given that the execution time is driven by the number of used and free blocks, it can take a non-deterministic time to execute. Typically, there are many used blocks and a much smaller number of used blocks making a call to this directive less expensive than a call to rtems_region_get_information()."
region,CONSTRAINTS:
region,The following constraints apply to this directive:
region,The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
region,The directive may be called from within device driver initialization context.
region,The directive may be called from within task context.
region,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
region,Gets the size of the region segment.
region,CALLING SEQUENCE:
region,PARAMETERS:
region,This parameter is the region identifier.
region,This parameter is the begin address of the segment.
region,"This parameter is the pointer to a uintptr_t object.  When the directive call is successful, the size of the segment in bytes will be stored in this object."
region,DESCRIPTION:
region,This directive obtains the size in bytes of the segment specified by segment of the region specified by id in size.
region,RETURN VALUES:
region,The requested operation was successful.
region,The segment parameter was NULL.
region,The size parameter was NULL.
region,There was no region associated with the identifier specified by id.
region,The segment was not within the region.
region,NOTES:
region,The actual length of the allocated segment may be larger than the requested size because a segment size is always a multiple of the region’s page size.
region,CONSTRAINTS:
region,The following constraints apply to this directive:
region,The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
region,The directive may be called from within device driver initialization context.
region,The directive may be called from within task context.
region,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
region,"© Copyright 1988, 2024 RTEMS Project and contributors."
region,The Region Manager provides facilities to dynamically allocate memory in variable sized units. The directives provided by the Region Manager are:
region,rtems_region_create() - Creates a region. rtems_region_ident() - Identifies a region by the object name. rtems_region_delete() - Deletes the region. rtems_region_extend() - Extends the region. rtems_region_get_segment() - Gets a segment from the region. rtems_region_return_segment() - Returns the segment to the region. rtems_region_resize_segment() - Changes the size of the segment. rtems_region_get_information() - Gets the region information. rtems_region_get_free_information() - Gets the region free information. rtems_region_get_segment_size() - Gets the size of the region segment.
region,rtems_region_create() - Creates a region.
region,rtems_region_ident() - Identifies a region by the object name.
region,rtems_region_delete() - Deletes the region.
region,rtems_region_extend() - Extends the region.
region,rtems_region_get_segment() - Gets a segment from the region.
region,rtems_region_return_segment() - Returns the segment to the region.
region,rtems_region_resize_segment() - Changes the size of the segment.
region,rtems_region_get_information() - Gets the region information.
region,rtems_region_get_free_information() - Gets the region free information.
region,rtems_region_get_segment_size() - Gets the size of the region segment.
region,"© Copyright 1988, 2024 RTEMS Project and contributors."
region,The rtems_region_create directive creates a region with the user-defined name.  The user may select FIFO or task priority as the method for placing waiting tasks in the task wait queue.  RTEMS allocates a Region Control Block (RNCB) from the RNCB free list to maintain the newly created region.  RTEMS also generates a unique region ID which is returned to the calling task.
region,"It is not possible to calculate the exact number of bytes available to the user since RTEMS requires overhead for each segment allocated.  For example, a region with one segment that is the size of the entire region has more available bytes than a region with two segments that collectively are the size of the entire region.  This is because the region with one segment requires only the overhead for one segment, while the other region requires the overhead for two segments."
region,"Due to automatic coalescing, the number of segments in the region dynamically changes.  Therefore, the total overhead required by RTEMS dynamically changes."
region,"When a region is created, RTEMS generates a unique region ID and assigns it to the created region until it is deleted.  The region ID may be obtained by either of two methods.  First, as the result of an invocation of the rtems_region_create directive, the region ID is stored in a user provided location.  Second, the region ID may be obtained later using the rtems_region_ident directive.  The region ID is used by other region manager directives to access this region."
region,The rtems_region_extend directive may be used to add memory to an existing region.  The caller specifies the size in bytes and starting address of the memory being added.
region,"The rtems_region_get_segment directive attempts to acquire a segment from a specified region.  If the region has enough available free memory, then a segment is returned successfully to the caller.  When the segment cannot be allocated, one of the following situations applies:"
region,"By default, the calling task will wait forever to acquire the segment. Specifying the RTEMS_NO_WAIT option forces an immediate return with an error status code. Specifying a timeout limits the interval the task will wait before returning with an error status code."
region,"By default, the calling task will wait forever to acquire the segment."
region,Specifying the RTEMS_NO_WAIT option forces an immediate return with an error status code.
region,Specifying a timeout limits the interval the task will wait before returning with an error status code.
region,"If the task waits for the segment, then it is placed in the region’s task wait queue in either FIFO or task priority order.  All tasks waiting on a region are returned an error when the message queue is deleted."
region,"When a segment is returned to a region by the rtems_region_return_segment directive, it is merged with its unallocated neighbors to form the largest possible segment.  The first task on the wait queue is examined to determine if its segment request can now be satisfied.  If so, it is given a segment and unblocked.  This process is repeated until the first task’s segment request cannot be satisfied."
region,The rtems_region_get_segment_size directive returns the size in bytes of the specified segment.  The size returned includes any “extra” memory included in the segment because of rounding up to a page size boundary.
region,"The rtems_region_resize_segment directive is used to change the size in bytes of the specified segment.  The size may be increased or decreased.  When increasing the size of a segment, it is possible that the request cannot be satisfied.  This directive provides functionality similar to the realloc() function in the Standard C Library."
region,"A region can be removed from the system and returned to RTEMS with the rtems_region_delete directive.  When a region is deleted, its control block is returned to the RNCB free list.  A region with segments still allocated is not allowed to be deleted.  Any task attempting to do so will be returned an error.  As a result of this directive, all tasks blocked waiting to obtain a segment from the region will be readied and returned a status code which indicates that the region was deleted."
region,"© Copyright 1988, 2024 RTEMS Project and contributors."
regulator,"The regulator provides facilities to accept bursty input and buffer it as needed before delivering it at a pre-defined periodic rate. The input is referred to as the Source, with the output referred to as the Destination. Messages are accepted from the Source and delivered to the Destination by a user-provided Delivery function."
regulator,The Regulator implementation uses the RTEMS Classic API Partition Manager to manage the buffer pool and the RTEMS Classic API Message Queue Manager to send the buffer to the Delivery thread. The Delivery thread invokes a user-provided delivery function to get the message to the Destination.
regulator,"The regulator is designed to sit logically between two entities – a source and a destination, where it limits the traffic sent to the destination to prevent it from being flooded with messages from the source. This can be used to accommodate bursts of input from a source and meter it out to a destination.  The maximum number of messages which can be buffered in the regulator is specified by the maximum_messages field in the rtems_regulator_attributes structure passed as an argument to rtems_regulator_create()."
regulator,"The regulator library accepts an input stream of messages from a source and delivers them to a destination. The regulator assumes that the input stream from the source contains sporadic bursts of data which can exceed the acceptable rate of the destination. By limiting the message rate, the regulator prevents an overflow of messages."
regulator,"The regulator can be configured for the input buffering required to manage the maximum burst and for the metering rate for the delivery. The delivery rate is in messages per second. If the sender produces data too fast, the regulator will buffer the configured number of messages."
regulator,"A configuration capability is provided to allow for adaptation to different message streams. The regulator can also support running multiple instances, which could be used on independent message streams."
regulator,"It is assumed that the application has a design limit on the number of messages which may be buffered. All messages accepted by the regulator, assuming no overflow on input, will eventually be output by the Delivery thread."
regulator,The Source sends buffers to the Regulator instance. The Regulator then sends the buffer via a message queue which delivers them to the Delivery thread.  The Delivery thread executes periodically at a rate specified by the delivery_thread_period field in the rtems_regulator_attributes structure passed as an argument to rtems_regulator_create().
regulator,"During each period, the Delivery thread attempts to receive up to maximum_to_dequeue_per_period number of buffers and invoke the Delivery function to deliver each of them to the Destination. The maximum_to_dequeue_per_period field in the rtems_regulator_attributes structure passed as an argument to rtems_regulator_create()."
regulator,"For example, consider a Source that may produce a burst of up to seven messages every five seconds. But the Destination cannot handle a burst of seven and either drops messages or gives an error. This can be accommodated by a Regulator instance configured as follows:"
regulator,maximum_messages - 7 delivery_thread_period - one second maximum_to_dequeue_per_period - 3
regulator,maximum_messages - 7
regulator,delivery_thread_period - one second
regulator,maximum_to_dequeue_per_period - 3
regulator,"In this scenario, the application will use the Delivery thread rtems_regulator_send() to enqueue the seven messages when they arrive. The Delivery thread will deliver three messages per second. The following illustrates this sequence:"
regulator,Time 0: Source sends seven messages Time 1: Delivery of messages 1 to 3 Time 3: Delivery of messages 4 to 6 Time 3: Delivery of message 7 Time 4: No messages to deliver
regulator,Time 0: Source sends seven messages
regulator,Time 1: Delivery of messages 1 to 3
regulator,Time 3: Delivery of messages 4 to 6
regulator,Time 3: Delivery of message 7
regulator,Time 4: No messages to deliver
regulator,This configuration of the regulator ensures that the Destination does not overflow.
regulator,"© Copyright 1988, 2024 RTEMS Project and contributors."
regulator,"This section details the directives of the Regulator Manager. A subsection is dedicated to each of this manager’s directives and lists the calling sequence, parameters, description, return values, and notes of the directive."
regulator,Creates a regulator.
regulator,CALLING SEQUENCE:
regulator,PARAMETERS:
regulator,This parameter is the attributes associated with the regulator being created.
regulator,"This parameter is the pointer to a regulator instance.  When the directive call is successful, a pointer to the created regulator will be stored in this object."
regulator,DESCRIPTION:
regulator,This function creates an instance of a regulator. It uses the provided attributes to create the instance return in regulator. This instance will allocate the buffers associated with the regulator instance as well as the Delivery Thread.
regulator,The attributes parameter points to an instance of rtems_regulator_attributes which is filled in to reflect the desired configuration of the regulator instance.  It defines multiple characteristics of the the Delivery thread dedicated to this regulator instance including the priority and stack size.  It also defines the period of the Delivery thread and the maximum number of messages that may be delivered per period via invocation of the delivery function.
regulator,"For each regulator instance, the following resources are allocated:"
regulator,A memory area for the regulator control block using malloc(). A RTEMS Classic API Message Queue is constructed with message buffer memory allocated using malloc().  Each message consists of a pointer to the contents and a length field. A RTEMS Classic API Partition. A RTEMS Classic API Rate Monotonic Period.
regulator,A memory area for the regulator control block using malloc().
regulator,A RTEMS Classic API Message Queue is constructed with message buffer memory allocated using malloc().  Each message consists of a pointer to the contents and a length field.
regulator,A RTEMS Classic API Partition.
regulator,A RTEMS Classic API Rate Monotonic Period.
regulator,RETURN VALUES:
regulator,The requested operation was successful.
regulator,The attributes parameter was NULL.
regulator,The regulator parameter was NULL.
regulator,The deliverer field in the structure pointed to by the attributes parameter was NULL.
regulator,The maximum_messages field in the structure pointed to by the attributes parameter was 0.
regulator,The maximum_to_dequeue_per_period field in the structure pointed to by the attributes parameter was 0.
regulator,The allocation of memory for the regulator instance failed.
regulator,The allocation of memory for the buffers failed.
regulator,The allocation of memory for the internal message queue failed.
regulator,NOTES:
regulator,"rtems_regulator_create() uses rtems_partition_create(), rtems_message_queue_construct(), rtems_task_create(), and rtems_task_start(). If any of those directives return a status indicating failure, it will be returned to the caller."
regulator,CONSTRAINTS:
regulator,The following constraints apply to this directive:
regulator,"The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted. The number of tasks available to the application is configured through the CONFIGURE_MAXIMUM_TASKS application configuration option. Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace."
regulator,The directive may be called from within device driver initialization context.
regulator,The directive may be called from within task context.
regulator,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
regulator,The number of tasks available to the application is configured through the CONFIGURE_MAXIMUM_TASKS application configuration option.
regulator,"Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace."
regulator,Deletes the regulator.
regulator,CALLING SEQUENCE:
regulator,PARAMETERS:
regulator,This parameter points to the regulator instance.
regulator,This parameter specifies the maximum length of time to wait.
regulator,DESCRIPTION:
regulator,This directive is used to delete the specified regulator instance. It will deallocate the resources that were allocated by the rtems_regulator_create() directive.
regulator,This directive ensures that no buffers are outstanding either because the Source is holding one of more buffers or because they are being held by the regulator instance pending delivery.
regulator,"If the Delivery Thread has been created and is running, this directive will request the thread to voluntarily exit. This call will wait up to ticks for the thread to exit."
regulator,RETURN VALUES:
regulator,The requested operation was successful.
regulator,The regulator parameter was NULL.
regulator,The regulator instance was not initialized.
regulator,The regulator instance has buffers outstanding.
regulator,The regulator instance was not able to be deleted within the specific number of ticks.
regulator,NOTES:
regulator,It is the responsibility of the user to ensure that any resources such as sockets or open file descriptors used by the Source or delivery function are also deleted if necessary. It is likely safer to delete those delivery resources after deleting the regulator instance rather than before.
regulator,It is the responsibility of the user to ensure that all buffers associated with this regulator instance have been released and that none are in the process of being delivered.
regulator,CONSTRAINTS:
regulator,The following constraints apply to this directive:
regulator,"The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted. The calling task does not have to be the task that created the object.  Any local task that knows the object identifier can delete the object. Where the object class corresponding to the directive is configured to use unlimited objects, the directive may free memory to the RTEMS Workspace."
regulator,The directive may be called from within task context.
regulator,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
regulator,The calling task does not have to be the task that created the object.  Any local task that knows the object identifier can delete the object.
regulator,"Where the object class corresponding to the directive is configured to use unlimited objects, the directive may free memory to the RTEMS Workspace."
regulator,Obtain buffer from regulator.
regulator,CALLING SEQUENCE:
regulator,PARAMETERS:
regulator,This parameter is the regulator instance to operate upon.
regulator,This parameter will point to the buffer allocated.
regulator,DESCRIPTION:
regulator,This function is used to obtain a buffer from the regulator’s pool. The buffer returned is assumed to be filled in with contents and used in a subsequent call to rtems_regulator_send().
regulator,"When the buffer is delivered, it is expected to be released. If the buffer is not successfully accepted by this method, then it should be returned using rtems_regulator_release_buffer() or used to send another message."
regulator,The buffer returned is of the maximum_message_size specified in the attributes passed in to rtems_regulator_create().
regulator,RETURN VALUES:
regulator,The requested operation was successful.
regulator,The regulator parameter was NULL.
regulator,The regulator instance was not initialized.
regulator,NOTES:
regulator,"rtems_regulator_obtain_buffer() uses rtems_partition_get_buffer() and if it returns a status indicating failure, it will be returned to the caller."
regulator,CONSTRAINTS:
regulator,The following constraints apply to this directive:
regulator,The directive may be called from within device driver initialization context. The directive may be called from within task context.
regulator,The directive may be called from within device driver initialization context.
regulator,The directive may be called from within task context.
regulator,Release buffer to regulator.
regulator,CALLING SEQUENCE:
regulator,PARAMETERS:
regulator,This parameter is the regulator instance to operate upon.
regulator,This parameter will point to the buffer to be released.
regulator,DESCRIPTION:
regulator,This function is used to release a buffer to the regulator’s pool. It is assumed that the buffer returned will not be used by the application anymore.
regulator,"The buffer must have previously been allocated by rtems_regulator_obtain_buffer() and NOT yet passed to rtems_regulator_send(), or it has been sent and delivery has been completed by the delivery function."
regulator,"If a subsequent rtems_regulator_send() using this buffer is successful, the buffer will eventually be processed by the delivery thread and released."
regulator,RETURN VALUES:
regulator,The requested operation was successful.
regulator,The regulator parameter was NULL.
regulator,The regulator instance was not initialized.
regulator,NOTES:
regulator,"rtems_regulator_release_buffer() uses rtems_partition_return_buffer() and if it returns a status indicating failure, it will be returned to the caller."
regulator,CONSTRAINTS:
regulator,The following constraints apply to this directive:
regulator,The directive may be called from within device driver initialization context. The directive may be called from within task context.
regulator,The directive may be called from within device driver initialization context.
regulator,The directive may be called from within task context.
regulator,Send buffer to regulator.
regulator,CALLING SEQUENCE:
regulator,PARAMETERS:
regulator,This parameter is the regulator instance to operate upon.
regulator,This parameter points to the buffer to send.
regulator,This parameter specifies the number of bytes in the message.
regulator,DESCRIPTION:
regulator,This method is used by the producer to send a message to the regulator for later delivery by the delivery thread. The message is contained in the memory pointed to by message and is length bytes in length.
regulator,It is required that the message buffer was obtained via rtems_regulator_obtain_buffer().
regulator,It is assumed that the message buffer has been filled in with application content to deliver.
regulator,"If the rtems_regulator_send() is successful, the message buffer is enqueued inside the regulator instance for subsequent delivery. After the message is delivered, it may be released by either delivery function or other application code depending on the implementation."
regulator,"The status RTEMS_TOO_MANY is returned if the regulator’s internal queue is full. This indicates that the configured maximum number of messages was insufficient. It is the responsibility of the caller to decide whether to hold messages, drop them, or print a message that the maximum number of messages should be increased"
regulator,RETURN VALUES:
regulator,The requested operation was successful.
regulator,The regulator parameter was NULL.
regulator,The regulator instance was not initialized.
regulator,NOTES:
regulator,"rtems_regulator_send() uses rtems_message_queue_send() and if it returns a status indicating failure, it will be returned to the caller."
regulator,CONSTRAINTS:
regulator,The following constraints apply to this directive:
regulator,The directive may be called from within device driver initialization context. The directive may be called from within task context.
regulator,The directive may be called from within device driver initialization context.
regulator,The directive may be called from within task context.
regulator,Obtain statistics from regulator.
regulator,CALLING SEQUENCE:
regulator,PARAMETERS:
regulator,This parameter is the regulator instance to operate upon.
regulator,This parameter points to the statistics structure to be filled in.
regulator,DESCRIPTION:
regulator,This method is used by the application to obtain the current statistics for this regulator. The statistics information provided includes:
regulator,"the  number of buffers obtained via rtems_regulator_obtain_buffer() the number of buffers released via rtems_regulator_release_buffer() the number of buffers delivered by the Delivery Thread via the deliverer function specified in the rtems_regulator_attributes structure provided to InterfaceRtemsRegulatorCreate` via the attibutes parameter. the period_statistics for the Delivery Thread. For more details on period statistics, see rtems_rate_monotonic_period_statistics."
regulator,the  number of buffers obtained via rtems_regulator_obtain_buffer()
regulator,the number of buffers released via rtems_regulator_release_buffer()
regulator,the number of buffers delivered by the Delivery Thread via the deliverer function specified in the rtems_regulator_attributes structure provided to InterfaceRtemsRegulatorCreate` via the attibutes parameter.
regulator,"the period_statistics for the Delivery Thread. For more details on period statistics, see rtems_rate_monotonic_period_statistics."
regulator,RETURN VALUES:
regulator,The requested operation was successful.
regulator,The regulator or statistics parameter was NULL.
regulator,The regulator instance was not initialized.
regulator,NOTES:
regulator,The number of buffers outstanding is released minus obtained. The regulator instance cannot be deleted using rtems_regulator_delete() until all buffers are released.
regulator,The obtained and released values are cumulative over the life of the Regulator instance and are likely to larger than the maximum_messages value in the attributes structure (rtems_regulator_attributes provided to rtems_regulator_create().
regulator,CONSTRAINTS:
regulator,The following constraints apply to this directive:
regulator,The directive may be called from within device driver initialization context. The directive may be called from within task context.
regulator,The directive may be called from within device driver initialization context.
regulator,The directive may be called from within task context.
regulator,"© Copyright 1988, 2024 RTEMS Project and contributors."
regulator,The Regulator Manager provides a set of directives to manage a data flow from a source to a destination. The focus is on regulating the bursty input so that it is delivered to the destination at a regular rate. The directives provided by the Regulator Manager are:
regulator,rtems_regulator_create() - Creates a regulator. rtems_regulator_delete() - Deletes the regulator. rtems_regulator_obtain_buffer() - Obtain buffer from a regulator. rtems_regulator_release_buffer() - Release buffer to a regulator. rtems_regulator_send() - Send buffer to a regulator. rtems_regulator_get_statistics() - Obtain statistics for a regulator.
regulator,rtems_regulator_create() - Creates a regulator.
regulator,rtems_regulator_delete() - Deletes the regulator.
regulator,rtems_regulator_obtain_buffer() - Obtain buffer from a regulator.
regulator,rtems_regulator_release_buffer() - Release buffer to a regulator.
regulator,rtems_regulator_send() - Send buffer to a regulator.
regulator,rtems_regulator_get_statistics() - Obtain statistics for a regulator.
regulator,"© Copyright 1988, 2024 RTEMS Project and contributors."
regulator,"The application interacting with the Source will obtain buffers from the regulator instance, fill them with information, and send them to the regulator instance. This allows the regulator to buffer bursty input."
regulator,A regulator instance is used as follows from the Source side:
regulator,The delivery of message buffers to the Destination and subsequent release is performed in the context of the delivery thread by either the delivery function or delivery thread. Details are below.
regulator,"The sequence diagram below shows the interaction between a message Source, a Regulator instance, and RTEMS, given the usage described in the above paragraphs."
regulator,"As illustrated in the preceding sequence diagram, the Source usually corresponds to application software reading a system input. The Source obtains a buffer from the Regulator instance and fills it with incoming data.  The application explicitly obtaining a buffer and filling it in allows for zero copy operations on the Source side."
regulator,"After the Source has sent the message to the Regulator instance, the Source is free to process another input and the Regulator instance will ensure that the buffer is delivered to the Delivery function and Destination."
regulator,"The Delivery function is provided by the application for a specific Regulator instance. Depending on the Destination, it may use a function which copies the buffer contents (e.g., write()) or which operates directly on the buffer contents (e.g. DMA from buffer). In the case of a Destination which copies the buffer contents, the buffer can be released via  rtems_regulator_release_buffer()  as soon as the function or copying completes. In the case where the delivery uses the buffer and returns, the call to rtems_regulator_release_buffer() will occur when the use of the buffer is complete (e.g. completion of DMA transfer).  This explicit and deliberate exposure of buffering provides the application with the ability to avoid copying the contents."
regulator,"© Copyright 1988, 2024 RTEMS Project and contributors."
scheduling-concepts,"RTEMS provides a plugin framework that allows it to support multiple scheduling algorithms. RTEMS includes multiple scheduling algorithms, and the user can select which of these they wish to use in their application at link-time.  In addition, the user can implement their own scheduling algorithm and configure RTEMS to use it."
scheduling-concepts,"Supporting multiple scheduling algorithms gives the end user the option to select the algorithm which is most appropriate to their use case. Most real-time operating systems schedule tasks using a priority based algorithm, possibly with preemption control.  The classic RTEMS scheduling algorithm which was the only algorithm available in RTEMS 4.10 and earlier, is a fixed-priority scheduling algorithm.  This scheduling algorithm is suitable for uniprocessor (e.g., non-SMP) systems and is known as the Deterministic Priority Scheduler.  Unless the user configures another scheduling algorithm, RTEMS will use this on uniprocessor systems."
scheduling-concepts,"When using priority based scheduling, RTEMS allocates the processor using a priority-based, preemptive algorithm augmented to provide round-robin characteristics within individual priority groups.  The goal of this algorithm is to guarantee that the task which is executing on the processor at any point in time is the one with the highest priority among all tasks in the ready state."
scheduling-concepts,"When a task is added to the ready chain, it is placed behind all other tasks of the same priority.  This rule provides a round-robin within a priority group scheduling characteristic.  This means that in a group of equal priority tasks, tasks will execute in the order they become ready or FIFO order.  Even though there are ways to manipulate and adjust task priorities, the most important rule to remember is:"
scheduling-concepts,Note
scheduling-concepts,Priority based scheduling algorithms will always select the highest priority task that is ready to run when allocating the processor to a task.
scheduling-concepts,"Priority scheduling is the most commonly used scheduling algorithm.  It should be used by applications in which multiple tasks contend for CPU time or other resources, and there is a need to ensure certain tasks are given priority over other tasks."
scheduling-concepts,There are a few common methods of accomplishing the mechanics of this algorithm.  These ways involve a list or chain of tasks in the ready state.
scheduling-concepts,"The least efficient method is to randomly place tasks in the ready chain forcing the scheduler to scan the entire chain to determine which task receives the processor. A more efficient method is to schedule the task by placing it in the proper place on the ready chain based on the designated scheduling criteria at the time it enters the ready state.  Thus, when the processor is free, the first task on the ready chain is allocated the processor. Another mechanism is to maintain a list of FIFOs per priority.  When a task is readied, it is placed on the rear of the FIFO for its priority.  This method is often used with a bitmap to assist in locating which FIFOs have ready tasks on them.  This data structure has \(O(1)\) insert, extract and find highest ready run-time complexities. A red-black tree may be used for the ready queue with the priority as the key.  This data structure has \(O(log(n))\) insert, extract and find highest ready run-time complexities while \(n\) is the count of tasks in the ready queue."
scheduling-concepts,The least efficient method is to randomly place tasks in the ready chain forcing the scheduler to scan the entire chain to determine which task receives the processor.
scheduling-concepts,"A more efficient method is to schedule the task by placing it in the proper place on the ready chain based on the designated scheduling criteria at the time it enters the ready state.  Thus, when the processor is free, the first task on the ready chain is allocated the processor."
scheduling-concepts,"Another mechanism is to maintain a list of FIFOs per priority.  When a task is readied, it is placed on the rear of the FIFO for its priority.  This method is often used with a bitmap to assist in locating which FIFOs have ready tasks on them.  This data structure has \(O(1)\) insert, extract and find highest ready run-time complexities."
scheduling-concepts,"A red-black tree may be used for the ready queue with the priority as the key.  This data structure has \(O(log(n))\) insert, extract and find highest ready run-time complexities while \(n\) is the count of tasks in the ready queue."
scheduling-concepts,RTEMS currently includes multiple priority based scheduling algorithms as well as other algorithms that incorporate deadline.  Each algorithm is discussed in the following sections.
scheduling-concepts,RTEMS provides four mechanisms which allow the user to alter the task scheduling decisions:
scheduling-concepts,user-selectable task priority level task preemption control task timeslicing control manual round-robin selection
scheduling-concepts,user-selectable task priority level
scheduling-concepts,task preemption control
scheduling-concepts,task timeslicing control
scheduling-concepts,manual round-robin selection
scheduling-concepts,"Each of these methods provides a powerful capability to customize sets of tasks to satisfy the unique and particular requirements encountered in custom real-time applications.  Although each mechanism operates independently, there is a precedence relationship which governs the effects of scheduling modifications.  The evaluation order for scheduling characteristics is always priority, preemption mode, and timeslicing.  When reading the descriptions of timeslicing and manual round-robin it is important to keep in mind that preemption (if enabled) of a task by higher priority tasks will occur as required, overriding the other factors presented in the description."
scheduling-concepts,"The most significant task scheduling modification mechanism is the ability for the user to assign a priority level to each individual task when it is created and to alter a task’s priority at run-time, see Task Priority."
scheduling-concepts,"Another way the user can alter the basic scheduling algorithm is by manipulating the preemption mode flag (RTEMS_PREEMPT_MASK) of individual tasks.  If preemption is disabled for a task (RTEMS_NO_PREEMPT), then the task will not relinquish control of the processor until it terminates, blocks, or re-enables preemption.  Even tasks which become ready to run and possess higher priority levels will not be allowed to execute.  Note that the preemption setting has no effect on the manner in which a task is scheduled. It only applies once a task has control of the processor."
scheduling-concepts,"Timeslicing or round-robin scheduling is an additional method which can be used to alter the basic scheduling algorithm.  Like preemption, timeslicing is specified on a task by task basis using the timeslicing mode flag (RTEMS_TIMESLICE_MASK).  If timeslicing is enabled for a task (RTEMS_TIMESLICE), then RTEMS will limit the amount of time the task can execute before the processor is allocated to another task.  Each tick of the real-time clock reduces the currently running task’s timeslice.  When the execution time equals the timeslice, RTEMS will dispatch another task of the same priority to execute.  If there are no other tasks of the same priority ready to execute, then the current task is allocated an additional timeslice and continues to run.  Remember that a higher priority task will preempt the task (unless preemption is disabled) as soon as it is ready to run, even if the task has not used up its entire timeslice."
scheduling-concepts,"The final mechanism for altering the RTEMS scheduling algorithm is called manual round-robin.  Manual round-robin is invoked by using the rtems_task_wake_after directive with a ticks parameter of RTEMS_YIELD_PROCESSOR.  This allows a task to give up the processor and be immediately returned to the ready chain at the end of its priority group.  If no other tasks of the same priority are ready to run, then the task does not lose control of the processor."
scheduling-concepts,"The dispatcher is the RTEMS component responsible for allocating the processor to a ready task.  In order to allocate the processor to one task, it must be deallocated or retrieved from the task currently using it.  This involves a concept called a context switch.  To perform a context switch, the dispatcher saves the context of the current task and restores the context of the task which has been allocated to the processor.  Saving and restoring a task’s context is the storing/loading of all the essential information about a task to enable it to continue execution without any effects of the interruption.  For example, the contents of a task’s register set must be the same when it is given the processor as they were when it was taken away.  All of the information that must be saved or restored for a context switch is located either in the TCB or on the task’s stacks."
scheduling-concepts,"Tasks that utilize a numeric coprocessor and are created with the RTEMS_FLOATING_POINT attribute require additional operations during a context switch.  These additional operations are necessary to save and restore the floating point context of RTEMS_FLOATING_POINT tasks.  To avoid unnecessary save and restore operations, the state of the numeric coprocessor is only saved when a RTEMS_FLOATING_POINT task is dispatched and that task was not the last task to utilize the coprocessor."
scheduling-concepts,"Tasks in an RTEMS system must always be in one of the five allowable task states.  These states are: executing, ready, blocked, dormant, and non-existent."
scheduling-concepts,"A task occupies the non-existent state before a rtems_task_create has been issued on its behalf.  A task enters the non-existent state from any other state in the system when it is deleted with the rtems_task_delete directive.  While a task occupies this state it does not have a TCB or a task ID assigned to it; therefore, no other tasks in the system may reference this task."
scheduling-concepts,"When a task is created via the rtems_task_create directive, it enters the dormant state.  This state is not entered through any other means.  Although the task exists in the system, it cannot actively compete for system resources. It will remain in the dormant state until it is started via the rtems_task_start directive, at which time it enters the ready state.  The task is now permitted to be scheduled for the processor and to compete for other system resources."
scheduling-concepts,A task occupies the blocked state whenever it is unable to be scheduled to run. A running task may block itself or be blocked by other tasks in the system. The running task blocks itself through voluntary operations that cause the task to wait.  The only way a task can block a task other than itself is with the rtems_task_suspend directive.  A task enters the blocked state due to any of the following conditions:
scheduling-concepts,"A task issues a rtems_task_suspend directive which blocks either itself or another task in the system. The running task issues a rtems_barrier_wait directive. The running task issues a rtems_message_queue_receive directive with the wait option, and the message queue is empty. The running task issues a rtems_event_receive directive with the wait option, and the currently pending events do not satisfy the request. The running task issues a rtems_semaphore_obtain directive with the wait option and the requested semaphore is unavailable. The running task issues a rtems_task_wake_after directive which blocks the task for the given count of ticks.  If the count of ticks specified is zero, the task yields the processor and remains in the ready state. The running task issues a rtems_task_wake_when directive which blocks the task until the requested date and time arrives. The running task issues a rtems_rate_monotonic_period directive and must wait for the specified rate monotonic period to conclude. The running task issues a rtems_region_get_segment directive with the wait option and there is not an available segment large enough to satisfy the task’s request."
scheduling-concepts,A task issues a rtems_task_suspend directive which blocks either itself or another task in the system.
scheduling-concepts,The running task issues a rtems_barrier_wait directive.
scheduling-concepts,"The running task issues a rtems_message_queue_receive directive with the wait option, and the message queue is empty."
scheduling-concepts,"The running task issues a rtems_event_receive directive with the wait option, and the currently pending events do not satisfy the request."
scheduling-concepts,The running task issues a rtems_semaphore_obtain directive with the wait option and the requested semaphore is unavailable.
scheduling-concepts,"The running task issues a rtems_task_wake_after directive which blocks the task for the given count of ticks.  If the count of ticks specified is zero, the task yields the processor and remains in the ready state."
scheduling-concepts,The running task issues a rtems_task_wake_when directive which blocks the task until the requested date and time arrives.
scheduling-concepts,The running task issues a rtems_rate_monotonic_period directive and must wait for the specified rate monotonic period to conclude.
scheduling-concepts,The running task issues a rtems_region_get_segment directive with the wait option and there is not an available segment large enough to satisfy the task’s request.
scheduling-concepts,"A blocked task may also be suspended.  Therefore, both the suspension and the blocking condition must be removed before the task becomes ready to run again."
scheduling-concepts,"A task occupies the ready state when it is able to be scheduled to run, but currently does not have control of the processor.  Tasks of the same or higher priority will yield the processor by either becoming blocked, completing their timeslice, or being deleted.  All tasks with the same priority will execute in FIFO order.  A task enters the ready state due to any of the following conditions:"
scheduling-concepts,"A running task issues a rtems_task_resume directive for a task that is suspended and the task is not blocked waiting on any resource. A running task issues a rtems_message_queue_send, rtems_message_queue_broadcast, or a rtems_message_queue_urgent directive which posts a message to the queue on which the blocked task is waiting. A running task issues an rtems_event_send directive which sends an event condition to a task that is blocked waiting on that event condition. A running task issues a rtems_semaphore_release directive which releases the semaphore on which the blocked task is waiting. The requested count of ticks has elapsed for a task which was blocked by a call to the rtems_task_wake_after directive. A timeout period expires for a task which blocked by a call to the rtems_task_wake_when directive. A running task issues a rtems_region_return_segment directive which releases a segment to the region on which the blocked task is waiting and a resulting segment is large enough to satisfy the task’s request. A rate monotonic period expires for a task which blocked by a call to the rtems_rate_monotonic_period directive. A timeout interval expires for a task which was blocked waiting on a message, event, semaphore, or segment with a timeout specified. A running task issues a directive which deletes a message queue, a semaphore, or a region on which the blocked task is waiting. A running task issues a rtems_task_restart directive for the blocked task. The running task, with its preemption mode enabled, may be made ready by issuing any of the directives that may unblock a task with a higher priority. This directive may be issued from the running task itself or from an ISR.  A ready task occupies the executing state when it has control of the CPU.  A task enters the executing state due to any of the following conditions: The task is the highest priority ready task in the system. The running task blocks and the task is next in the scheduling queue.  The task may be of equal priority as in round-robin scheduling or the task may possess the highest priority of the remaining ready tasks. The running task may reenable its preemption mode and a task exists in the ready queue that has a higher priority than the running task. The running task lowers its own priority and another task is of higher priority as a result. The running task raises the priority of a task above its own and the running task is in preemption mode."
scheduling-concepts,A running task issues a rtems_task_resume directive for a task that is suspended and the task is not blocked waiting on any resource.
scheduling-concepts,"A running task issues a rtems_message_queue_send, rtems_message_queue_broadcast, or a rtems_message_queue_urgent directive which posts a message to the queue on which the blocked task is waiting."
scheduling-concepts,A running task issues an rtems_event_send directive which sends an event condition to a task that is blocked waiting on that event condition.
scheduling-concepts,A running task issues a rtems_semaphore_release directive which releases the semaphore on which the blocked task is waiting.
scheduling-concepts,The requested count of ticks has elapsed for a task which was blocked by a call to the rtems_task_wake_after directive.
scheduling-concepts,A timeout period expires for a task which blocked by a call to the rtems_task_wake_when directive.
scheduling-concepts,A running task issues a rtems_region_return_segment directive which releases a segment to the region on which the blocked task is waiting and a resulting segment is large enough to satisfy the task’s request.
scheduling-concepts,A rate monotonic period expires for a task which blocked by a call to the rtems_rate_monotonic_period directive.
scheduling-concepts,"A timeout interval expires for a task which was blocked waiting on a message, event, semaphore, or segment with a timeout specified."
scheduling-concepts,"A running task issues a directive which deletes a message queue, a semaphore, or a region on which the blocked task is waiting."
scheduling-concepts,A running task issues a rtems_task_restart directive for the blocked task.
scheduling-concepts,"The running task, with its preemption mode enabled, may be made ready by issuing any of the directives that may unblock a task with a higher priority. This directive may be issued from the running task itself or from an ISR.  A ready task occupies the executing state when it has control of the CPU.  A task enters the executing state due to any of the following conditions:"
scheduling-concepts,The task is the highest priority ready task in the system.
scheduling-concepts,The running task blocks and the task is next in the scheduling queue.  The task may be of equal priority as in round-robin scheduling or the task may possess the highest priority of the remaining ready tasks.
scheduling-concepts,The running task may reenable its preemption mode and a task exists in the ready queue that has a higher priority than the running task.
scheduling-concepts,The running task lowers its own priority and another task is of higher priority as a result.
scheduling-concepts,The running task raises the priority of a task above its own and the running task is in preemption mode.
scheduling-concepts,"© Copyright 1988, 2024 RTEMS Project and contributors."
scheduling-concepts,"This section details the directives of the Scheduler Manager. A subsection is dedicated to each of this manager’s directives and lists the calling sequence, parameters, description, return values, and notes of the directive."
scheduling-concepts,Identifies a scheduler by the object name.
scheduling-concepts,CALLING SEQUENCE:
scheduling-concepts,PARAMETERS:
scheduling-concepts,This parameter is the scheduler name to look up.
scheduling-concepts,"This parameter is the pointer to an rtems_id object.  When the directive call is successful, the identifier of the scheduler will be stored in this object."
scheduling-concepts,DESCRIPTION:
scheduling-concepts,This directive obtains a scheduler identifier associated with the scheduler name specified in name.
scheduling-concepts,RETURN VALUES:
scheduling-concepts,The requested operation was successful.
scheduling-concepts,There was no scheduler associated with the name.
scheduling-concepts,The id parameter was NULL.
scheduling-concepts,NOTES:
scheduling-concepts,The scheduler name is determined by the scheduler configuration.
scheduling-concepts,The scheduler identifier is used with other scheduler related directives to access the scheduler.
scheduling-concepts,CONSTRAINTS:
scheduling-concepts,The following constraints apply to this directive:
scheduling-concepts,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
scheduling-concepts,The directive may be called from within any runtime context.
scheduling-concepts,The directive will not cause the calling task to be preempted.
scheduling-concepts,Identifies a scheduler by the processor index.
scheduling-concepts,CALLING SEQUENCE:
scheduling-concepts,PARAMETERS:
scheduling-concepts,This parameter is the processor index to identify the scheduler.
scheduling-concepts,"This parameter is the pointer to an rtems_id object.  When the directive call is successful, the identifier of the scheduler will be stored in this object."
scheduling-concepts,RETURN VALUES:
scheduling-concepts,The requested operation was successful.
scheduling-concepts,The id parameter was NULL.
scheduling-concepts,The processor index was invalid.
scheduling-concepts,"The processor index was valid, however, the corresponding processor was not owned by a scheduler."
scheduling-concepts,CONSTRAINTS:
scheduling-concepts,The following constraints apply to this directive:
scheduling-concepts,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
scheduling-concepts,The directive may be called from within any runtime context.
scheduling-concepts,The directive will not cause the calling task to be preempted.
scheduling-concepts,Identifies a scheduler by the processor set.
scheduling-concepts,CALLING SEQUENCE:
scheduling-concepts,PARAMETERS:
scheduling-concepts,This parameter is the size of the processor set referenced by cpuset in bytes.  The size shall be positive.
scheduling-concepts,This parameter is the pointer to a cpu_set_t.  The referenced processor set will be used to identify the scheduler.
scheduling-concepts,"This parameter is the pointer to an rtems_id object.  When the directive call is successful, the identifier of the scheduler will be stored in this object."
scheduling-concepts,DESCRIPTION:
scheduling-concepts,The scheduler is selected according to the highest numbered online processor in the specified processor set.
scheduling-concepts,RETURN VALUES:
scheduling-concepts,The requested operation was successful.
scheduling-concepts,The id parameter was NULL.
scheduling-concepts,The cpuset parameter was NULL.
scheduling-concepts,The processor set size was invalid.
scheduling-concepts,The processor set contained no online processor.
scheduling-concepts,"The processor set was valid, however, the highest numbered online processor in the processor set was not owned by a scheduler."
scheduling-concepts,CONSTRAINTS:
scheduling-concepts,The following constraints apply to this directive:
scheduling-concepts,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
scheduling-concepts,The directive may be called from within any runtime context.
scheduling-concepts,The directive will not cause the calling task to be preempted.
scheduling-concepts,Gets the maximum task priority of the scheduler.
scheduling-concepts,CALLING SEQUENCE:
scheduling-concepts,PARAMETERS:
scheduling-concepts,This parameter is the scheduler identifier.
scheduling-concepts,This parameter is the pointer to an rtems_task_priority object.  When the directive the maximum priority of the scheduler will be stored in this object.
scheduling-concepts,RETURN VALUES:
scheduling-concepts,The requested operation was successful.
scheduling-concepts,There was no scheduler associated with the identifier specified by scheduler_id.
scheduling-concepts,The priority parameter was NULL.
scheduling-concepts,CONSTRAINTS:
scheduling-concepts,The following constraints apply to this directive:
scheduling-concepts,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
scheduling-concepts,The directive may be called from within any runtime context.
scheduling-concepts,The directive will not cause the calling task to be preempted.
scheduling-concepts,Maps a Classic API task priority to the corresponding POSIX thread priority.
scheduling-concepts,CALLING SEQUENCE:
scheduling-concepts,PARAMETERS:
scheduling-concepts,This parameter is the scheduler identifier.
scheduling-concepts,This parameter is the Classic API task priority to map.
scheduling-concepts,"This parameter is the pointer to an int object.  When the directive call is successful, the POSIX thread priority value corresponding to the specified Classic API task priority value will be stored in this object."
scheduling-concepts,RETURN VALUES:
scheduling-concepts,The requested operation was successful.
scheduling-concepts,The posix_priority parameter was NULL.
scheduling-concepts,There was no scheduler associated with the identifier specified by scheduler_id.
scheduling-concepts,The Classic API task priority was invalid.
scheduling-concepts,CONSTRAINTS:
scheduling-concepts,The following constraints apply to this directive:
scheduling-concepts,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
scheduling-concepts,The directive may be called from within any runtime context.
scheduling-concepts,The directive will not cause the calling task to be preempted.
scheduling-concepts,Maps a POSIX thread priority to the corresponding Classic API task priority.
scheduling-concepts,CALLING SEQUENCE:
scheduling-concepts,PARAMETERS:
scheduling-concepts,This parameter is the scheduler identifier.
scheduling-concepts,This parameter is the POSIX thread priority to map.
scheduling-concepts,"This parameter is the pointer to an rtems_task_priority object.  When the directive call is successful, the Classic API task priority value corresponding to the specified POSIX thread priority value will be stored in this object."
scheduling-concepts,RETURN VALUES:
scheduling-concepts,The requested operation was successful.
scheduling-concepts,The priority parameter was NULL.
scheduling-concepts,There was no scheduler associated with the identifier specified by scheduler_id.
scheduling-concepts,The POSIX thread priority was invalid.
scheduling-concepts,CONSTRAINTS:
scheduling-concepts,The following constraints apply to this directive:
scheduling-concepts,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
scheduling-concepts,The directive may be called from within any runtime context.
scheduling-concepts,The directive will not cause the calling task to be preempted.
scheduling-concepts,Returns the index of the current processor.
scheduling-concepts,CALLING SEQUENCE:
scheduling-concepts,DESCRIPTION:
scheduling-concepts,"Where the system was built with SMP support disabled, this directive evaluates to a compile time constant of zero."
scheduling-concepts,"Where the system was built with SMP support enabled, this directive returns the index of the current processor.  The set of processor indices is the range of integers starting with zero up to rtems_scheduler_get_processor_maximum() minus one."
scheduling-concepts,RETURN VALUES:
scheduling-concepts,Returns the index of the current processor.
scheduling-concepts,NOTES:
scheduling-concepts,Outside of sections with disabled thread dispatching the current processor index may change after every instruction since the thread may migrate from one processor to another.  Sections with disabled interrupts are sections with thread dispatching disabled.
scheduling-concepts,CONSTRAINTS:
scheduling-concepts,The following constraints apply to this directive:
scheduling-concepts,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
scheduling-concepts,The directive may be called from within any runtime context.
scheduling-concepts,The directive will not cause the calling task to be preempted.
scheduling-concepts,Returns the processor maximum supported by the system.
scheduling-concepts,CALLING SEQUENCE:
scheduling-concepts,DESCRIPTION:
scheduling-concepts,"Where the system was built with SMP support disabled, this directive evaluates to a compile time constant of one."
scheduling-concepts,"Where the system was built with SMP support enabled, this directive returns the minimum of the processors (physically or virtually) available at the target and the configured processor maximum (see CONFIGURE_MAXIMUM_PROCESSORS).  Not all processors in the range from processor index zero to the last processor index (which is the processor maximum minus one) may be configured to be used by a scheduler or may be online (online processors have a scheduler assigned)."
scheduling-concepts,RETURN VALUES:
scheduling-concepts,Returns the processor maximum supported by the system.
scheduling-concepts,CONSTRAINTS:
scheduling-concepts,The following constraints apply to this directive:
scheduling-concepts,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
scheduling-concepts,The directive may be called from within any runtime context.
scheduling-concepts,The directive will not cause the calling task to be preempted.
scheduling-concepts,Gets the set of processors owned by the scheduler.
scheduling-concepts,CALLING SEQUENCE:
scheduling-concepts,PARAMETERS:
scheduling-concepts,This parameter is the scheduler identifier.
scheduling-concepts,This parameter is the size of the processor set referenced by cpuset in bytes.
scheduling-concepts,"This parameter is the pointer to a cpu_set_t object.  When the directive call is successful, the processor set of the scheduler will be stored in this object.  A set bit in the processor set means that the corresponding processor is owned by the scheduler, otherwise the bit is cleared."
scheduling-concepts,RETURN VALUES:
scheduling-concepts,The requested operation was successful.
scheduling-concepts,The cpuset parameter was NULL.
scheduling-concepts,There was no scheduler associated with the identifier specified by scheduler_id.
scheduling-concepts,The provided processor set was too small for the set of processors owned by the scheduler.
scheduling-concepts,CONSTRAINTS:
scheduling-concepts,The following constraints apply to this directive:
scheduling-concepts,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
scheduling-concepts,The directive may be called from within any runtime context.
scheduling-concepts,The directive will not cause the calling task to be preempted.
scheduling-concepts,Adds the processor to the set of processors owned by the scheduler.
scheduling-concepts,CALLING SEQUENCE:
scheduling-concepts,PARAMETERS:
scheduling-concepts,This parameter is the scheduler identifier.
scheduling-concepts,This parameter is the index of the processor to add.
scheduling-concepts,DESCRIPTION:
scheduling-concepts,This directive adds the processor specified by the cpu_index to the scheduler specified by scheduler_id.
scheduling-concepts,RETURN VALUES:
scheduling-concepts,The requested operation was successful.
scheduling-concepts,There was no scheduler associated with the identifier specified by scheduler_id.
scheduling-concepts,The processor was not configured to be used by the application.
scheduling-concepts,"The processor was configured to be used by the application, however, it was not online."
scheduling-concepts,The processor was already assigned to a scheduler.
scheduling-concepts,CONSTRAINTS:
scheduling-concepts,The following constraints apply to this directive:
scheduling-concepts,The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
scheduling-concepts,The directive may be called from within device driver initialization context.
scheduling-concepts,The directive may be called from within task context.
scheduling-concepts,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
scheduling-concepts,Removes the processor from the set of processors owned by the scheduler.
scheduling-concepts,CALLING SEQUENCE:
scheduling-concepts,PARAMETERS:
scheduling-concepts,This parameter is the scheduler identifier.
scheduling-concepts,This parameter is the index of the processor to remove.
scheduling-concepts,DESCRIPTION:
scheduling-concepts,This directive removes the processor specified by the cpu_index from the scheduler specified by scheduler_id.
scheduling-concepts,RETURN VALUES:
scheduling-concepts,The requested operation was successful.
scheduling-concepts,There was no scheduler associated with the identifier specified by scheduler_id.
scheduling-concepts,The processor was not owned by the scheduler.
scheduling-concepts,The processor was required by at least one non-idle task that used the scheduler as its home scheduler.
scheduling-concepts,The processor was the last processor owned by the scheduler and there was at least one task that used the scheduler as a helping scheduler.
scheduling-concepts,NOTES:
scheduling-concepts,Removing a processor from a scheduler is a complex operation that involves all tasks of the system.
scheduling-concepts,CONSTRAINTS:
scheduling-concepts,The following constraints apply to this directive:
scheduling-concepts,The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
scheduling-concepts,The directive may be called from within device driver initialization context.
scheduling-concepts,The directive may be called from within task context.
scheduling-concepts,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
scheduling-concepts,"© Copyright 1988, 2024 RTEMS Project and contributors."
scheduling-concepts,The scheduling concepts relate to the allocation of processing time for tasks.
scheduling-concepts,"The concept of scheduling in real-time systems dictates the ability to provide an immediate response to specific external events, particularly the necessity of scheduling tasks to run within a specified time limit after the occurrence of an event. For example, software embedded in life-support systems used to monitor hospital patients must take instant action if a change in the patient’s status is detected."
scheduling-concepts,The component of RTEMS responsible for providing this capability is appropriately called the scheduler. The scheduler’s sole purpose is to allocate the all important resource of processor time to the various tasks competing for attention. The directives provided by the Scheduler Manager are:
scheduling-concepts,rtems_scheduler_ident() - Identifies a scheduler by the object name. rtems_scheduler_ident_by_processor() - Identifies a scheduler by the processor index. rtems_scheduler_ident_by_processor_set() - Identifies a scheduler by the processor set. rtems_scheduler_get_maximum_priority() - Gets the maximum task priority of the scheduler. rtems_scheduler_map_priority_to_posix() - Maps a Classic API task priority to the corresponding POSIX thread priority. rtems_scheduler_map_priority_from_posix() - Maps a POSIX thread priority to the corresponding Classic API task priority. rtems_scheduler_get_processor() - Returns the index of the current processor. rtems_scheduler_get_processor_maximum() - Returns the processor maximum supported by the system. rtems_scheduler_get_processor_set() - Gets the set of processors owned by the scheduler. rtems_scheduler_add_processor() - Adds the processor to the set of processors owned by the scheduler. rtems_scheduler_remove_processor() - Removes the processor from the set of processors owned by the scheduler.
scheduling-concepts,rtems_scheduler_ident() - Identifies a scheduler by the object name.
scheduling-concepts,rtems_scheduler_ident_by_processor() - Identifies a scheduler by the processor index.
scheduling-concepts,rtems_scheduler_ident_by_processor_set() - Identifies a scheduler by the processor set.
scheduling-concepts,rtems_scheduler_get_maximum_priority() - Gets the maximum task priority of the scheduler.
scheduling-concepts,rtems_scheduler_map_priority_to_posix() - Maps a Classic API task priority to the corresponding POSIX thread priority.
scheduling-concepts,rtems_scheduler_map_priority_from_posix() - Maps a POSIX thread priority to the corresponding Classic API task priority.
scheduling-concepts,rtems_scheduler_get_processor() - Returns the index of the current processor.
scheduling-concepts,rtems_scheduler_get_processor_maximum() - Returns the processor maximum supported by the system.
scheduling-concepts,rtems_scheduler_get_processor_set() - Gets the set of processors owned by the scheduler.
scheduling-concepts,rtems_scheduler_add_processor() - Adds the processor to the set of processors owned by the scheduler.
scheduling-concepts,rtems_scheduler_remove_processor() - Removes the processor from the set of processors owned by the scheduler.
scheduling-concepts,"© Copyright 1988, 2024 RTEMS Project and contributors."
semaphore,"A semaphore can be viewed as a protected variable whose value can be modified only with the rtems_semaphore_create, rtems_semaphore_obtain, and rtems_semaphore_release directives.  RTEMS supports both binary and counting semaphores. A binary semaphore is restricted to values of zero or one, while a counting semaphore can assume any non-negative integer value."
semaphore,"A binary semaphore (not a simple binary semaphore) can be used to control access to a single resource.  In particular, it can be used to enforce mutual exclusion for a critical section in user code (mutex).  In this instance, the semaphore would be created with an initial count of one to indicate that no task is executing the critical section of code.  Upon entry to the critical section, a task must issue the rtems_semaphore_obtain directive to prevent other tasks from entering the critical section.  Upon exit from the critical section, the task that obtained the binary semaphore must issue the rtems_semaphore_release directive to allow another task to execute the critical section.  A binary semaphore must be released by the task that obtained it."
semaphore,"A counting semaphore can be used to control access to a pool of two or more resources.  For example, access to three printers could be administered by a semaphore created with an initial count of three.  When a task requires access to one of the printers, it issues the rtems_semaphore_obtain directive to obtain access to a printer.  If a printer is not currently available, the task can wait for a printer to become available or return immediately.  When the task has completed printing, it should issue the rtems_semaphore_release directive to allow other tasks access to the printer."
semaphore,"Task synchronization may be achieved by creating a semaphore with an initial count of zero.  One task waits for the arrival of another task by issuing a rtems_semaphore_obtain directive when it reaches a synchronization point. The other task performs a corresponding rtems_semaphore_release operation when it reaches its synchronization point, thus unblocking the pending task."
semaphore,"Deadlock occurs when a task owning a binary semaphore attempts to acquire that same semaphore and blocks as result.  Since the semaphore is allocated to a task, it cannot be deleted.  Therefore, the task that currently holds the semaphore and is also blocked waiting for that semaphore will never execute again."
semaphore,RTEMS addresses this problem by allowing the task holding the binary semaphore to obtain the same binary semaphore multiple times in a nested manner.  Each rtems_semaphore_obtain must be accompanied with a rtems_semaphore_release.  The semaphore will only be made available for acquisition by other tasks when the outermost rtems_semaphore_obtain is matched with a rtems_semaphore_release.
semaphore,Simple binary semaphores do not allow nested access and so can be used for task synchronization.
semaphore,"RTEMS supports priority inheritance for local, binary semaphores that use the priority task wait queue blocking discipline. In SMP configurations, the O(m) Independence-Preserving Protocol (OMIP) is used instead."
semaphore,"RTEMS supports priority ceiling for local, binary semaphores that use the priority task wait queue blocking discipline."
semaphore,"RTEMS supports the Multiprocessor Resource Sharing Protocol (MrsP) for local, binary semaphores that use the priority task wait queue blocking discipline.  In uniprocessor configurations, the Immediate Ceiling Priority Protocol (ICPP) is used instead."
semaphore,"In general, an attribute set is built by a bitwise OR of the desired attribute components.  The following table lists the set of valid semaphore attributes:"
semaphore,"RTEMS_FIFO tasks wait by FIFO (default) RTEMS_PRIORITY tasks wait by priority RTEMS_BINARY_SEMAPHORE restrict values to 0 and 1 RTEMS_COUNTING_SEMAPHORE no restriction on values (default) RTEMS_SIMPLE_BINARY_SEMAPHORE restrict values to 0 and 1, do not allow nested access, allow deletion of
locked semaphore. RTEMS_NO_INHERIT_PRIORITY do not use priority inheritance (default) RTEMS_INHERIT_PRIORITY use priority inheritance RTEMS_NO_PRIORITY_CEILING do not use priority ceiling (default) RTEMS_PRIORITY_CEILING use priority ceiling RTEMS_NO_MULTIPROCESSOR_RESOURCE_SHARING do not use Multiprocessor Resource Sharing Protocol (default) RTEMS_MULTIPROCESSOR_RESOURCE_SHARING use Multiprocessor Resource Sharing Protocol RTEMS_LOCAL local semaphore (default) RTEMS_GLOBAL global semaphore"
semaphore,RTEMS_FIFO
semaphore,tasks wait by FIFO (default)
semaphore,RTEMS_PRIORITY
semaphore,tasks wait by priority
semaphore,RTEMS_BINARY_SEMAPHORE
semaphore,restrict values to 0 and 1
semaphore,RTEMS_COUNTING_SEMAPHORE
semaphore,no restriction on values (default)
semaphore,RTEMS_SIMPLE_BINARY_SEMAPHORE
semaphore,"restrict values to 0 and 1, do not allow nested access, allow deletion of locked semaphore."
semaphore,RTEMS_NO_INHERIT_PRIORITY
semaphore,do not use priority inheritance (default)
semaphore,RTEMS_INHERIT_PRIORITY
semaphore,use priority inheritance
semaphore,RTEMS_NO_PRIORITY_CEILING
semaphore,do not use priority ceiling (default)
semaphore,RTEMS_PRIORITY_CEILING
semaphore,use priority ceiling
semaphore,RTEMS_NO_MULTIPROCESSOR_RESOURCE_SHARING
semaphore,do not use Multiprocessor Resource Sharing Protocol (default)
semaphore,RTEMS_MULTIPROCESSOR_RESOURCE_SHARING
semaphore,use Multiprocessor Resource Sharing Protocol
semaphore,RTEMS_LOCAL
semaphore,local semaphore (default)
semaphore,RTEMS_GLOBAL
semaphore,global semaphore
semaphore,"Attribute values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each attribute appears exactly once in the component list.  An attribute listed as a default is not required to appear in the attribute list, although it is a good programming practice to specify default attributes.  If all defaults are desired, the attribute RTEMS_DEFAULT_ATTRIBUTES should be specified on this call."
semaphore,"This example demonstrates the attribute_set parameter needed to create a local semaphore with the task priority waiting queue discipline.  The attribute_set parameter passed to the rtems_semaphore_create directive could be either RTEMS_PRIORITY or RTEMS_LOCAL | RTEMS_PRIORITY.  The attribute_set parameter can be set to RTEMS_PRIORITY because RTEMS_LOCAL is the default for all created tasks.  If a similar semaphore were to be known globally, then the attribute_set parameter would be RTEMS_GLOBAL | RTEMS_PRIORITY."
semaphore,"Some combinatinos of these attributes are invalid.  For example, priority ordered blocking discipline must be applied to a binary semaphore in order to use either the priority inheritance or priority ceiling functionality.  The following tree figure illustrates the valid combinations."
semaphore,"In general, an option is built by a bitwise OR of the desired option components.  The set of valid options for the rtems_semaphore_obtain directive are listed in the following table:"
semaphore,RTEMS_WAIT task will wait for semaphore (default) RTEMS_NO_WAIT task should not wait
semaphore,RTEMS_WAIT
semaphore,task will wait for semaphore (default)
semaphore,RTEMS_NO_WAIT
semaphore,task should not wait
semaphore,"Option values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each attribute appears exactly once in the component list.  An option listed as a default is not required to appear in the list, although it is a good programming practice to specify default options.  If all defaults are desired, the option RTEMS_DEFAULT_OPTIONS should be specified on this call."
semaphore,This example demonstrates the option parameter needed to poll for a semaphore. The option parameter passed to the rtems_semaphore_obtain directive should be RTEMS_NO_WAIT.
semaphore,"© Copyright 1988, 2024 RTEMS Project and contributors."
semaphore,"This section details the directives of the Semaphore Manager. A subsection is dedicated to each of this manager’s directives and lists the calling sequence, parameters, description, return values, and notes of the directive."
semaphore,Creates a semaphore.
semaphore,CALLING SEQUENCE:
semaphore,PARAMETERS:
semaphore,This parameter is the object name of the semaphore.
semaphore,"This parameter is the initial count of the semaphore.  If the semaphore is a binary semaphore, then a count of 0 will make the calling task the owner of the binary semaphore and a count of 1 will create a binary semaphore without an owner."
semaphore,This parameter is the attribute set of the semaphore.
semaphore,This parameter is the priority ceiling if the semaphore is a binary semaphore with the priority ceiling or MrsP locking protocol as defined by the attribute set.
semaphore,"This parameter is the pointer to an rtems_id object.  When the directive call is successful, the identifier of the created semaphore will be stored in this object."
semaphore,DESCRIPTION:
semaphore,This directive creates a semaphore which resides on the local node.  The semaphore has the user-defined object name specified in name and the initial count specified in count.  The assigned object identifier is returned in id.  This identifier is used to access the semaphore with other semaphore related directives.
semaphore,"The attribute set specified in attribute_set is built through a bitwise or of the attribute constants described below.  Not all combinations of attributes are allowed.  Some attributes are mutually exclusive.  If mutually exclusive attributes are combined, the behaviour is undefined. Attributes not mentioned below are not evaluated by this directive and have no effect.  Default attributes can be selected by using the RTEMS_DEFAULT_ATTRIBUTES constant.  The attribute set defines"
semaphore,"the scope of the semaphore: RTEMS_LOCAL (default) or RTEMS_GLOBAL, the task wait queue discipline used by the semaphore: RTEMS_FIFO (default) or RTEMS_PRIORITY, the class of the semaphore: RTEMS_COUNTING_SEMAPHORE (default), RTEMS_BINARY_SEMAPHORE, or RTEMS_SIMPLE_BINARY_SEMAPHORE, and the locking protocol of a binary semaphore: no locking protocol (default), RTEMS_INHERIT_PRIORITY, RTEMS_PRIORITY_CEILING, or RTEMS_MULTIPROCESSOR_RESOURCE_SHARING."
semaphore,"the scope of the semaphore: RTEMS_LOCAL (default) or RTEMS_GLOBAL,"
semaphore,"the task wait queue discipline used by the semaphore: RTEMS_FIFO (default) or RTEMS_PRIORITY,"
semaphore,"the class of the semaphore: RTEMS_COUNTING_SEMAPHORE (default), RTEMS_BINARY_SEMAPHORE, or RTEMS_SIMPLE_BINARY_SEMAPHORE, and"
semaphore,"the locking protocol of a binary semaphore: no locking protocol (default), RTEMS_INHERIT_PRIORITY, RTEMS_PRIORITY_CEILING, or RTEMS_MULTIPROCESSOR_RESOURCE_SHARING."
semaphore,The semaphore has a local or global scope in a multiprocessing network (this attribute does not refer to SMP systems).  The scope is selected by the mutually exclusive RTEMS_LOCAL and RTEMS_GLOBAL attributes.
semaphore,A local scope is the default and can be emphasized through the use of the RTEMS_LOCAL attribute.  A local semaphore can be only used by the node which created it. A global scope is established if the RTEMS_GLOBAL attribute is set.  Setting the global attribute in a single node system has no effect.
semaphore,A local scope is the default and can be emphasized through the use of the RTEMS_LOCAL attribute.  A local semaphore can be only used by the node which created it.
semaphore,A global scope is established if the RTEMS_GLOBAL attribute is set.  Setting the global attribute in a single node system has no effect.
semaphore,The task wait queue discipline is selected by the mutually exclusive RTEMS_FIFO and RTEMS_PRIORITY attributes.
semaphore,The FIFO discipline is the default and can be emphasized through use of the RTEMS_FIFO attribute. The priority discipline is selected by the RTEMS_PRIORITY attribute.  The locking protocols require the priority discipline.
semaphore,The FIFO discipline is the default and can be emphasized through use of the RTEMS_FIFO attribute.
semaphore,The priority discipline is selected by the RTEMS_PRIORITY attribute.  The locking protocols require the priority discipline.
semaphore,"The semaphore class is selected by the mutually exclusive RTEMS_COUNTING_SEMAPHORE, RTEMS_BINARY_SEMAPHORE, and RTEMS_SIMPLE_BINARY_SEMAPHORE attributes."
semaphore,The counting semaphore class is the default and can be emphasized through use of the RTEMS_COUNTING_SEMAPHORE attribute. The binary semaphore class is selected by the RTEMS_BINARY_SEMAPHORE attribute.  Binary semaphores are mutual exclusion (mutex) synchronization primitives which may have an owner.  The count of a binary semaphore is restricted to 0 and 1 values. The simple binary semaphore class is selected by the RTEMS_SIMPLE_BINARY_SEMAPHORE attribute.  Simple binary semaphores have no owner.  They may be used for task and interrupt synchronization.  The count of a simple binary semaphore is restricted to 0 and 1 values.
semaphore,The counting semaphore class is the default and can be emphasized through use of the RTEMS_COUNTING_SEMAPHORE attribute.
semaphore,The binary semaphore class is selected by the RTEMS_BINARY_SEMAPHORE attribute.  Binary semaphores are mutual exclusion (mutex) synchronization primitives which may have an owner.  The count of a binary semaphore is restricted to 0 and 1 values.
semaphore,The simple binary semaphore class is selected by the RTEMS_SIMPLE_BINARY_SEMAPHORE attribute.  Simple binary semaphores have no owner.  They may be used for task and interrupt synchronization.  The count of a simple binary semaphore is restricted to 0 and 1 values.
semaphore,"Binary semaphores may use a locking protocol.  If a locking protocol is selected, then the scope shall be local and the priority task wait queue discipline shall be selected.  The locking protocol is selected by the mutually exclusive RTEMS_INHERIT_PRIORITY, RTEMS_PRIORITY_CEILING, and RTEMS_MULTIPROCESSOR_RESOURCE_SHARING attributes."
semaphore,"The default is no locking protocol.  This can be emphasized through use of the RTEMS_NO_INHERIT_PRIORITY, RTEMS_NO_MULTIPROCESSOR_RESOURCE_SHARING, and RTEMS_NO_PRIORITY_CEILING attributes. The priority inheritance locking protocol is selected by the RTEMS_INHERIT_PRIORITY attribute. The priority ceiling locking protocol is selected by the RTEMS_PRIORITY_CEILING attribute.  For this locking protocol a priority ceiling shall be specified in priority_ceiling. The MrsP locking protocol is selected by the RTEMS_MULTIPROCESSOR_RESOURCE_SHARING attribute in SMP configurations, otherwise this attribute selects the priority ceiling locking protocol.  For these locking protocols a priority ceiling shall be specified in priority_ceiling.  This priority is used to set the priority ceiling for all schedulers.  This can be changed later with the rtems_semaphore_set_priority() directive using the returned object identifier."
semaphore,"The default is no locking protocol.  This can be emphasized through use of the RTEMS_NO_INHERIT_PRIORITY, RTEMS_NO_MULTIPROCESSOR_RESOURCE_SHARING, and RTEMS_NO_PRIORITY_CEILING attributes."
semaphore,The priority inheritance locking protocol is selected by the RTEMS_INHERIT_PRIORITY attribute.
semaphore,The priority ceiling locking protocol is selected by the RTEMS_PRIORITY_CEILING attribute.  For this locking protocol a priority ceiling shall be specified in priority_ceiling.
semaphore,"The MrsP locking protocol is selected by the RTEMS_MULTIPROCESSOR_RESOURCE_SHARING attribute in SMP configurations, otherwise this attribute selects the priority ceiling locking protocol.  For these locking protocols a priority ceiling shall be specified in priority_ceiling.  This priority is used to set the priority ceiling for all schedulers.  This can be changed later with the rtems_semaphore_set_priority() directive using the returned object identifier."
semaphore,RETURN VALUES:
semaphore,The requested operation was successful.
semaphore,The name parameter was invalid.
semaphore,The id parameter was NULL.
semaphore,The count parameter was invalid.
semaphore,The attribute_set parameter was invalid.
semaphore,There was no inactive object available to create a semaphore.  The number of semaphores available to the application is configured through the CONFIGURE_MAXIMUM_SEMAPHORES application configuration option.
semaphore,"In multiprocessing configurations, there was no inactive global object available to create a global semaphore.  The number of global objects available to the application is configured through the CONFIGURE_MP_MAXIMUM_GLOBAL_OBJECTS application configuration option."
semaphore,The priority_ceiling parameter was invalid.
semaphore,NOTES:
semaphore,"For control and maintenance of the semaphore, RTEMS allocates a SMCB from the local SMCB free pool and initializes it."
semaphore,"The SMCB for a global semaphore is allocated on the local node.  Semaphores should not be made global unless remote tasks must interact with the semaphore. This is to avoid the system overhead incurred by the creation of a global semaphore.  When a global semaphore is created, the semaphore’s name and identifier must be transmitted to every node in the system for insertion in the local copy of the global object table."
semaphore,CONSTRAINTS:
semaphore,The following constraints apply to this directive:
semaphore,"The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted. When the directive operates on a global object, the directive sends a message to remote nodes.  This may preempt the calling task. The number of semaphores available to the application is configured through the CONFIGURE_MAXIMUM_SEMAPHORES application configuration option. Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace. The number of global objects available to the application is configured through the CONFIGURE_MP_MAXIMUM_GLOBAL_OBJECTS application configuration option."
semaphore,The directive may be called from within device driver initialization context.
semaphore,The directive may be called from within task context.
semaphore,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
semaphore,"When the directive operates on a global object, the directive sends a message to remote nodes.  This may preempt the calling task."
semaphore,The number of semaphores available to the application is configured through the CONFIGURE_MAXIMUM_SEMAPHORES application configuration option.
semaphore,"Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace."
semaphore,The number of global objects available to the application is configured through the CONFIGURE_MP_MAXIMUM_GLOBAL_OBJECTS application configuration option.
semaphore,Identifies a semaphore by the object name.
semaphore,CALLING SEQUENCE:
semaphore,PARAMETERS:
semaphore,This parameter is the object name to look up.
semaphore,This parameter is the node or node set to search for a matching object.
semaphore,"This parameter is the pointer to an rtems_id object.  When the directive call is successful, the object identifier of an object with the specified name will be stored in this object."
semaphore,DESCRIPTION:
semaphore,This directive obtains a semaphore identifier associated with the semaphore name specified in name.
semaphore,The node to search is specified in node.  It shall be
semaphore,"a valid node number, the constant RTEMS_SEARCH_ALL_NODES to search in all nodes, the constant RTEMS_SEARCH_LOCAL_NODE to search in the local node only, or the constant RTEMS_SEARCH_OTHER_NODES to search in all nodes except the local node."
semaphore,"a valid node number,"
semaphore,"the constant RTEMS_SEARCH_ALL_NODES to search in all nodes,"
semaphore,"the constant RTEMS_SEARCH_LOCAL_NODE to search in the local node only, or"
semaphore,the constant RTEMS_SEARCH_OTHER_NODES to search in all nodes except the local node.
semaphore,RETURN VALUES:
semaphore,The requested operation was successful.
semaphore,The id parameter was NULL.
semaphore,The name parameter was 0.
semaphore,There was no object with the specified name on the specified nodes.
semaphore,"In multiprocessing configurations, the specified node was invalid."
semaphore,NOTES:
semaphore,"If the semaphore name is not unique, then the semaphore identifier will match the first semaphore with that name in the search order.  However, this semaphore identifier is not guaranteed to correspond to the desired semaphore."
semaphore,"The objects are searched from lowest to the highest index.  If node is RTEMS_SEARCH_ALL_NODES, all nodes are searched with the local node being searched first.  All other nodes are searched from lowest to the highest node number."
semaphore,"If node is a valid node number which does not represent the local node, then only the semaphores exported by the designated node are searched."
semaphore,This directive does not generate activity on remote nodes.  It accesses only the local copy of the global object table.
semaphore,The semaphore identifier is used with other semaphore related directives to access the semaphore.
semaphore,CONSTRAINTS:
semaphore,The following constraints apply to this directive:
semaphore,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
semaphore,The directive may be called from within any runtime context.
semaphore,The directive will not cause the calling task to be preempted.
semaphore,Deletes the semaphore.
semaphore,CALLING SEQUENCE:
semaphore,PARAMETERS:
semaphore,This parameter is the semaphore identifier.
semaphore,DESCRIPTION:
semaphore,This directive deletes the semaphore specified by id.
semaphore,RETURN VALUES:
semaphore,The requested operation was successful.
semaphore,There was no semaphore associated with the identifier specified by id.
semaphore,The semaphore resided on a remote node.
semaphore,The binary semaphore had an owner.
semaphore,NOTES:
semaphore,Binary semaphores with an owner cannot be deleted.
semaphore,"When a semaphore is deleted, all tasks blocked waiting to obtain the semaphore will be readied and returned a status code which indicates that the semaphore was deleted."
semaphore,The SMCB for the deleted semaphore is reclaimed by RTEMS.
semaphore,"When a global semaphore is deleted, the semaphore identifier must be transmitted to every node in the system for deletion from the local copy of the global object table."
semaphore,"The semaphore must reside on the local node, even if the semaphore was created with the RTEMS_GLOBAL attribute."
semaphore,"Proxies, used to represent remote tasks, are reclaimed when the semaphore is deleted."
semaphore,CONSTRAINTS:
semaphore,The following constraints apply to this directive:
semaphore,"The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted. When the directive operates on a global object, the directive sends a message to remote nodes.  This may preempt the calling task. The calling task does not have to be the task that created the object.  Any local task that knows the object identifier can delete the object. Where the object class corresponding to the directive is configured to use unlimited objects, the directive may free memory to the RTEMS Workspace."
semaphore,The directive may be called from within device driver initialization context.
semaphore,The directive may be called from within task context.
semaphore,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
semaphore,"When the directive operates on a global object, the directive sends a message to remote nodes.  This may preempt the calling task."
semaphore,The calling task does not have to be the task that created the object.  Any local task that knows the object identifier can delete the object.
semaphore,"Where the object class corresponding to the directive is configured to use unlimited objects, the directive may free memory to the RTEMS Workspace."
semaphore,Obtains the semaphore.
semaphore,CALLING SEQUENCE:
semaphore,PARAMETERS:
semaphore,This parameter is the semaphore identifier.
semaphore,This parameter is the option set.
semaphore,This parameter is the timeout in clock ticks if the RTEMS_WAIT option is set.  Use RTEMS_NO_TIMEOUT to wait potentially forever.
semaphore,DESCRIPTION:
semaphore,This directive obtains the semaphore specified by id.
semaphore,"The option set specified in option_set is built through a bitwise or of the option constants described below.  Not all combinations of options are allowed.  Some options are mutually exclusive.  If mutually exclusive options are combined, the behaviour is undefined.  Options not mentioned below are not evaluated by this directive and have no effect. Default options can be selected by using the RTEMS_DEFAULT_OPTIONS constant."
semaphore,The calling task can wait or try to obtain the semaphore according to the mutually exclusive RTEMS_WAIT and RTEMS_NO_WAIT options.
semaphore,"Waiting to obtain the semaphore is the default and can be emphasized through the use of the RTEMS_WAIT option.  The timeout parameter defines how long the calling task is willing to wait.  Use RTEMS_NO_TIMEOUT to wait potentially forever, otherwise set a timeout interval in clock ticks. Trying to obtain the semaphore is selected by the RTEMS_NO_WAIT option.  If this option is defined, then the timeout parameter is ignored.  When the semaphore cannot be immediately obtained, then the RTEMS_UNSATISFIED status is returned."
semaphore,"Waiting to obtain the semaphore is the default and can be emphasized through the use of the RTEMS_WAIT option.  The timeout parameter defines how long the calling task is willing to wait.  Use RTEMS_NO_TIMEOUT to wait potentially forever, otherwise set a timeout interval in clock ticks."
semaphore,"Trying to obtain the semaphore is selected by the RTEMS_NO_WAIT option.  If this option is defined, then the timeout parameter is ignored.  When the semaphore cannot be immediately obtained, then the RTEMS_UNSATISFIED status is returned."
semaphore,"With either RTEMS_WAIT or RTEMS_NO_WAIT if the current semaphore count is positive, then it is decremented by one and the semaphore is successfully obtained by returning immediately with the RTEMS_SUCCESSFUL status code."
semaphore,"If the calling task chooses to return immediately and the current semaphore count is zero, then the RTEMS_UNSATISFIED status code is returned indicating that the semaphore is not available."
semaphore,"If the calling task chooses to wait for a semaphore and the current semaphore count is zero, then the calling task is placed on the semaphore’s wait queue and blocked.  If a local, binary semaphore was created with the RTEMS_INHERIT_PRIORITY attribute, then the priority of the task currently holding the binary semaphore will inherit the current priority set of the blocking task.  The priority inheritance is carried out recursively.  This means, that if the task currently holding the binary semaphore is blocked on another local, binary semaphore using the priority inheritance locking protocol, then the owner of this semaphore will inherit the current priority sets of both tasks, and so on.  A task has a current priority for each scheduler."
semaphore,RETURN VALUES:
semaphore,The requested operation was successful.
semaphore,There was no semaphore associated with the identifier specified by id.
semaphore,The semaphore uses a priority ceiling and there was no priority ceiling defined for the home scheduler of the calling task.
semaphore,The semaphore could not be obtained immediately.
semaphore,The semaphore uses a priority ceiling and the calling task had a current priority less than the priority ceiling.
semaphore,"Acquiring of the local, binary semaphore by the calling task would have cased a deadlock."
semaphore,"The calling task attempted to recursively obtain a local, binary semaphore using the MrsP locking protocol."
semaphore,The semaphore was flushed while the calling task was waiting to obtain the semaphore.
semaphore,The timeout happened while the calling task was waiting to obtain the semaphore.
semaphore,The semaphore was deleted while the calling task was waiting to obtain the semaphore.
semaphore,NOTES:
semaphore,"If a local, binary semaphore was created with the RTEMS_PRIORITY_CEILING or RTEMS_MULTIPROCESSOR_RESOURCE_SHARING attribute, a task successfully obtains the semaphore, and the priority of that task is greater than the ceiling priority for this semaphore, then the priority of the task acquiring the semaphore is elevated to that of the ceiling."
semaphore,"Deadlock situations are detected for local, binary semaphores.  If a deadlock is detected, then the directive immediately returns the RTEMS_INCORRECT_STATE status code."
semaphore,"It is not allowed to recursively obtain (nested access) a local, binary semaphore using the MrsP locking protocol and any attempt to do this will just return the RTEMS_INCORRECT_STATE status code.  This error can only happen in SMP configurations."
semaphore,"If the semaphore was created with the RTEMS_PRIORITY attribute, then the calling task is inserted into the wait queue according to its priority. However, if the semaphore was created with the RTEMS_FIFO attribute, then the calling task is placed at the rear of the wait queue."
semaphore,"Attempting to obtain a global semaphore which does not reside on the local node will generate a request to the remote node to access the semaphore.  If the semaphore is not available and RTEMS_NO_WAIT was not specified, then the task must be blocked until the semaphore is released.  A proxy is allocated on the remote node to represent the task until the semaphore is released."
semaphore,CONSTRAINTS:
semaphore,The following constraints apply to this directive:
semaphore,"When a local, counting semaphore or a local, simple binary semaphore is accessed and the RTEMS_NO_WAIT option is set, the directive may be called from within interrupt context. When a local semaphore is accessed and the request can be immediately satisfied, the directive may be called from within device driver initialization context. The directive may be called from within task context. When the request cannot be immediately satisfied and the RTEMS_WAIT option is set, the calling task blocks at some point during the directive call. The timeout functionality of the directive requires a clock tick. When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply.  This will preempt the calling task."
semaphore,"When a local, counting semaphore or a local, simple binary semaphore is accessed and the RTEMS_NO_WAIT option is set, the directive may be called from within interrupt context."
semaphore,"When a local semaphore is accessed and the request can be immediately satisfied, the directive may be called from within device driver initialization context."
semaphore,The directive may be called from within task context.
semaphore,"When the request cannot be immediately satisfied and the RTEMS_WAIT option is set, the calling task blocks at some point during the directive call."
semaphore,The timeout functionality of the directive requires a clock tick.
semaphore,"When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply.  This will preempt the calling task."
semaphore,Releases the semaphore.
semaphore,CALLING SEQUENCE:
semaphore,PARAMETERS:
semaphore,This parameter is the semaphore identifier.
semaphore,DESCRIPTION:
semaphore,"This directive releases the semaphore specified by id.  If the semaphore’s wait queue is not empty, then"
semaphore,"the first task on the wait queue is removed and unblocked, the semaphore’s count is not changed, otherwise the semaphore’s count is incremented by one for counting semaphores and set to one for binary and simple binary semaphores."
semaphore,"the first task on the wait queue is removed and unblocked, the semaphore’s count is not changed, otherwise"
semaphore,the semaphore’s count is incremented by one for counting semaphores and set to one for binary and simple binary semaphores.
semaphore,RETURN VALUES:
semaphore,The requested operation was successful.
semaphore,There was no semaphore associated with the identifier specified by id.
semaphore,The calling task was not the owner of the semaphore.
semaphore,The semaphore’s count already had the maximum value of UINT32_MAX.
semaphore,NOTES:
semaphore,The calling task may be preempted if it causes a higher priority task to be made ready for execution.
semaphore,"The outermost release of a local, binary semaphore using the priority inheritance, priority ceiling, or MrsP locking protocol may result in the calling task having its priority lowered.  This will occur if the highest priority of the calling task was available due to the ownership of the released semaphore.  If a task was on the semaphore’s wait queue, then the priority associated with the semaphore will be transferred to the new owner."
semaphore,Releasing a global semaphore which does not reside on the local node will generate a request telling the remote node to release the semaphore.
semaphore,"If the task to be unblocked resides on a different node from the semaphore, then the semaphore allocation is forwarded to the appropriate node, the waiting task is unblocked, and the proxy used to represent the task is reclaimed."
semaphore,CONSTRAINTS:
semaphore,The following constraints apply to this directive:
semaphore,"When a local, counting semaphore or a local, simple binary semaphore is accessed, the directive may be called from within interrupt context. When a local semaphore is accessed, the directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may unblock a task.  This may cause the calling task to be preempted. When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply.  This will preempt the calling task."
semaphore,"When a local, counting semaphore or a local, simple binary semaphore is accessed, the directive may be called from within interrupt context."
semaphore,"When a local semaphore is accessed, the directive may be called from within device driver initialization context."
semaphore,The directive may be called from within task context.
semaphore,The directive may unblock a task.  This may cause the calling task to be preempted.
semaphore,"When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply.  This will preempt the calling task."
semaphore,Flushes the semaphore.
semaphore,CALLING SEQUENCE:
semaphore,PARAMETERS:
semaphore,This parameter is the semaphore identifier.
semaphore,DESCRIPTION:
semaphore,This directive unblocks all tasks waiting on the semaphore specified by id. The semaphore’s count is not changed by this directive.  Tasks which are unblocked as the result of this directive will return from the rtems_semaphore_obtain() directive with a status code of RTEMS_UNSATISFIED to indicate that the semaphore was not obtained.
semaphore,RETURN VALUES:
semaphore,The requested operation was successful.
semaphore,There was no semaphore associated with the identifier specified by id.
semaphore,The semaphore resided on a remote node.
semaphore,Flushing a semaphore using the MrsP locking protocol is undefined behaviour.
semaphore,NOTES:
semaphore,"If the task to be unblocked resides on a different node from the semaphore, then the waiting task is unblocked, and the proxy used to represent the task is reclaimed."
semaphore,"It is not allowed to flush a local, binary semaphore using the MrsP locking protocol and any attempt to do this will just return the RTEMS_NOT_DEFINED status code.  This error can only happen in SMP configurations."
semaphore,"For barrier synchronization, the Barrier Manager offers a cleaner alternative to using the semaphore flush directive.  Unlike POSIX barriers, they have a manual release option."
semaphore,Using the semaphore flush directive for condition synchronization in concert with another semaphore may be subject to the lost wake-up problem.  The following attempt to implement a condition variable is broken.
semaphore,CONSTRAINTS:
semaphore,The following constraints apply to this directive:
semaphore,"When a local, counting semaphore or a local, simple binary semaphore is accessed, the directive may be called from within interrupt context. When a local semaphore is accessed, the directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may unblock a task.  This may cause the calling task to be preempted. When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply.  This will preempt the calling task."
semaphore,"When a local, counting semaphore or a local, simple binary semaphore is accessed, the directive may be called from within interrupt context."
semaphore,"When a local semaphore is accessed, the directive may be called from within device driver initialization context."
semaphore,The directive may be called from within task context.
semaphore,The directive may unblock a task.  This may cause the calling task to be preempted.
semaphore,"When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply.  This will preempt the calling task."
semaphore,Sets the priority by scheduler for the semaphore.
semaphore,CALLING SEQUENCE:
semaphore,PARAMETERS:
semaphore,This parameter is the semaphore identifier.
semaphore,This parameter is the identifier of the scheduler corresponding to the new priority.
semaphore,This parameter is the new priority corresponding to the specified scheduler.
semaphore,"This parameter is the pointer to an rtems_task_priority object.  When the directive call is successful, the old priority of the semaphore corresponding to the specified scheduler will be stored in this object."
semaphore,DESCRIPTION:
semaphore,This directive sets the priority of the semaphore specified by semaphore_id.  The priority corresponds to the scheduler specified by scheduler_id.
semaphore,The special priority value RTEMS_CURRENT_PRIORITY can be used to get the current priority without changing it.
semaphore,The availability and use of a priority depends on the class and locking protocol of the semaphore:
semaphore,"For local, binary semaphores using the MrsP locking protocol, the ceiling priority for each scheduler can be set by this directive. For local, binary semaphores using the priority ceiling protocol, the ceiling priority can be set by this directive. For other semaphore classes and locking protocols, setting a priority is undefined behaviour."
semaphore,"For local, binary semaphores using the MrsP locking protocol, the ceiling priority for each scheduler can be set by this directive."
semaphore,"For local, binary semaphores using the priority ceiling protocol, the ceiling priority can be set by this directive."
semaphore,"For other semaphore classes and locking protocols, setting a priority is undefined behaviour."
semaphore,RETURN VALUES:
semaphore,The requested operation was successful.
semaphore,The old_priority parameter was NULL.
semaphore,There was no scheduler associated with the identifier specified by scheduler_id.
semaphore,There was no semaphore associated with the identifier specified by semaphore_id.
semaphore,The semaphore resided on a remote node.
semaphore,The new_priority parameter was invalid.
semaphore,Setting a priority for the class or locking protocol of the semaphore is undefined behaviour.
semaphore,NOTES:
semaphore,Please have a look at the following example:
semaphore,CONSTRAINTS:
semaphore,The following constraints apply to this directive:
semaphore,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may change the priority of a task.  This may cause the calling task to be preempted.
semaphore,The directive may be called from within interrupt context.
semaphore,The directive may be called from within device driver initialization context.
semaphore,The directive may be called from within task context.
semaphore,The directive may change the priority of a task.  This may cause the calling task to be preempted.
semaphore,"© Copyright 1988, 2024 RTEMS Project and contributors."
semaphore,The Semaphore Manager utilizes standard Dijkstra counting semaphores to provide synchronization and mutual exclusion capabilities. The directives provided by the Semaphore Manager are:
semaphore,rtems_semaphore_create() - Creates a semaphore. rtems_semaphore_ident() - Identifies a semaphore by the object name. rtems_semaphore_delete() - Deletes the semaphore. rtems_semaphore_obtain() - Obtains the semaphore. rtems_semaphore_release() - Releases the semaphore. rtems_semaphore_flush() - Flushes the semaphore. rtems_semaphore_set_priority() - Sets the priority by scheduler for the semaphore.
semaphore,rtems_semaphore_create() - Creates a semaphore.
semaphore,rtems_semaphore_ident() - Identifies a semaphore by the object name.
semaphore,rtems_semaphore_delete() - Deletes the semaphore.
semaphore,rtems_semaphore_obtain() - Obtains the semaphore.
semaphore,rtems_semaphore_release() - Releases the semaphore.
semaphore,rtems_semaphore_flush() - Flushes the semaphore.
semaphore,rtems_semaphore_set_priority() - Sets the priority by scheduler for the semaphore.
semaphore,"© Copyright 1988, 2024 RTEMS Project and contributors."
semaphore,"The rtems_semaphore_create directive creates a binary or counting semaphore with a user-specified name as well as an initial count.  If a binary semaphore is created with a count of zero (0) to indicate that it has been allocated, then the task creating the semaphore is considered the current holder of the semaphore.  At create time the method for ordering waiting tasks in the semaphore’s task wait queue (by FIFO or task priority) is specified. Additionally, the priority inheritance or priority ceiling algorithm may be selected for local, binary semaphores that use the priority task wait queue blocking discipline.  If the priority ceiling algorithm is selected, then the highest priority of any task which will attempt to obtain this semaphore must be specified.  RTEMS allocates a Semaphore Control Block (SMCB) from the SMCB free list.  This data structure is used by RTEMS to manage the newly created semaphore.  Also, a unique semaphore ID is generated and returned to the calling task."
semaphore,"When a semaphore is created, RTEMS generates a unique semaphore ID and assigns it to the created semaphore until it is deleted.  The semaphore ID may be obtained by either of two methods.  First, as the result of an invocation of the rtems_semaphore_create directive, the semaphore ID is stored in a user provided location.  Second, the semaphore ID may be obtained later using the rtems_semaphore_ident directive.  The semaphore ID is used by other semaphore manager directives to access this semaphore."
semaphore,The rtems_semaphore_obtain directive is used to acquire the specified semaphore.  A simplified version of the rtems_semaphore_obtain directive can be described as follows:
semaphore,If the semaphore’s count is greater than zero then decrement the semaphore’s count else wait for release of semaphore then return SUCCESSFUL.
semaphore,"When the semaphore cannot be immediately acquired, one of the following situations applies:"
semaphore,"By default, the calling task will wait forever to acquire the semaphore. Specifying RTEMS_NO_WAIT forces an immediate return with an error status code. Specifying a timeout limits the interval the task will wait before returning with an error status code."
semaphore,"By default, the calling task will wait forever to acquire the semaphore."
semaphore,Specifying RTEMS_NO_WAIT forces an immediate return with an error status code.
semaphore,Specifying a timeout limits the interval the task will wait before returning with an error status code.
semaphore,"If the task waits to acquire the semaphore, then it is placed in the semaphore’s task wait queue in either FIFO or task priority order.  If the task blocked waiting for a binary semaphore using priority inheritance and the task’s priority is greater than that of the task currently holding the semaphore, then the holding task will inherit the priority of the blocking task.  All tasks waiting on a semaphore are returned an error code when the semaphore is deleted."
semaphore,"When a task successfully obtains a semaphore using priority ceiling and the priority ceiling for this semaphore is greater than that of the holder, then the holder’s priority will be elevated."
semaphore,The rtems_semaphore_release directive is used to release the specified semaphore.  A simplified version of the rtems_semaphore_release directive can be described as follows:
semaphore,If there are no tasks are waiting on this semaphore then increment the semaphore’s count else assign semaphore to a waiting task and return SUCCESSFUL.
semaphore,"If this is the outermost release of a binary semaphore that uses priority inheritance or priority ceiling and the task does not currently hold any other binary semaphores, then the task performing the rtems_semaphore_release will have its priority restored to its normal value."
semaphore,"The rtems_semaphore_delete directive removes a semaphore from the system and frees its control block.  A semaphore can be deleted by any local task that knows the semaphore’s ID.  As a result of this directive, all tasks blocked waiting to acquire the semaphore will be readied and returned a status code which indicates that the semaphore was deleted.  Any subsequent references to the semaphore’s name and ID are invalid."
semaphore,"© Copyright 1988, 2024 RTEMS Project and contributors."
signal,"The signal manager allows a task to optionally define an asynchronous signal routine (ASR).  An ASR is to a task what an ISR is to an application’s set of tasks.  When the processor is interrupted, the execution of an application is also interrupted and an ISR is given control.  Similarly, when a signal is sent to a task, that task’s execution path will be “interrupted” by the ASR. Sending a signal to a task has no effect on the receiving task’s current execution state."
signal,A signal flag is used by a task (or ISR) to inform another task of the occurrence of a significant situation.  Thirty-two signal flags are associated with each task.  A collection of one or more signals is referred to as a signal set.  The data type rtems_signal_set is used to manipulate signal sets.
signal,"A signal set is posted when it is directed (or sent) to a task. A pending signal is a signal that has been sent to a task with a valid ASR, but has not been processed by that task’s ASR."
signal,The format of an ASR is similar to that of an ISR with the following exceptions:
signal,"ISRs are scheduled by the processor hardware.  ASRs are scheduled by RTEMS. ISRs do not execute in the context of a task and may invoke only a subset of directives.  ASRs execute in the context of a task and may execute any directive. When an ISR is invoked, it is passed the vector number as its argument.  When an ASR is invoked, it is passed the signal set as its argument. An ASR has a task mode which can be different from that of the task.  An ISR does not execute as a task and, as a result, does not have a task mode."
signal,ISRs are scheduled by the processor hardware.  ASRs are scheduled by RTEMS.
signal,ISRs do not execute in the context of a task and may invoke only a subset of directives.  ASRs execute in the context of a task and may execute any directive.
signal,"When an ISR is invoked, it is passed the vector number as its argument.  When an ASR is invoked, it is passed the signal set as its argument."
signal,"An ASR has a task mode which can be different from that of the task.  An ISR does not execute as a task and, as a result, does not have a task mode."
signal,"A signal set is built by a bitwise OR of the desired signals.  The set of valid signals is RTEMS_SIGNAL_0 through RTEMS_SIGNAL_31.  If a signal is not explicitly specified in the signal set, then it is not present.  Signal values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each signal appears exactly once in the component list."
signal,"This example demonstrates the signal parameter used when sending the signal set consisting of RTEMS_SIGNAL_6, RTEMS_SIGNAL_15, and RTEMS_SIGNAL_31. The signal parameter provided to the rtems_signal_send directive should be RTEMS_SIGNAL_6 | RTEMS_SIGNAL_15 | RTEMS_SIGNAL_31."
signal,"In general, an ASR’s mode is built by a bitwise OR of the desired mode components.  The set of valid mode components is the same as those allowed with the task_create and task_mode directives.  A complete list of mode options is provided in the following table:"
signal,RTEMS_PREEMPT is masked by RTEMS_PREEMPT_MASK and enables preemption RTEMS_NO_PREEMPT is masked by RTEMS_PREEMPT_MASK and disables preemption RTEMS_NO_TIMESLICE is masked by RTEMS_TIMESLICE_MASK and disables timeslicing RTEMS_TIMESLICE is masked by RTEMS_TIMESLICE_MASK and enables timeslicing RTEMS_ASR is masked by RTEMS_ASR_MASK and enables ASR processing RTEMS_NO_ASR is masked by RTEMS_ASR_MASK and disables ASR processing RTEMS_INTERRUPT_LEVEL(0) is masked by RTEMS_INTERRUPT_MASK and enables all interrupts RTEMS_INTERRUPT_LEVEL(n) is masked by RTEMS_INTERRUPT_MASK and sets interrupts level n
signal,RTEMS_PREEMPT
signal,is masked by RTEMS_PREEMPT_MASK and enables preemption
signal,RTEMS_NO_PREEMPT
signal,is masked by RTEMS_PREEMPT_MASK and disables preemption
signal,RTEMS_NO_TIMESLICE
signal,is masked by RTEMS_TIMESLICE_MASK and disables timeslicing
signal,RTEMS_TIMESLICE
signal,is masked by RTEMS_TIMESLICE_MASK and enables timeslicing
signal,RTEMS_ASR
signal,is masked by RTEMS_ASR_MASK and enables ASR processing
signal,RTEMS_NO_ASR
signal,is masked by RTEMS_ASR_MASK and disables ASR processing
signal,RTEMS_INTERRUPT_LEVEL(0)
signal,is masked by RTEMS_INTERRUPT_MASK and enables all interrupts
signal,RTEMS_INTERRUPT_LEVEL(n)
signal,is masked by RTEMS_INTERRUPT_MASK and sets interrupts level n
signal,"Mode values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each mode appears exactly once in the component list.  A mode component listed as a default is not required to appear in the mode list, although it is a good programming practice to specify default components.  If all defaults are desired, the mode DEFAULT_MODES should be specified on this call."
signal,This example demonstrates the mode parameter used with the rtems_signal_catch to establish an ASR which executes at interrupt level three and is non-preemptible.  The mode should be set to RTEMS_INTERRUPT_LEVEL(3) | RTEMS_NO_PREEMPT to indicate the desired processor mode and interrupt level.
signal,"© Copyright 1988, 2024 RTEMS Project and contributors."
signal,"This section details the directives of the Signal Manager. A subsection is dedicated to each of this manager’s directives and lists the calling sequence, parameters, description, return values, and notes of the directive."
signal,Establishes an asynchronous signal routine (ASR) for the calling task.
signal,CALLING SEQUENCE:
signal,PARAMETERS:
signal,This parameter is the handler to process an asynchronous signal set.
signal,This parameter is the task mode while an asynchronous signal set is processed by the handler.  See rtems_task_mode().
signal,DESCRIPTION:
signal,"This directive establishes an asynchronous signal routine (ASR) for the calling task.  The asr_handler parameter specifies the entry point of the ASR.  A task may have at most one handler installed at a time.  The most recently installed handler is used.  When asr_handler is NULL, the ASR for the calling task is invalidated and all pending signals are cleared.  Any signals sent to a task with an invalid ASR are discarded.  The mode_set parameter specifies the execution mode for the ASR.  This execution mode supersedes the task’s execution mode while the ASR is executing."
signal,RETURN VALUES:
signal,The requested operation was successful.
signal,The RTEMS_NO_PREEMPT was set in mode_set and the system configuration had no implementation for this mode.
signal,The RTEMS_INTERRUPT_LEVEL() was set to a positive level in mode_set and the system configuration had no implementation for this mode.
signal,NOTES:
signal,"It is strongly recommended to disable ASR processing during ASR processing by setting RTEMS_NO_ASR in mode_set, otherwise a recursion may happen during ASR processing.  Uncontrolled recursion may lead to stack overflows."
signal,Using the same mutex (in particular a recursive mutex) in normal task context and during ASR processing may result in undefined behaviour.
signal,"Asynchronous signal handlers can access thread-local storage (TLS). When thread-local storage is shared between normal task context and ASR processing, it may be protected by disabled interrupts."
signal,CONSTRAINTS:
signal,The following constraints apply to this directive:
signal,The directive may be called from within task context. The directive will not cause the calling task to be preempted.
signal,The directive may be called from within task context.
signal,The directive will not cause the calling task to be preempted.
signal,Sends the signal set to the task.
signal,CALLING SEQUENCE:
signal,PARAMETERS:
signal,This parameter is the identifier of the target task to receive the signal set.
signal,This parameter is the signal set to send.
signal,DESCRIPTION:
signal,"This directive sends the signal set, signal_set, to the target task identified by id."
signal,"If a caller sends a signal set to a task with an invalid ASR, then an error code is returned to the caller.  If a caller sends a signal set to a task whose ASR is valid but disabled, then the signal set will be caught and left pending for the ASR to process when it is enabled.  If a caller sends a signal set to a task with an ASR that is both valid and enabled, then the signal set is caught and the ASR will execute the next time the task is dispatched to run."
signal,RETURN VALUES:
signal,The requested operation was successful.
signal,The signal_set parameter was 0.
signal,There was no task associated with the identifier specified by id.
signal,The target task had no valid ASR installed.
signal,NOTES:
signal,"Sending a signal set to a task has no effect on that task’s state.  If a signal set is sent to a blocked task, then the task will remain blocked and the signals will be processed when the task becomes the running task."
signal,Sending a signal set to a global task which does not reside on the local node will generate a request telling the remote node to send the signal set to the specified task.
signal,CONSTRAINTS:
signal,The following constraints apply to this directive:
signal,"The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. When the directive operates on a local object, the directive will not cause the calling task to be preempted. When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply.  This will preempt the calling task."
signal,The directive may be called from within interrupt context.
signal,The directive may be called from within device driver initialization context.
signal,The directive may be called from within task context.
signal,"When the directive operates on a local object, the directive will not cause the calling task to be preempted."
signal,"When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply.  This will preempt the calling task."
signal,"© Copyright 1988, 2024 RTEMS Project and contributors."
signal,The Signal Manager provides the capabilities required for asynchronous communication. The directives provided by the Signal Manager are:
signal,rtems_signal_catch() - Establishes an asynchronous signal routine (ASR) for the calling task. rtems_signal_send() - Sends the signal set to the task.
signal,rtems_signal_catch() - Establishes an asynchronous signal routine (ASR) for the calling task.
signal,rtems_signal_send() - Sends the signal set to the task.
signal,"© Copyright 1988, 2024 RTEMS Project and contributors."
signal,"The rtems_signal_catch directive establishes an ASR for the calling task. The address of the ASR and its execution mode are specified to this directive. The ASR’s mode is distinct from the task’s mode.  For example, the task may allow preemption, while that task’s ASR may have preemption disabled.  Until a task calls rtems_signal_catch the first time, its ASR is invalid, and no signal sets can be sent to the task."
signal,"A task may invalidate its ASR and discard all pending signals by calling rtems_signal_catch with a value of NULL for the ASR’s address.  When a task’s ASR is invalid, new signal sets sent to this task are discarded."
signal,"A task may disable ASR processing (RTEMS_NO_ASR) via the task_mode directive.  When a task’s ASR is disabled, the signals sent to it are left pending to be processed later when the ASR is enabled."
signal,"Any directive that can be called from a task can also be called from an ASR.  A task is only allowed one active ASR.  Thus, each call to rtems_signal_catch replaces the previous one."
signal,"Normally, signal processing is disabled for the ASR’s execution mode, but if signal processing is enabled for the ASR, the ASR must be reentrant."
signal,"The rtems_signal_send directive allows both tasks and ISRs to send signals to a target task.  The target task and a set of signals are specified to the rtems_signal_send directive.  The sending of a signal to a task has no effect on the execution state of that task.  If the task is not the currently running task, then the signals are left pending and processed by the task’s ASR the next time the task is dispatched to run.  The ASR is executed immediately before the task is dispatched.  If the currently running task sends a signal to itself or is sent a signal from an ISR, its ASR is immediately dispatched to run provided signal processing is enabled."
signal,"If an ASR with signals enabled is preempted by another task or an ISR and a new signal set is sent, then a new copy of the ASR will be invoked, nesting the preempted ASR.  Upon completion of processing the new signal set, control will return to the preempted ASR.  In this situation, the ASR must be reentrant."
signal,"Like events, identical signals sent to a task are not queued.  In other words, sending the same signal multiple times to a task (without any intermediate signal processing occurring for the task), has the same result as sending that signal to that task once."
signal,"Asynchronous signals were designed to provide the capability to generate software interrupts.  The processing of software interrupts parallels that of hardware interrupts.  As a result, the differences between the formats of ASRs and ISRs is limited to the meaning of the single argument passed to an ASR. The ASR should have the following calling sequence and adhere to C calling conventions:"
signal,When the ASR returns to RTEMS the mode and execution path of the interrupted task (or ASR) is restored to the context prior to entering the ASR.
signal,"© Copyright 1988, 2024 RTEMS Project and contributors."
task,"Many definitions of a task have been proposed in computer literature. Unfortunately, none of these definitions encompasses all facets of the concept in a manner which is operating system independent.  Several of the more common definitions are provided to enable each user to select a definition which best matches their own experience and understanding of the task concept:"
task,"a “dispatchable” unit. an entity to which the processor is allocated. an atomic unit of a real-time, multiprocessor system. single threads of execution which concurrently compete for resources. a sequence of closely related computations which can execute concurrently with other computational sequences."
task,a “dispatchable” unit.
task,an entity to which the processor is allocated.
task,"an atomic unit of a real-time, multiprocessor system."
task,single threads of execution which concurrently compete for resources.
task,a sequence of closely related computations which can execute concurrently with other computational sequences.
task,"From RTEMS’ perspective, a task is the smallest thread of execution which can compete on its own for system resources.  A task is manifested by the existence of a task control block (TCB)."
task,"The Task Control Block (TCB) is an RTEMS defined data structure which contains all the information that is pertinent to the execution of a task.  During system initialization, RTEMS reserves a TCB for each task configured.  A TCB is allocated upon creation of the task and is returned to the TCB free list upon deletion of the task."
task,"The TCB’s elements are modified as a result of system calls made by the application in response to external and internal stimuli.  TCBs are the only RTEMS internal data structure that can be accessed by an application via user extension routines.  The TCB contains a task’s name, ID, current priority, current and starting states, execution mode, TCB user extension pointer, scheduling control structures, as well as data required by a blocked task."
task,"A task’s context is stored in the TCB when a task switch occurs.  When the task regains control of the processor, its context is restored from the TCB.  When a task is restarted, the initial state of the task is restored from the starting context area in the task’s TCB."
task,The system uses two separate memory areas to manage a task.  One memory area is the Task Control Block.  The other memory area is allocated from the stack space or provided by the user and contains
task,"the task stack, the thread-local storage (TLS), and an optional architecture-specific floating-point context."
task,"the task stack,"
task,"the thread-local storage (TLS), and"
task,an optional architecture-specific floating-point context.
task,The size of the thread-local storage is determined at link time.  A user-provided task stack must take the size of the thread-local storage into account.
task,"On architectures with a dedicated floating-point context, the application configuration assumes that every task is a floating-point task, but whether or not a task is actually floating-point is determined at runtime during task creation (see Floating Point Considerations).  In highly memory constrained systems this potential overestimate of the task stack space can be mitigated through the CONFIGURE_MINIMUM_TASK_STACK_SIZE configuration option and aligned task stack sizes for the tasks.  A user-provided task stack must take the potential floating-point context into account."
task,"By default, the task name is defined by the task object name given to rtems_task_create().  The task name can be obtained with the pthread_getname_np() function. Optionally, a new task name may be set with the pthread_setname_np() function. The maximum size of a task name is defined by the application configuration option CONFIGURE_MAXIMUM_THREAD_NAME_SIZE."
task,A task may exist in one of the following five states:
task,executing - Currently scheduled to the CPU ready - May be scheduled to the CPU blocked - Unable to be scheduled to the CPU dormant - Created task that is not started non-existent - Uncreated or deleted task
task,executing - Currently scheduled to the CPU
task,ready - May be scheduled to the CPU
task,blocked - Unable to be scheduled to the CPU
task,dormant - Created task that is not started
task,non-existent - Uncreated or deleted task
task,"An active task may occupy the executing, ready, blocked or dormant state, otherwise the task is considered non-existent.  One or more tasks may be active in the system simultaneously.  Multiple tasks communicate, synchronize, and compete for system resources with each other via system calls.  The multiple tasks appear to execute in parallel, but actually each is dispatched to the CPU for periods of time determined by the RTEMS scheduling algorithm.  The scheduling of a task is based on its current state and priority."
task,"A task’s priority determines its importance in relation to the other tasks executing on the processor set owned by a scheduler.  Normally, RTEMS supports 256 levels of priority ranging from 0 to 255.  The priority level 0 represents a special priority reserved for the operating system.  The data type rtems_task_priority is used to store task priorities.  The maximum priority level depends on the configured scheduler, see CONFIGURE_MAXIMUM_PRIORITY, Clustered Scheduler Configuration, and Scheduling Concepts."
task,"Tasks of numerically smaller priority values are more important tasks than tasks of numerically larger priority values.  For example, a task at priority level 5 is of higher privilege than a task at priority level 10.  There is no limit to the number of tasks assigned to the same priority."
task,Each task has a priority associated with it at all times.  The initial value of this priority is assigned at task creation time.  The priority of a task may be changed at any subsequent time.
task,"Priorities are used by the scheduler to determine which ready task will be allowed to execute.  In general, the higher the logical priority of a task, the more likely it is to receive processor execution time."
task,A task’s execution mode is a combination of the following four components:
task,preemption ASR processing timeslicing interrupt level
task,preemption
task,ASR processing
task,timeslicing
task,interrupt level
task,It is used to modify RTEMS’ scheduling process and to alter the execution environment of the task.  The data type rtems_task_mode is used to manage the task execution mode.
task,"The preemption component allows a task to determine when control of the processor is relinquished.  If preemption is disabled (RTEMS_NO_PREEMPT), the task will retain control of the processor as long as it is in the executing state - even if a higher priority task is made ready.  If preemption is enabled (RTEMS_PREEMPT) and a higher priority task is made ready, then the processor will be taken away from the current task immediately and given to the higher priority task."
task,"The timeslicing component is used by the RTEMS scheduler to determine how the processor is allocated to tasks of equal priority.  If timeslicing is enabled (RTEMS_TIMESLICE), then RTEMS will limit the amount of time the task can execute before the processor is allocated to another ready task of equal priority. The length of the timeslice is application dependent and specified in the Configuration Table.  If timeslicing is disabled (RTEMS_NO_TIMESLICE), then the task will be allowed to execute until a task of higher priority is made ready.  If RTEMS_NO_PREEMPT is selected, then the timeslicing component is ignored by the scheduler."
task,"The asynchronous signal processing component is used to determine when received signals are to be processed by the task.  If signal processing is enabled (RTEMS_ASR), then signals sent to the task will be processed the next time the task executes.  If signal processing is disabled (RTEMS_NO_ASR), then all signals received by the task will remain posted until signal processing is enabled.  This component affects only tasks which have established a routine to process asynchronous signals."
task,The interrupt level component is used to determine which interrupts will be enabled when the task is executing. RTEMS_INTERRUPT_LEVEL(n) specifies that the task will execute at interrupt level n.
task,RTEMS_PREEMPT enable preemption (default) RTEMS_NO_PREEMPT disable preemption RTEMS_NO_TIMESLICE disable timeslicing (default) RTEMS_TIMESLICE enable timeslicing RTEMS_ASR enable ASR processing (default) RTEMS_NO_ASR disable ASR processing RTEMS_INTERRUPT_LEVEL(0) enable all interrupts (default) RTEMS_INTERRUPT_LEVEL(n) execute at interrupt level n
task,RTEMS_PREEMPT
task,enable preemption (default)
task,RTEMS_NO_PREEMPT
task,disable preemption
task,RTEMS_NO_TIMESLICE
task,disable timeslicing (default)
task,RTEMS_TIMESLICE
task,enable timeslicing
task,RTEMS_ASR
task,enable ASR processing (default)
task,RTEMS_NO_ASR
task,disable ASR processing
task,RTEMS_INTERRUPT_LEVEL(0)
task,enable all interrupts (default)
task,RTEMS_INTERRUPT_LEVEL(n)
task,execute at interrupt level n
task,The set of default modes may be selected by specifying the RTEMS_DEFAULT_MODES constant.
task,"Independent of the task state with respect to the scheduler, the task life is determined by several orthogonal states:"
task,protected or unprotected deferred life changes or no deferred life changes restarting or not restarting terminating or not terminating detached or not detached
task,protected or unprotected
task,deferred life changes or no deferred life changes
task,restarting or not restarting
task,terminating or not terminating
task,detached or not detached
task,"While the task life is protected, asynchronous task restart and termination requests are blocked.  A task may still restart or terminate itself.  All tasks are created with an unprotected task life.  The task life protection is used by the system to prevent system resources being affected by asynchronous task restart and termination requests.  The task life protection can be enabled (PTHREAD_CANCEL_DISABLE) or disabled (PTHREAD_CANCEL_ENABLE) for the calling task through the pthread_setcancelstate() directive."
task,"While deferred life changes are enabled, asynchronous task restart and termination requests are delayed until the task performs a life change itself or calls pthread_testcancel().  Cancellation points are not implemented in RTEMS.  Deferred task life changes can be enabled (PTHREAD_CANCEL_DEFERRED) or disabled (PTHREAD_CANCEL_ASYNCHRONOUS) for the calling task through the pthread_setcanceltype() directive.  Classic API tasks are created with deferred life changes disabled.  POSIX threads are created with deferred life changes enabled."
task,A task is made restarting by issuing a task restart request through the rtems_task_restart() directive.
task,"A task is made terminating by issuing a task termination request through the rtems_task_exit(), rtems_task_delete(), pthread_exit(), and pthread_cancel() directives."
task,"When a detached task terminates, the termination procedure completes without the need for another task to join with the terminated task.  Classic API tasks are created as not detached.  The detached state of created POSIX threads is determined by the thread attributes.  They are created as not detached by default.  The calling task is made detached through the pthread_detach() directive.  The rtems_task_exit() directive and self deletion though rtems_task_delete() directive make the calling task detached.  In contrast, the pthread_exit() directive does not change the detached state of the calling task."
task,All RTEMS tasks are invoked with a single argument which is specified when they are started or restarted.  The argument is commonly used to communicate startup information to the task.  The simplest manner in which to define a task which accesses it argument is:
task,Application tasks requiring more information may view this single argument as an index into an array of parameter blocks.
task,Please consult the RTEMS CPU Architecture Supplement if this section is relevant on your architecture.  On some architectures the floating-point context is contained in the normal task context and this section does not apply.
task,Creating a task with the RTEMS_FLOATING_POINT attribute flag results in additional memory being allocated for the task to store the state of the numeric coprocessor during task switches.  This additional memory is not allocated for RTEMS_NO_FLOATING_POINT tasks. Saving and restoring the context of a RTEMS_FLOATING_POINT task takes longer than that of a RTEMS_NO_FLOATING_POINT task because of the relatively large amount of time required for the numeric coprocessor to save or restore its computational state.
task,"Since RTEMS was designed specifically for embedded military applications which are floating point intensive, the executive is optimized to avoid unnecessarily saving and restoring the state of the numeric coprocessor.  In uniprocessor configurations, the state of the numeric coprocessor is only saved when a RTEMS_FLOATING_POINT task is dispatched and that task was not the last task to utilize the coprocessor.  In a uniprocessor system with only one RTEMS_FLOATING_POINT task, the state of the numeric coprocessor will never be saved or restored."
task,"Although the overhead imposed by RTEMS_FLOATING_POINT tasks is minimal, some applications may wish to completely avoid the overhead associated with RTEMS_FLOATING_POINT tasks and still utilize a numeric coprocessor.  By preventing a task from being preempted while performing a sequence of floating point operations, a RTEMS_NO_FLOATING_POINT task can utilize the numeric coprocessor without incurring the overhead of a RTEMS_FLOATING_POINT context switch.  This approach also avoids the allocation of a floating point context area.  However, if this approach is taken by the application designer, no tasks should be created as RTEMS_FLOATING_POINT tasks.  Otherwise, the floating point context will not be correctly maintained because RTEMS assumes that the state of the numeric coprocessor will not be altered by RTEMS_NO_FLOATING_POINT tasks.  Some architectures with a dedicated floating-point context raise a processor exception if a task with RTEMS_NO_FLOATING_POINT issues a floating-point instruction, so this approach may not work at all."
task,"If the supported processor type does not have hardware floating capabilities or a standard numeric coprocessor, RTEMS will not provide built-in support for hardware floating point on that processor.  In this case, all tasks are considered RTEMS_NO_FLOATING_POINT whether created as RTEMS_FLOATING_POINT or RTEMS_NO_FLOATING_POINT tasks.  A floating point emulation software library must be utilized for floating point operations."
task,"On some processors, it is possible to disable the floating point unit dynamically.  If this capability is supported by the target processor, then RTEMS will utilize this capability to enable the floating point unit only for tasks which are created with the RTEMS_FLOATING_POINT attribute.  The consequence of a RTEMS_NO_FLOATING_POINT task attempting to access the floating point unit is CPU dependent but will generally result in an exception condition."
task,"In general, an attribute set is built by a bitwise OR of the desired components.  The set of valid task attribute components is listed below:"
task,RTEMS_NO_FLOATING_POINT does not use coprocessor (default) RTEMS_FLOATING_POINT uses numeric coprocessor RTEMS_LOCAL local task (default) RTEMS_GLOBAL global task
task,RTEMS_NO_FLOATING_POINT
task,does not use coprocessor (default)
task,RTEMS_FLOATING_POINT
task,uses numeric coprocessor
task,RTEMS_LOCAL
task,local task (default)
task,RTEMS_GLOBAL
task,global task
task,"Attribute values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each attribute appears exactly once in the component list.  A component listed as a default is not required to appear in the component list, although it is a good programming practice to specify default components.  If all defaults are desired, then RTEMS_DEFAULT_ATTRIBUTES should be used."
task,"This example demonstrates the attribute_set parameter needed to create a local task which utilizes the numeric coprocessor.  The attribute_set parameter could be RTEMS_FLOATING_POINT or RTEMS_LOCAL | RTEMS_FLOATING_POINT.  The attribute_set parameter can be set to RTEMS_FLOATING_POINT because RTEMS_LOCAL is the default for all created tasks.  If the task were global and used the numeric coprocessor, then the attribute_set parameter would be RTEMS_GLOBAL | RTEMS_FLOATING_POINT."
task,"In general, a mode and its corresponding mask is built by a bitwise OR of the desired components.  The set of valid mode constants and each mode’s corresponding mask constant is listed below:"
task,RTEMS_PREEMPT is masked by RTEMS_PREEMPT_MASK and enables preemption RTEMS_NO_PREEMPT is masked by RTEMS_PREEMPT_MASK and disables preemption RTEMS_NO_TIMESLICE is masked by RTEMS_TIMESLICE_MASK and disables timeslicing RTEMS_TIMESLICE is masked by RTEMS_TIMESLICE_MASK and enables timeslicing RTEMS_ASR is masked by RTEMS_ASR_MASK and enables ASR processing RTEMS_NO_ASR is masked by RTEMS_ASR_MASK and disables ASR processing RTEMS_INTERRUPT_LEVEL(0) is masked by RTEMS_INTERRUPT_MASK and enables all interrupts RTEMS_INTERRUPT_LEVEL(n) is masked by RTEMS_INTERRUPT_MASK and sets interrupts level n
task,RTEMS_PREEMPT
task,is masked by RTEMS_PREEMPT_MASK and enables preemption
task,RTEMS_NO_PREEMPT
task,is masked by RTEMS_PREEMPT_MASK and disables preemption
task,RTEMS_NO_TIMESLICE
task,is masked by RTEMS_TIMESLICE_MASK and disables timeslicing
task,RTEMS_TIMESLICE
task,is masked by RTEMS_TIMESLICE_MASK and enables timeslicing
task,RTEMS_ASR
task,is masked by RTEMS_ASR_MASK and enables ASR processing
task,RTEMS_NO_ASR
task,is masked by RTEMS_ASR_MASK and disables ASR processing
task,RTEMS_INTERRUPT_LEVEL(0)
task,is masked by RTEMS_INTERRUPT_MASK and enables all interrupts
task,RTEMS_INTERRUPT_LEVEL(n)
task,is masked by RTEMS_INTERRUPT_MASK and sets interrupts level n
task,"Mode values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each mode appears exactly once in the component list.  A mode component listed as a default is not required to appear in the mode component list, although it is a good programming practice to specify default components.  If all defaults are desired, the mode RTEMS_DEFAULT_MODES and the mask RTEMS_ALL_MODE_MASKS should be used."
task,"The following example demonstrates the mode and mask parameters used with the rtems_task_mode directive to place a task at interrupt level 3 and make it non-preemptible.  The mode should be set to RTEMS_INTERRUPT_LEVEL(3) | RTEMS_NO_PREEMPT to indicate the desired preemption mode and interrupt level, while the mask parameter should be set to RTEMS_INTERRUPT_MASK | RTEMS_NO_PREEMPT_MASK to indicate that the calling task’s interrupt level and preemption mode are being altered."
task,"© Copyright 1988, 2024 RTEMS Project and contributors."
task,"This section details the directives of the Task Manager. A subsection is dedicated to each of this manager’s directives and lists the calling sequence, parameters, description, return values, and notes of the directive."
task,Creates a task.
task,CALLING SEQUENCE:
task,PARAMETERS:
task,This parameter is the object name of the task.
task,This parameter is the initial task priority.
task,This parameter is the task stack size in bytes.
task,This parameter is the initial mode set of the task.
task,This parameter is the attribute set of the task.
task,"This parameter is the pointer to an rtems_id object.  When the directive call is successful, the identifier of the created task will be stored in this object."
task,DESCRIPTION:
task,This directive creates a task which resides on the local node.  The task has the user-defined object name specified in name.  The assigned object identifier is returned in id.  This identifier is used to access the task with other task related directives.
task,The initial priority of the task is specified in initial_priority. The home scheduler of the created task is the home scheduler of the calling task at some time point during the task creation. The initial task priority specified in initial_priority shall be valid for this scheduler.
task,"The stack size of the task is specified in stack_size.  If the requested stack size is less than the configured minimum stack size, then RTEMS will use the configured minimum as the stack size for this task.  The configured minimum stack size is defined by the CONFIGURE_MINIMUM_TASK_STACK_SIZE application configuration option.  In addition to being able to specify the task stack size as a integer, there are two constants which may be specified:"
task,"The RTEMS_MINIMUM_STACK_SIZE constant can be specified to use the recommended minimum stack size for the target processor.  This value is selected by the RTEMS maintainers conservatively to minimize the risk of blown stacks for most user applications.  Using this constant when specifying the task stack size, indicates that the stack size will be at least RTEMS_MINIMUM_STACK_SIZE bytes in size.  If the user configured minimum stack size is larger than the recommended minimum, then it will be used. The RTEMS_CONFIGURED_MINIMUM_STACK_SIZE constant can be specified to use the minimum stack size that was configured by the application.  If not explicitly configured by the application, the default configured minimum stack size is the target processor dependent value RTEMS_MINIMUM_STACK_SIZE.  Since this uses the configured minimum stack size value, you may get a stack size that is smaller or larger than the recommended minimum.  This can be used to provide large stacks for all tasks on complex applications or small stacks on applications that are trying to conserve memory."
task,"The RTEMS_MINIMUM_STACK_SIZE constant can be specified to use the recommended minimum stack size for the target processor.  This value is selected by the RTEMS maintainers conservatively to minimize the risk of blown stacks for most user applications.  Using this constant when specifying the task stack size, indicates that the stack size will be at least RTEMS_MINIMUM_STACK_SIZE bytes in size.  If the user configured minimum stack size is larger than the recommended minimum, then it will be used."
task,"The RTEMS_CONFIGURED_MINIMUM_STACK_SIZE constant can be specified to use the minimum stack size that was configured by the application.  If not explicitly configured by the application, the default configured minimum stack size is the target processor dependent value RTEMS_MINIMUM_STACK_SIZE.  Since this uses the configured minimum stack size value, you may get a stack size that is smaller or larger than the recommended minimum.  This can be used to provide large stacks for all tasks on complex applications or small stacks on applications that are trying to conserve memory."
task,"The initial mode set specified in initial_modes is built through a bitwise or of the mode constants described below.  Not all combinations of modes are allowed.  Some modes are mutually exclusive.  If mutually exclusive modes are combined, the behaviour is undefined.  Default task modes can be selected by using the RTEMS_DEFAULT_MODES constant.  The task mode set defines"
task,"the preemption mode of the task: RTEMS_PREEMPT (default) or RTEMS_NO_PREEMPT, the timeslicing mode of the task: RTEMS_TIMESLICE or RTEMS_NO_TIMESLICE (default), the ASR processing mode of the task: RTEMS_ASR (default) or RTEMS_NO_ASR, the interrupt level of the task: RTEMS_INTERRUPT_LEVEL() with a default of RTEMS_INTERRUPT_LEVEL( 0 ) which is associated with enabled interrupts."
task,"the preemption mode of the task: RTEMS_PREEMPT (default) or RTEMS_NO_PREEMPT,"
task,"the timeslicing mode of the task: RTEMS_TIMESLICE or RTEMS_NO_TIMESLICE (default),"
task,"the ASR processing mode of the task: RTEMS_ASR (default) or RTEMS_NO_ASR,"
task,the interrupt level of the task: RTEMS_INTERRUPT_LEVEL() with a default of RTEMS_INTERRUPT_LEVEL( 0 ) which is associated with enabled interrupts.
task,The initial preemption mode of the task is enabled or disabled.
task,An enabled preemption is the default and can be emphasized through the use of the RTEMS_PREEMPT mode constant. A disabled preemption is set by the RTEMS_NO_PREEMPT mode constant.
task,An enabled preemption is the default and can be emphasized through the use of the RTEMS_PREEMPT mode constant.
task,A disabled preemption is set by the RTEMS_NO_PREEMPT mode constant.
task,The initial timeslicing mode of the task is enabled or disabled.
task,A disabled timeslicing is the default and can be emphasized through the use of the RTEMS_NO_TIMESLICE mode constant. An enabled timeslicing is set by the RTEMS_TIMESLICE mode constant.
task,A disabled timeslicing is the default and can be emphasized through the use of the RTEMS_NO_TIMESLICE mode constant.
task,An enabled timeslicing is set by the RTEMS_TIMESLICE mode constant.
task,The initial ASR processing mode of the task is enabled or disabled.
task,An enabled ASR processing is the default and can be emphasized through the use of the RTEMS_ASR mode constant. A disabled ASR processing is set by the RTEMS_NO_ASR mode constant.
task,An enabled ASR processing is the default and can be emphasized through the use of the RTEMS_ASR mode constant.
task,A disabled ASR processing is set by the RTEMS_NO_ASR mode constant.
task,The initial interrupt level mode of the task is defined by RTEMS_INTERRUPT_LEVEL().
task,Task execution with interrupts enabled the default and can be emphasized through the use of the RTEMS_INTERRUPT_LEVEL() mode macro with a value of zero (0) for the parameter.  An interrupt level of zero is associated with enabled interrupts on all target processors. Task execution at a non-zero interrupt level can be specified by the RTEMS_INTERRUPT_LEVEL() mode macro with a non-zero value for the parameter.  The interrupt level portion of the task mode supports a maximum of 256 interrupt levels.  These levels are mapped onto the interrupt levels actually supported by the target processor in a processor dependent fashion.
task,Task execution with interrupts enabled the default and can be emphasized through the use of the RTEMS_INTERRUPT_LEVEL() mode macro with a value of zero (0) for the parameter.  An interrupt level of zero is associated with enabled interrupts on all target processors.
task,Task execution at a non-zero interrupt level can be specified by the RTEMS_INTERRUPT_LEVEL() mode macro with a non-zero value for the parameter.  The interrupt level portion of the task mode supports a maximum of 256 interrupt levels.  These levels are mapped onto the interrupt levels actually supported by the target processor in a processor dependent fashion.
task,"The attribute set specified in attribute_set is built through a bitwise or of the attribute constants described below.  Not all combinations of attributes are allowed.  Some attributes are mutually exclusive.  If mutually exclusive attributes are combined, the behaviour is undefined. Attributes not mentioned below are not evaluated by this directive and have no effect.  Default attributes can be selected by using the RTEMS_DEFAULT_ATTRIBUTES constant.  The attribute set defines"
task,the scope of the task: RTEMS_LOCAL (default) or RTEMS_GLOBAL and the floating-point unit use of the task: RTEMS_FLOATING_POINT or RTEMS_NO_FLOATING_POINT (default).
task,the scope of the task: RTEMS_LOCAL (default) or RTEMS_GLOBAL and
task,the floating-point unit use of the task: RTEMS_FLOATING_POINT or RTEMS_NO_FLOATING_POINT (default).
task,The task has a local or global scope in a multiprocessing network (this attribute does not refer to SMP systems).  The scope is selected by the mutually exclusive RTEMS_LOCAL and RTEMS_GLOBAL attributes.
task,A local scope is the default and can be emphasized through the use of the RTEMS_LOCAL attribute.  A local task can be only used by the node which created it. A global scope is established if the RTEMS_GLOBAL attribute is set.  Setting the global attribute in a single node system has no effect.the
task,A local scope is the default and can be emphasized through the use of the RTEMS_LOCAL attribute.  A local task can be only used by the node which created it.
task,A global scope is established if the RTEMS_GLOBAL attribute is set.  Setting the global attribute in a single node system has no effect.the
task,"The use of the floating-point unit is selected by the mutually exclusive RTEMS_FLOATING_POINT and RTEMS_NO_FLOATING_POINT attributes.  On some target processors, the use of the floating-point unit can be enabled or disabled for each task.  Other target processors may have no hardware floating-point unit or enable the use of the floating-point unit for all tasks.  Consult the RTEMS CPU Architecture Supplement for the details."
task,"A disabled floating-point unit is the default and can be emphasized through use of the RTEMS_NO_FLOATING_POINT attribute.  For performance reasons, it is recommended that tasks not using the floating-point unit should specify this attribute. An enabled floating-point unit is selected by the RTEMS_FLOATING_POINT attribute."
task,"A disabled floating-point unit is the default and can be emphasized through use of the RTEMS_NO_FLOATING_POINT attribute.  For performance reasons, it is recommended that tasks not using the floating-point unit should specify this attribute."
task,An enabled floating-point unit is selected by the RTEMS_FLOATING_POINT attribute.
task,RETURN VALUES:
task,The requested operation was successful.
task,The name parameter was invalid.
task,The id parameter was NULL.
task,The initial_priority was invalid.
task,There was no inactive object available to create a task.  The number of tasks available to the application is configured through the CONFIGURE_MAXIMUM_TASKS application configuration option.
task,"In multiprocessing configurations, there was no inactive global object available to create a global task.  The number of global objects available to the application is configured through the CONFIGURE_MP_MAXIMUM_GLOBAL_OBJECTS application configuration option."
task,"There was not enough memory to allocate the task storage area.  The task storage area contains the task stack, the thread-local storage, and the floating point context."
task,One of the task create extensions failed to create the task.
task,"In SMP configurations, the non-preemption mode was not supported."
task,"In SMP configurations, the interrupt level mode was not supported."
task,NOTES:
task,The task processor affinity is initialized to the set of online processors.
task,"When created, a task is placed in the dormant state and can only be made ready to execute using the directive rtems_task_start()."
task,"Application developers should consider the stack usage of the device drivers when calculating the stack size required for tasks which utilize the driver. The task stack size shall account for an target processor dependent interrupt stack frame which may be placed on the stack of the interrupted task while servicing an interrupt.  The stack checker may be used to monitor the stack usage, see CONFIGURE_STACK_CHECKER_ENABLED."
task,"For control and maintenance of the task, RTEMS allocates a TCB from the local TCB free pool and initializes it."
task,"The TCB for a global task is allocated on the local node.  Task should not be made global unless remote tasks must interact with the task.  This is to avoid the system overhead incurred by the creation of a global task.  When a global task is created, the task’s name and identifier must be transmitted to every node in the system for insertion in the local copy of the global object table."
task,CONSTRAINTS:
task,The following constraints apply to this directive:
task,"The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted. When the directive operates on a global object, the directive sends a message to remote nodes.  This may preempt the calling task. The number of tasks available to the application is configured through the CONFIGURE_MAXIMUM_TASKS application configuration option. Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace. The number of global objects available to the application is configured through the CONFIGURE_MP_MAXIMUM_GLOBAL_OBJECTS application configuration option."
task,The directive may be called from within device driver initialization context.
task,The directive may be called from within task context.
task,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
task,"When the directive operates on a global object, the directive sends a message to remote nodes.  This may preempt the calling task."
task,The number of tasks available to the application is configured through the CONFIGURE_MAXIMUM_TASKS application configuration option.
task,"Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace."
task,The number of global objects available to the application is configured through the CONFIGURE_MP_MAXIMUM_GLOBAL_OBJECTS application configuration option.
task,Constructs a task from the specified task configuration.
task,CALLING SEQUENCE:
task,PARAMETERS:
task,This parameter is the pointer to an rtems_task_config object. It configures the task.
task,"This parameter is the pointer to an rtems_id object.  When the directive call is successful, the identifier of the constructed task will be stored in this object."
task,RETURN VALUES:
task,The requested operation was successful.
task,The config parameter was NULL.
task,The task name was invalid.
task,The id parameter was NULL.
task,The initial task priority was invalid.
task,The thread-local storage size is greater than the maximum thread-local storage size specified in the task configuration.  The thread-local storage size is determined by the thread-local variables used by the application and CONFIGURE_MAXIMUM_THREAD_LOCAL_STORAGE_SIZE.
task,"The task storage area was too small to provide a task stack of the configured minimum size, see CONFIGURE_MINIMUM_TASK_STACK_SIZE. The task storage area contains the task stack, the thread-local storage, and the floating-point context on architectures with a separate floating-point context."
task,There was no inactive task object available to construct a task.
task,"In multiprocessing configurations, there was no inactive global object available to construct a global task."
task,One of the task create extensions failed during the task construction.
task,"In SMP configurations, the non-preemption mode was not supported."
task,"In SMP configurations, the interrupt level mode was not supported."
task,NOTES:
task,"In contrast to tasks created by rtems_task_create(), the tasks constructed by this directive use a user-provided task storage area.  The task storage area contains the task stack, the thread-local storage, and the floating-point context on architectures with a separate floating-point context."
task,This directive is intended for applications which do not want to use the RTEMS Workspace and instead statically allocate all operating system resources.  It is not recommended to use rtems_task_create() and rtems_task_construct() together in an application.  It is also not recommended to use rtems_task_construct() for drivers or general purpose libraries.  The reason for these recommendations is that the task configuration needs settings which can be only given with a through knowledge of the application resources.
task,An application based solely on static allocation can avoid any runtime memory allocators.  This can simplify the application architecture as well as any analysis that may be required.
task,The stack space estimate done by <rtems/confdefs.h> assumes that all tasks are created by rtems_task_create().  The estimate can be adjusted to take user-provided task storage areas into account through the CONFIGURE_MINIMUM_TASKS_WITH_USER_PROVIDED_STORAGE application configuration option.
task,The CONFIGURE_MAXIMUM_TASKS should include tasks constructed by rtems_task_construct().
task,CONSTRAINTS:
task,The following constraints apply to this directive:
task,"The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted. When the directive operates on a global object, the directive sends a message to remote nodes.  This may preempt the calling task. The number of tasks available to the application is configured through the CONFIGURE_MAXIMUM_TASKS application configuration option. Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace. The number of global objects available to the application is configured through the CONFIGURE_MP_MAXIMUM_GLOBAL_OBJECTS application configuration option."
task,The directive may be called from within device driver initialization context.
task,The directive may be called from within task context.
task,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
task,"When the directive operates on a global object, the directive sends a message to remote nodes.  This may preempt the calling task."
task,The number of tasks available to the application is configured through the CONFIGURE_MAXIMUM_TASKS application configuration option.
task,"Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace."
task,The number of global objects available to the application is configured through the CONFIGURE_MP_MAXIMUM_GLOBAL_OBJECTS application configuration option.
task,Identifies a task by the object name.
task,CALLING SEQUENCE:
task,PARAMETERS:
task,This parameter is the object name to look up.
task,This parameter is the node or node set to search for a matching object.
task,"This parameter is the pointer to an rtems_id object.  When the directive call is successful, the object identifier of an object with the specified name will be stored in this object."
task,DESCRIPTION:
task,This directive obtains a task identifier associated with the task name specified in name.
task,A task may obtain its own identifier by specifying RTEMS_WHO_AM_I for the name.
task,The node to search is specified in node.  It shall be
task,"a valid node number, the constant RTEMS_SEARCH_ALL_NODES to search in all nodes, the constant RTEMS_SEARCH_LOCAL_NODE to search in the local node only, or the constant RTEMS_SEARCH_OTHER_NODES to search in all nodes except the local node."
task,"a valid node number,"
task,"the constant RTEMS_SEARCH_ALL_NODES to search in all nodes,"
task,"the constant RTEMS_SEARCH_LOCAL_NODE to search in the local node only, or"
task,the constant RTEMS_SEARCH_OTHER_NODES to search in all nodes except the local node.
task,RETURN VALUES:
task,The requested operation was successful.
task,The id parameter was NULL.
task,There was no object with the specified name on the specified nodes.
task,"In multiprocessing configurations, the specified node was invalid."
task,NOTES:
task,"If the task name is not unique, then the task identifier will match the first task with that name in the search order.  However, this task identifier is not guaranteed to correspond to the desired task."
task,"The objects are searched from lowest to the highest index.  If node is RTEMS_SEARCH_ALL_NODES, all nodes are searched with the local node being searched first.  All other nodes are searched from lowest to the highest node number."
task,"If node is a valid node number which does not represent the local node, then only the tasks exported by the designated node are searched."
task,This directive does not generate activity on remote nodes.  It accesses only the local copy of the global object table.
task,The task identifier is used with other task related directives to access the task.
task,CONSTRAINTS:
task,The following constraints apply to this directive:
task,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
task,The directive may be called from within any runtime context.
task,The directive will not cause the calling task to be preempted.
task,Gets the task identifier of the calling task.
task,CALLING SEQUENCE:
task,DESCRIPTION:
task,This directive returns the task identifier of the calling task.
task,RETURN VALUES:
task,Returns the task identifier of the calling task.
task,CONSTRAINTS:
task,The following constraints apply to this directive:
task,The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive will not cause the calling task to be preempted.
task,The directive may be called from within device driver initialization context.
task,The directive may be called from within task context.
task,The directive will not cause the calling task to be preempted.
task,Starts the task.
task,CALLING SEQUENCE:
task,PARAMETERS:
task,This parameter is the task identifier.  The constant RTEMS_SELF may be used to specify the calling task.
task,This parameter is the task entry point.
task,This parameter is the task entry point argument.
task,DESCRIPTION:
task,"This directive readies the task, specified by id, for execution based on the priority and execution mode specified when the task was created.  The task entry point of the task is given in entry_point.  The task’s entry point argument is contained in argument."
task,RETURN VALUES:
task,The requested operation was successful.
task,The entry_point parameter was NULL.
task,There was no task associated with the identifier specified by id.
task,The task was not in the dormant state.
task,The task resided on a remote node.
task,NOTES:
task,"The type of the entry point argument is an unsigned integer type.  However, the integer type has the property that any valid pointer to void can be converted to this type and then converted back to a pointer to void.  The result will compare equal to the original pointer.  The type can represent at least 32 bits.  Some applications use the entry point argument as an index into a parameter table to get task-specific parameters."
task,Any actions performed on a dormant task such as suspension or change of priority are nullified when the task is initiated via the rtems_task_start() directive.
task,CONSTRAINTS:
task,The following constraints apply to this directive:
task,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may unblock a task.  This may cause the calling task to be preempted.
task,The directive may be called from within interrupt context.
task,The directive may be called from within device driver initialization context.
task,The directive may be called from within task context.
task,The directive may unblock a task.  This may cause the calling task to be preempted.
task,Restarts the task.
task,CALLING SEQUENCE:
task,PARAMETERS:
task,This parameter is the task identifier.  The constant RTEMS_SELF may be used to specify the calling task.
task,This parameter is the task entry point argument.
task,DESCRIPTION:
task,"This directive resets the task specified by id to begin execution at its original entry point.  The task’s priority and execution mode are set to the original creation values.  If the task is currently blocked, RTEMS automatically makes the task ready.  A task can be restarted from any state, except the dormant state.  The task’s entry point argument is contained in argument."
task,RETURN VALUES:
task,The requested operation was successful.
task,There was no task associated with the identifier specified by id.
task,The task never started.
task,The task resided on a remote node.
task,NOTES:
task,"The type of the entry point argument is an unsigned integer type.  However, the integer type has the property that any valid pointer to void can be converted to this type and then converted back to a pointer to void.  The result will compare equal to the original pointer.  The type can represent at least 32 bits.  Some applications use the entry point argument as an index into a parameter table to get task-specific parameters."
task,"A new entry point argument may be used to distinguish between the initial rtems_task_start() of the task and any ensuing calls to rtems_task_restart() of the task.  This can be beneficial in deleting a task.  Instead of deleting a task using the rtems_task_delete() directive, a task can delete another task by restarting that task, and allowing that task to release resources back to RTEMS and then delete itself."
task,CONSTRAINTS:
task,The following constraints apply to this directive:
task,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may change the priority of a task.  This may cause the calling task to be preempted. The directive may unblock a task.  This may cause the calling task to be preempted.
task,The directive may be called from within interrupt context.
task,The directive may be called from within device driver initialization context.
task,The directive may be called from within task context.
task,The directive may change the priority of a task.  This may cause the calling task to be preempted.
task,The directive may unblock a task.  This may cause the calling task to be preempted.
task,Deletes the task.
task,CALLING SEQUENCE:
task,PARAMETERS:
task,This parameter is the task identifier.  The constant RTEMS_SELF may be used to specify the calling task.
task,DESCRIPTION:
task,"This directive deletes the task, either the calling task or another task, as specified by id."
task,RETURN VALUES:
task,The requested operation was successful.
task,There was no task associated with the identifier specified by id.
task,The directive was called from within interrupt context.
task,"The task termination procedure was started, however, waiting for the terminating task would have resulted in a deadlock."
task,The task resided on a remote node.
task,NOTES:
task,"The task deletion is done in several steps.  Firstly, the task is marked as terminating.  While the task life of the terminating task is protected, it executes normally until it disables the task life protection or it deletes itself.  A terminating task will eventually stop its normal execution and start its termination procedure.  The procedure executes in the context of the terminating task.  The task termination procedure involves the destruction of POSIX key values and running the task termination user extensions.  Once complete the execution of the task is stopped and task-specific resources are reclaimed by the system, such as the stack memory, any allocated delay or timeout timers, the TCB, and, if the task is RTEMS_FLOATING_POINT, its floating point context area.  RTEMS explicitly does not reclaim the following resources: region segments, partition buffers, semaphores, timers, or rate monotonic periods."
task,"A task is responsible for releasing its resources back to RTEMS before deletion.  To insure proper deallocation of resources, a task should not be deleted unless it is unable to execute or does not hold any RTEMS resources. If a task holds RTEMS resources, the task should be allowed to deallocate its resources before deletion.  A task can be directed to release its resources and delete itself by restarting it with a special argument or by sending it a message, an event, or a signal."
task,Deletion of the calling task (RTEMS_SELF) will force RTEMS to select another task to execute.
task,"When a task deletes another task, the calling task waits until the task termination procedure of the task being deleted has completed.  The terminating task inherits the eligible priorities of the calling task."
task,"When a global task is deleted, the task identifier must be transmitted to every node in the system for deletion from the local copy of the global object table."
task,"The task must reside on the local node, even if the task was created with the RTEMS_GLOBAL attribute."
task,CONSTRAINTS:
task,The following constraints apply to this directive:
task,"The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted. When the directive operates on a global object, the directive sends a message to remote nodes.  This may preempt the calling task. The calling task does not have to be the task that created the object.  Any local task that knows the object identifier can delete the object. Where the object class corresponding to the directive is configured to use unlimited objects, the directive may free memory to the RTEMS Workspace."
task,The directive may be called from within device driver initialization context.
task,The directive may be called from within task context.
task,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
task,"When the directive operates on a global object, the directive sends a message to remote nodes.  This may preempt the calling task."
task,The calling task does not have to be the task that created the object.  Any local task that knows the object identifier can delete the object.
task,"Where the object class corresponding to the directive is configured to use unlimited objects, the directive may free memory to the RTEMS Workspace."
task,Deletes the calling task.
task,CALLING SEQUENCE:
task,DESCRIPTION:
task,This directive deletes the calling task.
task,NOTES:
task,"The directive is an optimized variant of the following code sequences, see also rtems_task_delete():"
task,CONSTRAINTS:
task,The following constraints apply to this directive:
task,"The directive may be called from within task context. The directive will not return to the caller. While thread dispatching is disabled, if the directive performs a thread dispatch, then the fatal error with the fatal source INTERNAL_ERROR_CORE and the fatal code INTERNAL_ERROR_BAD_THREAD_DISPATCH_DISABLE_LEVEL will occur."
task,The directive may be called from within task context.
task,The directive will not return to the caller.
task,"While thread dispatching is disabled, if the directive performs a thread dispatch, then the fatal error with the fatal source INTERNAL_ERROR_CORE and the fatal code INTERNAL_ERROR_BAD_THREAD_DISPATCH_DISABLE_LEVEL will occur."
task,Suspends the task.
task,CALLING SEQUENCE:
task,PARAMETERS:
task,This parameter is the task identifier.  The constant RTEMS_SELF may be used to specify the calling task.
task,DESCRIPTION:
task,This directive suspends the task specified by id from further execution by placing it in the suspended state.  This state is additive to any other blocked state that the task may already be in.  The task will not execute again until another task issues the rtems_task_resume() directive for this task and any blocked state has been removed.  The rtems_task_restart() directive will also remove the suspended state.
task,RETURN VALUES:
task,The requested operation was successful.
task,There was no task associated with the identifier specified by id.
task,The task was already suspended.
task,The task resided on a remote node.
task,NOTES:
task,"The requesting task can suspend itself for example by specifying RTEMS_SELF as id.  In this case, the task will be suspended and a successful return code will be returned when the task is resumed."
task,CONSTRAINTS:
task,The following constraints apply to this directive:
task,"The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply.  This will preempt the calling task."
task,The directive may be called from within interrupt context.
task,The directive may be called from within device driver initialization context.
task,The directive may be called from within task context.
task,"When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply.  This will preempt the calling task."
task,Resumes the task.
task,CALLING SEQUENCE:
task,PARAMETERS:
task,This parameter is the task identifier.
task,DESCRIPTION:
task,"This directive removes the task specified by id from the suspended state. If the task is in the ready state after the suspension is removed, then it will be scheduled to run.  If the task is still in a blocked state after the suspension is removed, then it will remain in that blocked state."
task,RETURN VALUES:
task,The requested operation was successful.
task,There was no task associated with the identifier specified by id.
task,The task was not suspended.
task,CONSTRAINTS:
task,The following constraints apply to this directive:
task,"The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may unblock a task.  This may cause the calling task to be preempted. When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply.  This will preempt the calling task."
task,The directive may be called from within interrupt context.
task,The directive may be called from within device driver initialization context.
task,The directive may be called from within task context.
task,The directive may unblock a task.  This may cause the calling task to be preempted.
task,"When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply.  This will preempt the calling task."
task,Checks if the task is suspended.
task,CALLING SEQUENCE:
task,PARAMETERS:
task,This parameter is the task identifier.  The constant RTEMS_SELF may be used to specify the calling task.
task,DESCRIPTION:
task,This directive returns a status code indicating whether or not the task specified by id is currently suspended.
task,RETURN VALUES:
task,The task was not suspended.
task,There was no task associated with the identifier specified by id.
task,The task was suspended.
task,The task resided on a remote node.
task,CONSTRAINTS:
task,The following constraints apply to this directive:
task,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive will not cause the calling task to be preempted.
task,The directive may be called from within interrupt context.
task,The directive may be called from within device driver initialization context.
task,The directive may be called from within task context.
task,The directive will not cause the calling task to be preempted.
task,Sets the real priority or gets the current priority of the task.
task,CALLING SEQUENCE:
task,PARAMETERS:
task,This parameter is the task identifier.  The constant RTEMS_SELF may be used to specify the calling task.
task,This parameter is the new real priority or RTEMS_CURRENT_PRIORITY to get the current priority.
task,"This parameter is the pointer to an rtems_task_priority object.  When the directive call is successful, the current or previous priority of the task with respect to its home scheduler will be stored in this object."
task,DESCRIPTION:
task,"This directive manipulates the priority of the task specified by id.  When new_priority is not equal to RTEMS_CURRENT_PRIORITY, the specified task’s previous priority is returned in old_priority.  When new_priority is RTEMS_CURRENT_PRIORITY, the specified task’s current priority is returned in old_priority."
task,RETURN VALUES:
task,The requested operation was successful.
task,The old_priority parameter was NULL.
task,There was no task associated with the identifier specified by id.
task,The task priority specified in new_priority was invalid with respect to the home scheduler of the task.
task,NOTES:
task,Valid priorities range from one to a maximum value which depends on the configured scheduler.  The lower the priority value the higher is the importance of the task.
task,"If the task is currently holding any binary semaphores which use a locking protocol, then the task’s priority cannot be lowered immediately.  If the task’s priority were lowered immediately, then this could violate properties of the locking protocol and may result in priority inversion.  The requested lowering of the task’s priority will occur when the task has released all binary semaphores which make the task more important.  The task’s priority can be increased regardless of the task’s use of binary semaphores with locking protocols."
task,CONSTRAINTS:
task,The following constraints apply to this directive:
task,"The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may change the priority of a task.  This may cause the calling task to be preempted. When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply.  This will preempt the calling task."
task,The directive may be called from within interrupt context.
task,The directive may be called from within device driver initialization context.
task,The directive may be called from within task context.
task,The directive may change the priority of a task.  This may cause the calling task to be preempted.
task,"When the directive operates on a remote object, the directive sends a message to the remote node and waits for a reply.  This will preempt the calling task."
task,Gets the current priority of the task with respect to the scheduler.
task,CALLING SEQUENCE:
task,PARAMETERS:
task,This parameter is the task identifier.  The constant RTEMS_SELF may be used to specify the calling task.
task,This parameter is the scheduler identifier.
task,"This parameter is the pointer to an rtems_task_priority object.  When the directive call is successful, the current priority of the task with respect to the specified scheduler will be stored in this object."
task,DESCRIPTION:
task,This directive returns the current priority in priority of the task specified by task_id with respect to the scheduler specified by scheduler_id.
task,RETURN VALUES:
task,The requested operation was successful.
task,The priority parameter was NULL.
task,There was no task associated with the identifier specified by task_id.
task,There was no scheduler associated with the identifier specified by scheduler_id.
task,The task had no priority with respect to the scheduler.
task,The task resided on a remote node.
task,NOTES:
task,"The current priority reflects temporary priority adjustments due to locking protocols, the rate-monotonic period objects on some schedulers such as EDF, and the POSIX sporadic server."
task,CONSTRAINTS:
task,The following constraints apply to this directive:
task,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive will not cause the calling task to be preempted.
task,The directive may be called from within interrupt context.
task,The directive may be called from within device driver initialization context.
task,The directive may be called from within task context.
task,The directive will not cause the calling task to be preempted.
task,Gets and optionally sets the mode of the calling task.
task,CALLING SEQUENCE:
task,PARAMETERS:
task,"This parameter is the mode set to apply to the calling task.  When mask is set to RTEMS_CURRENT_MODE, the value of this parameter is ignored.  Only modes requested by mask are applied to the calling task."
task,"This parameter is the mode mask which specifies which modes in mode_set are applied to the calling task.  When the value is RTEMS_CURRENT_MODE, the mode of the calling task is not changed."
task,"This parameter is the pointer to an rtems_mode object.  When the directive call is successful, the mode of the task before any mode changes done by the directive call will be stored in this object."
task,DESCRIPTION:
task,"This directive queries and optionally manipulates the execution mode of the calling task.  A task’s execution mode enables and disables preemption, timeslicing, asynchronous signal processing, as well as specifying the interrupt level.  To modify an execution mode, the mode class(es) to be changed must be specified in the mask parameter and the desired mode(s) must be specified in the mode_set parameter."
task,"A task can obtain its current execution mode, without modifying it, by calling this directive with a mask value of RTEMS_CURRENT_MODE."
task,"The mode set specified in mode_set is built through a bitwise or of the mode constants described below.  Not all combinations of modes are allowed. Some modes are mutually exclusive.  If mutually exclusive modes are combined, the behaviour is undefined.  Default task modes can be selected by using the RTEMS_DEFAULT_MODES constant.  The task mode set defines"
task,"the preemption mode of the task: RTEMS_PREEMPT (default) or RTEMS_NO_PREEMPT, the timeslicing mode of the task: RTEMS_TIMESLICE or RTEMS_NO_TIMESLICE (default), the ASR processing mode of the task: RTEMS_ASR (default) or RTEMS_NO_ASR, the interrupt level of the task: RTEMS_INTERRUPT_LEVEL() with a default of RTEMS_INTERRUPT_LEVEL( 0 ) which is associated with enabled interrupts."
task,"the preemption mode of the task: RTEMS_PREEMPT (default) or RTEMS_NO_PREEMPT,"
task,"the timeslicing mode of the task: RTEMS_TIMESLICE or RTEMS_NO_TIMESLICE (default),"
task,"the ASR processing mode of the task: RTEMS_ASR (default) or RTEMS_NO_ASR,"
task,the interrupt level of the task: RTEMS_INTERRUPT_LEVEL() with a default of RTEMS_INTERRUPT_LEVEL( 0 ) which is associated with enabled interrupts.
task,The mode mask specified in mask is built through a bitwise or of the mode mask constants described below.
task,"When the RTEMS_PREEMPT_MASK is set in mask, the preemption mode of the calling task is"
task,enabled by using the RTEMS_PREEMPT mode constant in mode_set and disabled by using the RTEMS_NO_PREEMPT mode constant in mode_set.
task,enabled by using the RTEMS_PREEMPT mode constant in mode_set and
task,disabled by using the RTEMS_NO_PREEMPT mode constant in mode_set.
task,"When the RTEMS_TIMESLICE_MASK is set in mask, the timeslicing mode of the calling task is"
task,enabled by using the RTEMS_TIMESLICE mode constant in mode_set and disabled by using the RTEMS_NO_TIMESLICE mode constant in mode_set.
task,enabled by using the RTEMS_TIMESLICE mode constant in mode_set and
task,disabled by using the RTEMS_NO_TIMESLICE mode constant in mode_set.
task,"Enabling timeslicing has no effect if preemption is disabled.  For a task to be timesliced, that task must have both preemption and timeslicing enabled."
task,"When the RTEMS_ASR_MASK is set in mask, the ASR processing mode of the calling task is"
task,enabled by using the RTEMS_ASR mode constant in mode_set and disabled by using the RTEMS_NO_ASR mode constant in mode_set.
task,enabled by using the RTEMS_ASR mode constant in mode_set and
task,disabled by using the RTEMS_NO_ASR mode constant in mode_set.
task,"When the RTEMS_INTERRUPT_MASK is set in mask, interrupts of the calling task are"
task,enabled by using the RTEMS_INTERRUPT_LEVEL() mode macro with a value of zero (0) in mode_set and disabled up to the specified level by using the RTEMS_INTERRUPT_LEVEL() mode macro with a positive value in mode_set.
task,enabled by using the RTEMS_INTERRUPT_LEVEL() mode macro with a value of zero (0) in mode_set and
task,disabled up to the specified level by using the RTEMS_INTERRUPT_LEVEL() mode macro with a positive value in mode_set.
task,An interrupt level of zero is associated with enabled interrupts on all target processors.  The interrupt level portion of the task mode supports a maximum of 256 interrupt levels.  These levels are mapped onto the interrupt levels actually supported by the target processor in a processor dependent fashion.
task,RETURN VALUES:
task,The requested operation was successful.
task,The RTEMS_NO_PREEMPT was set in mode_set and setting the preemption mode was requested by RTEMS_PREEMPT_MASK in mask and the system configuration had no implementation for this mode.
task,The RTEMS_INTERRUPT_LEVEL() was set to a positive level in mode_set and setting the interrupt level was requested by RTEMS_INTERRUPT_MASK in mask and the system configuration had no implementation for this mode.
task,CONSTRAINTS:
task,The following constraints apply to this directive:
task,"The directive may be called from within task context. When the directive enables preemption for the calling task, another task may preempt the calling task. While thread dispatching is disabled, if the directive performs a thread dispatch, then the fatal error with the fatal source INTERNAL_ERROR_CORE and the fatal code INTERNAL_ERROR_BAD_THREAD_DISPATCH_DISABLE_LEVEL will occur."
task,The directive may be called from within task context.
task,"When the directive enables preemption for the calling task, another task may preempt the calling task."
task,"While thread dispatching is disabled, if the directive performs a thread dispatch, then the fatal error with the fatal source INTERNAL_ERROR_CORE and the fatal code INTERNAL_ERROR_BAD_THREAD_DISPATCH_DISABLE_LEVEL will occur."
task,Wakes up after a count of clock ticks have occurred or yields the processor.
task,CALLING SEQUENCE:
task,PARAMETERS:
task,This parameter is the count of clock ticks to delay the task or RTEMS_YIELD_PROCESSOR to yield the processor.
task,DESCRIPTION:
task,"This directive blocks the calling task for the specified ticks count of clock ticks if the value is not equal to RTEMS_YIELD_PROCESSOR. When the requested count of ticks have occurred, the task is made ready.  The clock tick directives automatically update the delay period.  The calling task may give up the processor and remain in the ready state by specifying a value of RTEMS_YIELD_PROCESSOR in ticks."
task,RETURN VALUES:
task,The requested operation was successful.
task,NOTES:
task,Setting the system date and time with the rtems_clock_set() directive and similar directives which set CLOCK_REALTIME have no effect on a rtems_task_wake_after() blocked task.  The delay until first clock tick will never be a whole clock tick interval since this directive will never execute exactly on a clock tick.  Applications requiring use of a clock (CLOCK_REALTIME or CLOCK_MONOTONIC) instead of clock ticks should make use of clock_nanosleep().
task,CONSTRAINTS:
task,The following constraints apply to this directive:
task,"The directive may be called from within task context. The directive requires a Clock Driver. While thread dispatching is disabled, if the directive performs a thread dispatch, then the fatal error with the fatal source INTERNAL_ERROR_CORE and the fatal code INTERNAL_ERROR_BAD_THREAD_DISPATCH_DISABLE_LEVEL will occur."
task,The directive may be called from within task context.
task,The directive requires a Clock Driver.
task,"While thread dispatching is disabled, if the directive performs a thread dispatch, then the fatal error with the fatal source INTERNAL_ERROR_CORE and the fatal code INTERNAL_ERROR_BAD_THREAD_DISPATCH_DISABLE_LEVEL will occur."
task,Wakes up when specified.
task,CALLING SEQUENCE:
task,PARAMETERS:
task,This parameter is the date and time to wake up.
task,DESCRIPTION:
task,"This directive blocks a task until the date and time specified in time_buffer.  At the requested date and time, the calling task will be unblocked and made ready to execute."
task,RETURN VALUES:
task,The requested operation was successful.
task,The system date and time was not set.
task,The time_buffer parameter was NULL.
task,The time of day was invalid.
task,NOTES:
task,The ticks portion of time_buffer structure is ignored.  The timing granularity of this directive is a second.
task,CONSTRAINTS:
task,The following constraints apply to this directive:
task,"The directive may be called from within task context. The directive requires a Clock Driver. While thread dispatching is disabled, if the directive performs a thread dispatch, then the fatal error with the fatal source INTERNAL_ERROR_CORE and the fatal code INTERNAL_ERROR_BAD_THREAD_DISPATCH_DISABLE_LEVEL will occur."
task,The directive may be called from within task context.
task,The directive requires a Clock Driver.
task,"While thread dispatching is disabled, if the directive performs a thread dispatch, then the fatal error with the fatal source INTERNAL_ERROR_CORE and the fatal code INTERNAL_ERROR_BAD_THREAD_DISPATCH_DISABLE_LEVEL will occur."
task,Gets the home scheduler of the task.
task,CALLING SEQUENCE:
task,PARAMETERS:
task,This parameter is the task identifier.  The constant RTEMS_SELF may be used to specify the calling task.
task,"This parameter is the pointer to an rtems_id object.  When the directive call is successful, the identifier of the home scheduler of the task will be stored in this object."
task,DESCRIPTION:
task,This directive returns the identifier of the home scheduler of the task specified by task_id in scheduler_id.
task,RETURN VALUES:
task,The requested operation was successful.
task,The scheduler_id parameter was NULL.
task,There was no task associated with the identifier specified by task_id.
task,The task resided on a remote node.
task,CONSTRAINTS:
task,The following constraints apply to this directive:
task,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive will not cause the calling task to be preempted.
task,The directive may be called from within interrupt context.
task,The directive may be called from within device driver initialization context.
task,The directive may be called from within task context.
task,The directive will not cause the calling task to be preempted.
task,Sets the home scheduler for the task.
task,CALLING SEQUENCE:
task,PARAMETERS:
task,This parameter is the task identifier.  The constant RTEMS_SELF may be used to specify the calling task.
task,This parameter is the scheduler identifier of the new home scheduler for the task specified by task_id.
task,This parameter is the new real priority for the task with respect to the scheduler specified by scheduler_id.
task,DESCRIPTION:
task,This directive sets the home scheduler to the scheduler specified by scheduler_id for the task specified by task_id.
task,RETURN VALUES:
task,The requested operation was successful.
task,There was no scheduler associated with the identifier specified by scheduler_id.
task,The task priority specified by priority was invalid with respect to the scheduler specified by scheduler_id.
task,There was no task associated with the identifier specified by task_id.
task,The task specified by task_id was enqueued on a wait queue.
task,The task specified by task_id had a current priority which consisted of more than the real priority.
task,The task specified by task_id had a helping scheduler.
task,The task specified by task_id was pinned.
task,The scheduler specified by scheduler_id owned no processor.
task,The scheduler specified by scheduler_id did not support the affinity set of the task specified by task_id.
task,The task resided on a remote node.
task,CONSTRAINTS:
task,The following constraints apply to this directive:
task,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may change the priority of a task.  This may cause the calling task to be preempted.
task,The directive may be called from within interrupt context.
task,The directive may be called from within device driver initialization context.
task,The directive may be called from within task context.
task,The directive may change the priority of a task.  This may cause the calling task to be preempted.
task,Gets the processor affinity of the task.
task,CALLING SEQUENCE:
task,PARAMETERS:
task,This parameter is the task identifier.  The constant RTEMS_SELF may be used to specify the calling task.
task,This parameter is the size of the processor set referenced by cpuset in bytes.
task,"This parameter is the pointer to a cpu_set_t object.  When the directive call is successful, the processor affinity set of the task will be stored in this object.  A set bit in the processor set means that the corresponding processor is in the processor affinity set of the task, otherwise the bit is cleared."
task,DESCRIPTION:
task,This directive returns the processor affinity of the task in cpuset of the task specified by id.
task,RETURN VALUES:
task,The requested operation was successful.
task,The cpuset parameter was NULL.
task,There was no task associated with the identifier specified by id.
task,The size specified by cpusetsize of the processor set was too small for the processor affinity set of the task.
task,The task resided on a remote node.
task,CONSTRAINTS:
task,The following constraints apply to this directive:
task,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive will not cause the calling task to be preempted.
task,The directive may be called from within interrupt context.
task,The directive may be called from within device driver initialization context.
task,The directive may be called from within task context.
task,The directive will not cause the calling task to be preempted.
task,Sets the processor affinity of the task.
task,CALLING SEQUENCE:
task,PARAMETERS:
task,This parameter is the task identifier.  The constant RTEMS_SELF may be used to specify the calling task.
task,This parameter is the size of the processor set referenced by cpuset in bytes.
task,"This parameter is the pointer to a cpu_set_t object.  The processor set defines the new processor affinity set of the task.  A set bit in the processor set means that the corresponding processor shall be in the processor affinity set of the task, otherwise the bit shall be cleared."
task,DESCRIPTION:
task,This directive sets the processor affinity of the task specified by id.
task,RETURN VALUES:
task,The requested operation was successful.
task,The cpuset parameter was NULL.
task,There was no task associated with the identifier specified by id.
task,The referenced processor set was not a valid new processor affinity set for the task.
task,The task resided on a remote node.
task,CONSTRAINTS:
task,The following constraints apply to this directive:
task,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may change the processor affinity of a task.  This may cause the calling task to be preempted.
task,The directive may be called from within interrupt context.
task,The directive may be called from within device driver initialization context.
task,The directive may be called from within task context.
task,The directive may change the processor affinity of a task.  This may cause the calling task to be preempted.
task,Iterates over all tasks and invokes the visitor routine for each task.
task,CALLING SEQUENCE:
task,PARAMETERS:
task,This parameter is the visitor routine invoked for each task.
task,This parameter is the argument passed to each visitor routine invocation during the iteration.
task,DESCRIPTION:
task,This directive iterates over all tasks in the system.  This operation covers all tasks of all APIs.  The user should be careful in accessing the contents of the TCB.  The visitor argument arg is passed to all invocations of visitor in addition to the TCB. The iteration stops immediately in case the visitor routine returns true.
task,NOTES:
task,"The visitor routine is invoked while owning the objects allocator lock.  It is allowed to perform blocking operations in the visitor routine, however, care must be taken so that no deadlocks via the object allocator lock can occur."
task,CONSTRAINTS:
task,The following constraints apply to this directive:
task,The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
task,The directive may be called from within device driver initialization context.
task,The directive may be called from within task context.
task,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
task,Gets the recommended task storage area size for the size and task attributes.
task,CALLING SEQUENCE:
task,PARAMETERS:
task,This parameter is the size dedicated to the task stack and thread-local storage in bytes.
task,This parameter is the attribute set of the task using the storage area.
task,RETURN VALUES:
task,Returns the recommended task storage area size calculated from the input parameters.
task,"© Copyright 1988, 2024 RTEMS Project and contributors."
task,"The Task Manager provides a comprehensive set of directives to create, delete, and administer tasks. The directives provided by the Task Manager are:"
task,rtems_task_create() - Creates a task. rtems_task_construct() - Constructs a task from the specified task configuration. rtems_task_ident() - Identifies a task by the object name. rtems_task_self() - Gets the task identifier of the calling task. rtems_task_start() - Starts the task. rtems_task_restart() - Restarts the task. rtems_task_delete() - Deletes the task. rtems_task_exit() - Deletes the calling task. rtems_task_suspend() - Suspends the task. rtems_task_resume() - Resumes the task. rtems_task_is_suspended() - Checks if the task is suspended. rtems_task_set_priority() - Sets the real priority or gets the current priority of the task. rtems_task_get_priority() - Gets the current priority of the task with respect to the scheduler. rtems_task_mode() - Gets and optionally sets the mode of the calling task. rtems_task_wake_after() - Wakes up after a count of clock ticks have occurred or yields the processor. rtems_task_wake_when() - Wakes up when specified. rtems_task_get_scheduler() - Gets the home scheduler of the task. rtems_task_set_scheduler() - Sets the home scheduler for the task. rtems_task_get_affinity() - Gets the processor affinity of the task. rtems_task_set_affinity() - Sets the processor affinity of the task. rtems_task_iterate() - Iterates over all tasks and invokes the visitor routine for each task. RTEMS_TASK_STORAGE_SIZE() - Gets the recommended task storage area size for the size and task attributes.
task,rtems_task_create() - Creates a task.
task,rtems_task_construct() - Constructs a task from the specified task configuration.
task,rtems_task_ident() - Identifies a task by the object name.
task,rtems_task_self() - Gets the task identifier of the calling task.
task,rtems_task_start() - Starts the task.
task,rtems_task_restart() - Restarts the task.
task,rtems_task_delete() - Deletes the task.
task,rtems_task_exit() - Deletes the calling task.
task,rtems_task_suspend() - Suspends the task.
task,rtems_task_resume() - Resumes the task.
task,rtems_task_is_suspended() - Checks if the task is suspended.
task,rtems_task_set_priority() - Sets the real priority or gets the current priority of the task.
task,rtems_task_get_priority() - Gets the current priority of the task with respect to the scheduler.
task,rtems_task_mode() - Gets and optionally sets the mode of the calling task.
task,rtems_task_wake_after() - Wakes up after a count of clock ticks have occurred or yields the processor.
task,rtems_task_wake_when() - Wakes up when specified.
task,rtems_task_get_scheduler() - Gets the home scheduler of the task.
task,rtems_task_set_scheduler() - Sets the home scheduler for the task.
task,rtems_task_get_affinity() - Gets the processor affinity of the task.
task,rtems_task_set_affinity() - Sets the processor affinity of the task.
task,rtems_task_iterate() - Iterates over all tasks and invokes the visitor routine for each task.
task,RTEMS_TASK_STORAGE_SIZE() - Gets the recommended task storage area size for the size and task attributes.
task,"© Copyright 1988, 2024 RTEMS Project and contributors."
task,"The rtems_task_create directive creates a task by allocating a task control block, assigning the task a user-specified name, allocating it a stack and floating point context area, setting a user-specified initial priority, setting a user-specified initial mode, and assigning it a task ID.  Newly created tasks are initially placed in the dormant state.  All RTEMS tasks execute in the most privileged mode of the processor."
task,"When a task is created, RTEMS generates a unique task ID and assigns it to the created task until it is deleted.  The task ID may be obtained by either of two methods.  First, as the result of an invocation of the rtems_task_create directive, the task ID is stored in a user provided location.  Second, the task ID may be obtained later using the rtems_task_ident directive.  The task ID is used by other directives to manipulate this task."
task,"The rtems_task_start directive is used to place a dormant task in the ready state.  This enables the task to compete, based on its current priority, for the processor and other system resources.  Any actions, such as suspension or change of priority, performed on a task prior to starting it are nullified when the task is started."
task,"With the rtems_task_start directive the user specifies the task’s starting address and argument.  The argument is used to communicate some startup information to the task.  As part of this directive, RTEMS initializes the task’s stack based upon the task’s initial execution mode and start address. The starting argument is passed to the task in accordance with the target processor’s calling convention."
task,"The rtems_task_restart directive restarts a task at its initial starting address with its original priority and execution mode, but with a possibly different argument.  The new argument may be used to distinguish between the original invocation of the task and subsequent invocations.  The task’s stack and control block are modified to reflect their original creation values. Although references to resources that have been requested are cleared, resources allocated by the task are NOT automatically returned to RTEMS.  A task cannot be restarted unless it has previously been started (i.e. dormant tasks cannot be restarted).  All restarted tasks are placed in the ready state."
task,The rtems_task_suspend directive is used to place either the caller or another task into a suspended state.  The task remains suspended until a rtems_task_resume directive is issued.  This implies that a task may be suspended as well as blocked waiting either to acquire a resource or for the expiration of a timer.
task,"The rtems_task_resume directive is used to remove another task from the suspended state. If the task is not also blocked, resuming it will place it in the ready state, allowing it to once again compete for the processor and resources.  If the task was blocked as well as suspended, this directive clears the suspension and leaves the task in the blocked state."
task,Suspending a task which is already suspended or resuming a task which is not suspended is considered an error.  The rtems_task_is_suspended can be used to determine if a task is currently suspended.
task,"The rtems_task_wake_after directive creates a sleep timer which allows a task to go to sleep for a specified count of clock ticks.  The task is blocked until the count of clock ticks has elapsed, at which time the task is unblocked. A task calling the rtems_task_wake_after directive with a delay of RTEMS_YIELD_PROCESSOR ticks will yield the processor to any other ready task of equal or greater priority and remain ready to execute."
task,"The rtems_task_wake_when directive creates a sleep timer which allows a task to go to sleep until a specified date and time.  The calling task is blocked until the specified date and time has occurred, at which time the task is unblocked."
task,"The rtems_task_set_priority directive is used to obtain or change the current priority of either the calling task or another task.  If the new priority requested is RTEMS_CURRENT_PRIORITY or the task’s actual priority, then the current priority will be returned and the task’s priority will remain unchanged.  If the task’s priority is altered, then the task will be scheduled according to its new priority."
task,The rtems_task_restart directive resets the priority of a task to its original value.
task,"The rtems_task_mode directive is used to obtain or change the current execution mode of the calling task.  A task’s execution mode is used to enable preemption, timeslicing, ASR processing, and to set the task’s interrupt level."
task,The rtems_task_restart directive resets the mode of a task to its original value.
task,"RTEMS provides the rtems_task_delete directive to allow a task to delete itself or any other task.  This directive removes all RTEMS references to the task, frees the task’s control block, removes it from resource wait queues, and deallocates its stack as well as the optional floating point context.  The task’s name and ID become inactive at this time, and any subsequent references to either of them is invalid.  In fact, RTEMS may reuse the task ID for another task which is created later in the application.  A specialization of rtems_task_delete is rtems_task_exit which deletes the calling task."
task,"Unexpired delay timers (i.e. those used by rtems_task_wake_after and rtems_task_wake_when) and timeout timers associated with the task are automatically deleted, however, other resources dynamically allocated by the task are NOT automatically returned to RTEMS.  Therefore, before a task is deleted, all of its dynamically allocated resources should be deallocated by the user.  This may be accomplished by instructing the task to delete itself rather than directly deleting the task.  Other tasks may instruct a task to delete itself by sending a “delete self” message, event, or signal, or by restarting the task with special arguments which instruct the task to delete itself."
task,"On some embedded applications targeting SMP systems, it may be beneficial to lock individual tasks to specific processors.  In this way, one can designate a processor for I/O tasks, another for computation, etc..  The following illustrates the code sequence necessary to assign a task an affinity for processor with index processor_index."
task,"It is important to note that the cpuset is not validated until the rtems_task_set_affinity call is made. At that point, it is validated against the current system configuration."
task,Task notepads and the associated directives TASK_GET_NOTE - Get task notepad entry and TASK_SET_NOTE - Set task notepad entry were removed in RTEMS 5.1. These were never thread-safe to access and subject to conflicting use of the notepad index by libraries which were designed independently.
task,"It is recommended that applications be modified to use services which are thread safe and not subject to issues with multiple applications conflicting over the key (e.g. notepad index) selection. For most applications, POSIX Keys should be used. These are available in all RTEMS build configurations. It is also possible that thread-local storage (TLS) is an option for some use cases."
task,"Task notepads and the associated directives TASK_VARIABLE_ADD - Associate per task variable, TASK_VARIABLE_GET - Obtain value of a per task variable and TASK_VARIABLE_DELETE - Remove per task variable were removed in RTEMS 5.1.  Task variables must be replaced by POSIX Keys or thread-local storage (TLS).  POSIX Keys are available in all configurations and support value destructors.  For the TLS support consult the RTEMS CPU Architecture Supplement."
task,"© Copyright 1988, 2024 RTEMS Project and contributors."
timer,A clock tick is required to support the functionality provided by this manager.
timer,A timer is an RTEMS object which allows the application to schedule operations to occur at specific times in the future.  User supplied timer service routines are invoked by either a clock tick directive or a special Timer Server task when the timer fires.  Timer service routines may perform any operations or directives which normally would be performed by the application code which invoked a clock tick directive.
timer,"The timer can be used to implement watchdog routines which only fire to denote that an application error has occurred.  The timer is reset at specific points in the application to ensure that the watchdog does not fire.  Thus, if the application does not reset the watchdog timer, then the timer service routine will fire to indicate that the application has failed to reach a reset point. This use of a timer is sometimes referred to as a “keep alive” or a “deadman” timer."
timer,"The Timer Server task is responsible for executing the timer service routines associated with all task-based timers.  This task executes at a priority specified by rtems_timer_initiate_server() and it may have a priority of zero (the highest priority).  In uniprocessor configurations, it is created non-preemptible."
timer,"By providing a mechanism where timer service routines execute in task rather than interrupt space, the application is allowed a bit more flexibility in what operations a timer service routine can perform.  For example, the Timer Server can be configured to have a floating point context in which case it would be safe to perform floating point operations from a task-based timer.  Most of the time, executing floating point instructions from an interrupt service routine is not considered safe. The timer service routines invoked by the Timer Server may block, however, since this blocks the Timer Server itself, other timer service routines that are already pending do not run until the blocked timer service routine finished its work."
timer,The Timer Server is designed to remain blocked until a task-based timer fires. This reduces the execution overhead of the Timer Server.
timer,The timer service routine should adhere to C calling conventions and have a prototype similar to the following:
timer,Where the timer_id parameter is the RTEMS object ID of the timer which is being fired and user_data is a pointer to user-defined information which may be utilized by the timer service routine.  The argument user_data may be NULL.
timer,"© Copyright 1988, 2024 RTEMS Project and contributors."
timer,"This section details the directives of the Timer Manager. A subsection is dedicated to each of this manager’s directives and lists the calling sequence, parameters, description, return values, and notes of the directive."
timer,Creates a timer.
timer,CALLING SEQUENCE:
timer,PARAMETERS:
timer,This parameter is the object name of the timer.
timer,"This parameter is the pointer to an rtems_id object.  When the directive call is successful, the identifier of the created timer will be stored in this object."
timer,DESCRIPTION:
timer,This directive creates a timer which resides on the local node.  The timer has the user-defined object name specified in name.  The assigned object identifier is returned in id.  This identifier is used to access the timer with other timer related directives.
timer,RETURN VALUES:
timer,The requested operation was successful.
timer,The name parameter was invalid.
timer,The id parameter was NULL.
timer,There was no inactive object available to create a timer.  The number of timers available to the application is configured through the CONFIGURE_MAXIMUM_TIMERS application configuration option.
timer,NOTES:
timer,The processor used to maintain the timer is the processor of the calling task at some point during the timer creation.
timer,"For control and maintenance of the timer, RTEMS allocates a TMCB from the local TMCB free pool and initializes it."
timer,CONSTRAINTS:
timer,The following constraints apply to this directive:
timer,"The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted. The number of timers available to the application is configured through the CONFIGURE_MAXIMUM_TIMERS application configuration option. Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace."
timer,The directive may be called from within device driver initialization context.
timer,The directive may be called from within task context.
timer,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
timer,The number of timers available to the application is configured through the CONFIGURE_MAXIMUM_TIMERS application configuration option.
timer,"Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace."
timer,Identifies a timer by the object name.
timer,CALLING SEQUENCE:
timer,PARAMETERS:
timer,This parameter is the object name to look up.
timer,"This parameter is the pointer to an rtems_id object.  When the directive call is successful, the object identifier of an object with the specified name will be stored in this object."
timer,DESCRIPTION:
timer,This directive obtains a timer identifier associated with the timer name specified in name.
timer,RETURN VALUES:
timer,The requested operation was successful.
timer,The id parameter was NULL.
timer,The name parameter was 0.
timer,There was no object with the specified name on the local node.
timer,NOTES:
timer,"If the timer name is not unique, then the timer identifier will match the first timer with that name in the search order.  However, this timer identifier is not guaranteed to correspond to the desired timer."
timer,The objects are searched from lowest to the highest index.  Only the local node is searched.
timer,The timer identifier is used with other timer related directives to access the timer.
timer,CONSTRAINTS:
timer,The following constraints apply to this directive:
timer,The directive may be called from within any runtime context. The directive will not cause the calling task to be preempted.
timer,The directive may be called from within any runtime context.
timer,The directive will not cause the calling task to be preempted.
timer,Cancels the timer.
timer,CALLING SEQUENCE:
timer,PARAMETERS:
timer,This parameter is the timer identifier.
timer,DESCRIPTION:
timer,"This directive cancels the timer specified by id.  This timer will be reinitiated by the next invocation of rtems_timer_reset(), rtems_timer_fire_after(), rtems_timer_fire_when(), rtems_timer_server_fire_after(), or rtems_timer_server_fire_when() with the same timer identifier."
timer,RETURN VALUES:
timer,The requested operation was successful.
timer,There was no timer associated with the identifier specified by id.
timer,CONSTRAINTS:
timer,The following constraints apply to this directive:
timer,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive will not cause the calling task to be preempted.
timer,The directive may be called from within interrupt context.
timer,The directive may be called from within device driver initialization context.
timer,The directive may be called from within task context.
timer,The directive will not cause the calling task to be preempted.
timer,Deletes the timer.
timer,CALLING SEQUENCE:
timer,PARAMETERS:
timer,This parameter is the timer identifier.
timer,DESCRIPTION:
timer,"This directive deletes the timer specified by id.  If the timer is running, it is automatically canceled."
timer,RETURN VALUES:
timer,The requested operation was successful.
timer,There was no timer associated with the identifier specified by id.
timer,NOTES:
timer,The TMCB for the deleted timer is reclaimed by RTEMS.
timer,CONSTRAINTS:
timer,The following constraints apply to this directive:
timer,"The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted. The calling task does not have to be the task that created the object.  Any local task that knows the object identifier can delete the object. Where the object class corresponding to the directive is configured to use unlimited objects, the directive may free memory to the RTEMS Workspace."
timer,The directive may be called from within device driver initialization context.
timer,The directive may be called from within task context.
timer,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
timer,The calling task does not have to be the task that created the object.  Any local task that knows the object identifier can delete the object.
timer,"Where the object class corresponding to the directive is configured to use unlimited objects, the directive may free memory to the RTEMS Workspace."
timer,Fires the timer after the interval.
timer,CALLING SEQUENCE:
timer,PARAMETERS:
timer,This parameter is the timer identifier.
timer,This parameter is the interval until the routine is fired in clock ticks.
timer,This parameter is the routine to schedule.
timer,This parameter is the argument passed to the routine when it is fired.
timer,DESCRIPTION:
timer,"This directive initiates the timer specified by id.  If the timer is running, it is automatically canceled before being initiated.  The timer is scheduled to fire after an interval of clock ticks has passed specified by ticks.  When the timer fires, the timer service routine routine will be invoked with the argument user_data in the context of the clock tick ISR."
timer,RETURN VALUES:
timer,The requested operation was successful.
timer,The ticks parameter was 0.
timer,The routine parameter was NULL.
timer,There was no timer associated with the identifier specified by id.
timer,CONSTRAINTS:
timer,The following constraints apply to this directive:
timer,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive will not cause the calling task to be preempted.
timer,The directive may be called from within interrupt context.
timer,The directive may be called from within device driver initialization context.
timer,The directive may be called from within task context.
timer,The directive will not cause the calling task to be preempted.
timer,Fires the timer at the time of day.
timer,CALLING SEQUENCE:
timer,PARAMETERS:
timer,This parameter is the timer identifier.
timer,This parameter is the time of day when the routine is fired.
timer,This parameter is the routine to schedule.
timer,This parameter is the argument passed to the routine when it is fired.
timer,DESCRIPTION:
timer,"This directive initiates the timer specified by id.  If the timer is running, it is automatically canceled before being initiated.  The timer is scheduled to fire at the time of day specified by wall_time.  When the timer fires, the timer service routine routine will be invoked with the argument user_data in the context of the clock tick ISR."
timer,RETURN VALUES:
timer,The requested operation was successful.
timer,The system date and time was not set.
timer,The routine parameter was NULL.
timer,The wall_time parameter was NULL.
timer,The time of day was invalid.
timer,There was no timer associated with the identifier specified by id.
timer,CONSTRAINTS:
timer,The following constraints apply to this directive:
timer,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive will not cause the calling task to be preempted.
timer,The directive may be called from within interrupt context.
timer,The directive may be called from within device driver initialization context.
timer,The directive may be called from within task context.
timer,The directive will not cause the calling task to be preempted.
timer,Initiates the Timer Server.
timer,CALLING SEQUENCE:
timer,PARAMETERS:
timer,This parameter is the task priority.
timer,This parameter is the task stack size in bytes.
timer,This parameter is the task attribute set.
timer,DESCRIPTION:
timer,This directive initiates the Timer Server task.  This task is responsible for executing all timers initiated via the rtems_timer_server_fire_after() or rtems_timer_server_fire_when() directives.
timer,RETURN VALUES:
timer,The requested operation was successful.
timer,The Timer Server was already initiated.
timer,The task priority was invalid.
timer,There was no inactive task object available to create the Timer Server task.
timer,"There was not enough memory to allocate the task storage area.  The task storage area contains the task stack, the thread-local storage, and the floating point context."
timer,One of the task create extensions failed to create the Timer Server task.
timer,NOTES:
timer,The Timer Server task is created using the rtems_task_create() directive and must be accounted for when configuring the system.
timer,CONSTRAINTS:
timer,The following constraints apply to this directive:
timer,"The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted. The directive may be called from within device driver initialization context. The directive may be called from within task context. The number of timers available to the application is configured through the CONFIGURE_MAXIMUM_TIMERS application configuration option. Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace."
timer,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
timer,The directive may be called from within device driver initialization context.
timer,The directive may be called from within task context.
timer,The number of timers available to the application is configured through the CONFIGURE_MAXIMUM_TIMERS application configuration option.
timer,"Where the object class corresponding to the directive is configured to use unlimited objects, the directive may allocate memory from the RTEMS Workspace."
timer,Fires the timer after the interval using the Timer Server.
timer,CALLING SEQUENCE:
timer,PARAMETERS:
timer,This parameter is the timer identifier.
timer,This parameter is the interval until the routine is fired in clock ticks.
timer,This parameter is the routine to schedule.
timer,This parameter is the argument passed to the routine when it is fired.
timer,DESCRIPTION:
timer,"This directive initiates the timer specified by id.  If the timer is running, it is automatically canceled before being initiated.  The timer is scheduled to fire after an interval of clock ticks has passed specified by ticks.  When the timer fires, the timer service routine routine will be invoked with the argument user_data in the context of the Timer Server task."
timer,RETURN VALUES:
timer,The requested operation was successful.
timer,The Timer Server was not initiated.
timer,The ticks parameter was 0.
timer,The routine parameter was NULL.
timer,There was no timer associated with the identifier specified by id.
timer,CONSTRAINTS:
timer,The following constraints apply to this directive:
timer,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive will not cause the calling task to be preempted.
timer,The directive may be called from within interrupt context.
timer,The directive may be called from within device driver initialization context.
timer,The directive may be called from within task context.
timer,The directive will not cause the calling task to be preempted.
timer,Fires the timer at the time of day using the Timer Server.
timer,CALLING SEQUENCE:
timer,PARAMETERS:
timer,This parameter is the timer identifier.
timer,This parameter is the time of day when the routine is fired.
timer,This parameter is the routine to schedule.
timer,This parameter is the argument passed to the routine when it is fired.
timer,DESCRIPTION:
timer,"This directive initiates the timer specified by id.  If the timer is running, it is automatically canceled before being initiated.  The timer is scheduled to fire at the time of day specified by wall_time.  When the timer fires, the timer service routine routine will be invoked with the argument user_data in the context of the Timer Server task."
timer,RETURN VALUES:
timer,The requested operation was successful.
timer,The Timer Server was not initiated.
timer,The system date and time was not set.
timer,The routine parameter was NULL.
timer,The wall_time parameter was NULL.
timer,The time of day was invalid.
timer,There was no timer associated with the identifier specified by id.
timer,CONSTRAINTS:
timer,The following constraints apply to this directive:
timer,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive will not cause the calling task to be preempted.
timer,The directive may be called from within interrupt context.
timer,The directive may be called from within device driver initialization context.
timer,The directive may be called from within task context.
timer,The directive will not cause the calling task to be preempted.
timer,Resets the timer.
timer,CALLING SEQUENCE:
timer,PARAMETERS:
timer,This parameter is the timer identifier.
timer,DESCRIPTION:
timer,"This directive resets the timer specified by id.  This timer must have been previously initiated with either the rtems_timer_fire_after() or rtems_timer_server_fire_after() directive.  If active the timer is canceled, after which the timer is reinitiated using the same interval and timer service routine which the original rtems_timer_fire_after() or rtems_timer_server_fire_after() directive used."
timer,RETURN VALUES:
timer,The requested operation was successful.
timer,There was no timer associated with the identifier specified by id.
timer,The timer was not of the interval class.
timer,NOTES:
timer,"If the timer has not been used or the last usage of this timer was by a rtems_timer_fire_when() or rtems_timer_server_fire_when() directive, then the RTEMS_NOT_DEFINED error is returned."
timer,Restarting a cancelled after timer results in the timer being reinitiated with its previous timer service routine and interval.
timer,CONSTRAINTS:
timer,The following constraints apply to this directive:
timer,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive will not cause the calling task to be preempted.
timer,The directive may be called from within interrupt context.
timer,The directive may be called from within device driver initialization context.
timer,The directive may be called from within task context.
timer,The directive will not cause the calling task to be preempted.
timer,Gets information about the timer.
timer,CALLING SEQUENCE:
timer,PARAMETERS:
timer,This parameter is the timer identifier.
timer,"This parameter is the pointer to an rtems_timer_information object.  When the directive call is successful, the information about the timer will be stored in this object."
timer,DESCRIPTION:
timer,This directive returns information about the timer.
timer,RETURN VALUES:
timer,The requested operation was successful.
timer,The the_info parameter was NULL.
timer,There was no timer associated with the identifier specified by id.
timer,CONSTRAINTS:
timer,The following constraints apply to this directive:
timer,The directive may be called from within interrupt context. The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive will not cause the calling task to be preempted.
timer,The directive may be called from within interrupt context.
timer,The directive may be called from within device driver initialization context.
timer,The directive may be called from within task context.
timer,The directive will not cause the calling task to be preempted.
timer,"© Copyright 1988, 2024 RTEMS Project and contributors."
timer,The Timer Manager provides support for timer facilities. The directives provided by the Timer Manager are:
timer,rtems_timer_create() - Creates a timer. rtems_timer_ident() - Identifies a timer by the object name. rtems_timer_cancel() - Cancels the timer. rtems_timer_delete() - Deletes the timer. rtems_timer_fire_after() - Fires the timer after the interval. rtems_timer_fire_when() - Fires the timer at the time of day. rtems_timer_initiate_server() - Initiates the Timer Server. rtems_timer_server_fire_after() - Fires the timer after the interval using the Timer Server. rtems_timer_server_fire_when() - Fires the timer at the time of day using the Timer Server. rtems_timer_reset() - Resets the timer. rtems_timer_get_information() - Gets information about the timer.
timer,rtems_timer_create() - Creates a timer.
timer,rtems_timer_ident() - Identifies a timer by the object name.
timer,rtems_timer_cancel() - Cancels the timer.
timer,rtems_timer_delete() - Deletes the timer.
timer,rtems_timer_fire_after() - Fires the timer after the interval.
timer,rtems_timer_fire_when() - Fires the timer at the time of day.
timer,rtems_timer_initiate_server() - Initiates the Timer Server.
timer,rtems_timer_server_fire_after() - Fires the timer after the interval using the Timer Server.
timer,rtems_timer_server_fire_when() - Fires the timer at the time of day using the Timer Server.
timer,rtems_timer_reset() - Resets the timer.
timer,rtems_timer_get_information() - Gets information about the timer.
timer,"© Copyright 1988, 2024 RTEMS Project and contributors."
timer,"The rtems_timer_create directive creates a timer by allocating a Timer Control Block (TMCB), assigning the timer a user-specified name, and assigning it a timer ID.  Newly created timers do not have a timer service routine associated with them and are not active."
timer,"When a timer is created, RTEMS generates a unique timer ID and assigns it to the created timer until it is deleted.  The timer ID may be obtained by either of two methods.  First, as the result of an invocation of the rtems_timer_create directive, the timer ID is stored in a user provided location.  Second, the timer ID may be obtained later using the rtems_timer_ident directive.  The timer ID is used by other directives to manipulate this timer."
timer,"The rtems_timer_fire_after and rtems_timer_server_fire_after directives initiate a timer to fire a user provided timer service routine after the specified number of clock ticks have elapsed.  When the interval has elapsed, the timer service routine will be invoked from a clock tick directive if it was initiated by the rtems_timer_fire_after directive and from the Timer Server task if initiated by the rtems_timer_server_fire_after directive."
timer,"The rtems_timer_fire_when and rtems_timer_server_fire_when directive initiate a timer to fire a user provided timer service routine when the specified time of day has been reached.  When the interval has elapsed, the timer service routine will be invoked from a clock tick directive by the rtems_timer_fire_when directive and from the Timer Server task if initiated by the rtems_timer_server_fire_when directive."
timer,"The rtems_timer_cancel directive is used to halt the specified timer.  Once canceled, the timer service routine will not fire unless the timer is reinitiated.  The timer can be reinitiated using the rtems_timer_reset, rtems_timer_fire_after, and rtems_timer_fire_when directives."
timer,"The rtems_timer_reset directive is used to restore an interval timer initiated by a previous invocation of rtems_timer_fire_after or rtems_timer_server_fire_after to its original interval length.  If the timer has not been used or the last usage of this timer was by the rtems_timer_fire_when or rtems_timer_server_fire_when directive, then an error is returned.  The timer service routine is not changed or fired by this directive."
timer,The rtems_timer_initiate_server directive is used to allocate and start the execution of the Timer Server task.  The application can specify both the stack size and attributes of the Timer Server.  The Timer Server executes at a priority higher than any application task and thus the user can expect to be preempted as the result of executing the rtems_timer_initiate_server directive.
timer,"The rtems_timer_delete directive is used to delete a timer.  If the timer is running and has not expired, the timer is automatically canceled.  The timer’s control block is returned to the TMCB free list when it is deleted.  A timer can be deleted by a task other than the task which created the timer. Any subsequent references to the timer’s name and ID are invalid."
timer,"© Copyright 1988, 2024 RTEMS Project and contributors."
user-extensions,User extensions (call-back functions) are invoked by the system when the following events occur
user-extensions,"thread creation, thread start, thread restart, thread switch, thread begin, thread exitted (return from thread entry function), thread termination, thread deletion, and fatal error detection (system termination)."
user-extensions,"thread creation,"
user-extensions,"thread start,"
user-extensions,"thread restart,"
user-extensions,"thread switch,"
user-extensions,"thread begin,"
user-extensions,"thread exitted (return from thread entry function),"
user-extensions,"thread termination,"
user-extensions,"thread deletion, and"
user-extensions,fatal error detection (system termination).
user-extensions,"The user extensions have event-specific arguments, invocation orders and execution contexts.  Extension sets can be installed at run-time via rtems_extension_create() (dynamic extension sets) or at link-time via the application configuration option CONFIGURE_INITIAL_EXTENSIONS (initial extension sets)."
user-extensions,The execution context of user extensions varies.  Some user extensions are invoked with ownership of the allocator mutex.  The allocator mutex protects dynamic memory allocations and object creation/deletion.  Some user extensions are invoked with thread dispatching disabled.  The fatal error extension is invoked in an arbitrary context.
user-extensions,User extensions are maintained as a set.  All user extensions are optional and may be NULL.  Together a set of these user extensions typically performs a specific functionality such as performance monitoring or debugger support.  The extension set is defined via the following structure.
user-extensions,There is no system-provided storage for the initial extension sets.
user-extensions,The task control block (TCB) contains a pointer for each dynamic extension set. The pointer is initialized to NULL during thread initialization before the thread create extension is invoked.  The pointer may be used by the dynamic extension set to maintain thread-specific data.
user-extensions,The TCB extension is an array of pointers in the TCB. The index into the table can be obtained from the extension identifier returned when the extension object is created:
user-extensions,"The number of pointers in the area is the same as the number of dynamic user extension sets configured.  This allows an application to augment the TCB with user-defined information.  For example, an application could implement task profiling by storing timing statistics in the TCB’s extended memory area.  When a task context switch is being executed, the thread switch extension could read a real-time clock to calculate how long the task being swapped out has run as well as timestamp the starting time for the task being swapped in."
user-extensions,"If used, the extended memory area for the TCB should be allocated and the TCB extension pointer should be set at the time the task is created or started by either the thread create or thread start extension.  The application is responsible for managing this extended memory area for the TCBs.  The memory may be reinitialized by the thread restart extension and should be deallocated by the thread delete extension  when the task is deleted.  Since the TCB extension buffers would most likely be of a fixed size, the RTEMS partition manager could be used to manage the application’s extended memory area.  The application could create a partition of fixed size TCB extension buffers and use the partition manager’s allocation and deallocation directives to obtain and release the extension buffers."
user-extensions,"The user extensions are invoked in either extension forward order or extension reverse order.  By invoking the user extensions in these orders, extensions can be built upon one another.  At the following system events, the user extensions are invoked in forward order"
user-extensions,"thread creation, thread start, thread restart, thread switch, thread begin, thread exitted (return from thread entry function), and fatal error detection."
user-extensions,"thread creation,"
user-extensions,"thread start,"
user-extensions,"thread restart,"
user-extensions,"thread switch,"
user-extensions,"thread begin,"
user-extensions,"thread exitted (return from thread entry function), and"
user-extensions,fatal error detection.
user-extensions,"At the following system events, the user extensions are invoked in reverse order:"
user-extensions,"thread termination, and thread deletion."
user-extensions,"thread termination, and"
user-extensions,thread deletion.
user-extensions,"At these system events, the user extensions are invoked in reverse order to insure that if an extension set is built upon another, the more complicated user extension is invoked before the user extension it is built upon.  An example is use of the thread delete extension by the Standard C Library.  Extension sets which are installed after the Standard C Library will operate correctly even if they utilize the C Library because the C Library’s thread delete extension is invoked after that of the other thread delete extensions."
user-extensions,"The thread create extension is invoked during thread creation, for example via rtems_task_create() or pthread_create(). The thread create extension is defined as follows."
user-extensions,The executing is a pointer to the TCB of the currently executing thread.  The created is a pointer to the TCB of the created thread. The created thread is completely initialized with respect to the operating system.
user-extensions,The executing thread is the owner of the allocator mutex except during creation of the idle threads.  Since the allocator mutex allows nesting the normal memory allocation routines can be used.
user-extensions,"A thread create extension will frequently attempt to allocate resources.  If this allocation fails, then the thread create extension must return false and the entire thread create operation will fail, otherwise it must return true."
user-extensions,The thread create extension is invoked in forward order with thread dispatching enabled (except during system initialization).
user-extensions,"The thread start extension is invoked during a thread start, for example via rtems_task_start() or pthread_create(). The thread start extension is defined as follows."
user-extensions,"The executing is a pointer to the TCB of the currently executing thread.  The started is a pointer to the TCB of the started thread. It is invoked after the environment of the started thread has been loaded and the started thread has been made ready.  So, in SMP configurations, the thread may already run on another processor before the thread start extension is actually invoked.  Thread switch and thread begin extensions may run before or in parallel with the thread start extension in SMP configurations."
user-extensions,The thread start extension is invoked in forward order with thread dispatching disabled.
user-extensions,"The thread restart extension is invoked during a thread restart, for example via rtems_task_restart(). The thread restart extension is defined as follows."
user-extensions,Both executing and restarted are pointers the TCB of the currently executing thread.  It is invoked in the context of the executing thread right before the execution context is reloaded.  The thread stack reflects the previous execution context.
user-extensions,"The thread restart extension is invoked in forward order with thread dispatching enabled (except during system initialization).  The thread life is protected.  Thread restart and delete requests issued by thread restart extensions lead to recursion.  The POSIX cleanup handlers, POSIX key destructors and thread-local object destructors run in this context."
user-extensions,The thread switch extension is defined as follows.
user-extensions,The invocation conditions of the thread switch extension depend on whether RTEMS was configured for uniprocessor or SMP systems.  A user must pay attention to the differences to correctly implement a thread switch extension.
user-extensions,"In uniprocessor configurations, the thread switch extension is invoked before the context switch from the currently executing thread to the heir thread.  The executing is a pointer to the TCB of the currently executing thread. The heir is a pointer to the TCB of the heir thread.  The context switch initiated through the multitasking start is not covered by the thread switch extension."
user-extensions,"In SMP configurations, the thread switch extension is invoked after the context switch to the new executing thread (previous heir thread).  The executing is a pointer to the TCB of the previously executing thread. Despite the name, this is not the currently executing thread.  The heir is a pointer to the TCB of the newly executing thread.  This is the currently executing thread.  The context switches initiated through the multitasking start are covered by the thread switch extension.  The reason for the differences to uniprocessor configurations is that the context switch may update the heir thread of the processor, see Thread Dispatch Details. The thread switch extensions are invoked with disabled interrupts and with ownership of a per-processor SMP lock.  Thread switch extensions may run in parallel on multiple processors.  It is recommended to use thread-local or per-processor data structures for thread switch extensions.  A global SMP lock should be avoided for performance reasons."
user-extensions,The thread switch extension is invoked in forward order with thread dispatching disabled.
user-extensions,The thread begin extension is invoked during a thread begin before the thread entry function is called.  The thread begin extension is defined as follows.
user-extensions,"The executing is a pointer to the TCB of the currently executing thread.  The thread begin extension executes in a normal thread context and may allocate resources for the executing thread.  In particular, it has access to thread-local storage of the executing thread."
user-extensions,The thread begin extension is invoked in forward order with thread dispatching enabled.  The thread switch extension may be called multiple times for this thread before or during the thread begin extension is invoked.
user-extensions,The thread exitted extension is invoked once the thread entry function returns. The thread exitted extension is defined as follows.
user-extensions,The executing is a pointer to the TCB of the currently executing thread.
user-extensions,This extension is invoked in forward order with thread dispatching enabled.
user-extensions,"The thread termination extension is invoked in case a termination request is recognized by the currently executing thread.  Termination requests may result due to calls of rtems_task_delete(), pthread_exit(), or pthread_cancel().  The thread termination extension is defined as follows."
user-extensions,The executing is a pointer to the TCB of the currently executing thread.
user-extensions,"It is invoked in the context of the terminated thread right before the thread dispatch to the heir thread.  The POSIX cleanup handlers, POSIX key destructors and thread-local object destructors run in this context.  Depending on the order, the thread termination extension has access to thread-local storage and thread-specific data of POSIX keys."
user-extensions,The thread terminate extension is invoked in reverse order with thread dispatching enabled.  The thread life is protected.  Thread restart and delete requests issued by thread terminate extensions lead to recursion.
user-extensions,The thread delete extension is invoked in case a zombie thread is killed.  A thread becomes a zombie thread after it terminated.  The thread delete extension is defined as follows.
user-extensions,The executing is a pointer to the TCB of the currently executing thread.  The deleted is a pointer to the TCB of the deleted thread. The executing and deleted pointers are never equal.
user-extensions,The executing thread is the owner of the allocator mutex.  Since the allocator mutex allows nesting the normal memory allocation routines can be used.
user-extensions,The thread delete extension is invoked in reverse order with thread dispatching enabled.
user-extensions,Please note that a thread delete extension is not immediately invoked with a call to rtems_task_delete() or similar.  The thread must first terminate and this may take some time.  The thread delete extension is invoked by rtems_task_create() or similar as a result of a lazy garbage collection of zombie threads.
user-extensions,The fatal error extension is invoked during system termination.  The fatal error extension is defined as follows.
user-extensions,The source parameter is the fatal source indicating the subsystem the fatal condition originated in.  The always_set_to_false parameter is always set to false and provided only for backward compatibility reasons.  The code parameter is the fatal error code.  This value must be interpreted with respect to the source.
user-extensions,The fatal error extension is invoked in forward order.
user-extensions,"It is strongly advised to use initial extension sets to install a fatal error extension.  Usually, the initial extension set of board support package provides a fatal error extension which resets the board.  In this case, the dynamic fatal error extensions are not invoked."
user-extensions,"© Copyright 1988, 2024 RTEMS Project and contributors."
user-extensions,"This section details the directives of the User Extensions Manager. A subsection is dedicated to each of this manager’s directives and lists the calling sequence, parameters, description, return values, and notes of the directive."
user-extensions,Creates an extension set.
user-extensions,CALLING SEQUENCE:
user-extensions,PARAMETERS:
user-extensions,This parameter is the object name of the extension set.
user-extensions,This parameter is the table with the extensions to be used by the extension set.
user-extensions,"This parameter is the pointer to an rtems_id object.  When the directive call is successful, the identifier of the created extension set will be stored in this object."
user-extensions,DESCRIPTION:
user-extensions,This directive creates an extension set which resides on the local node.  The extension set has the user-defined object name specified in name.  The assigned object identifier is returned in id.  This identifier is used to access the extension set with other extension set related directives.
user-extensions,The extension set is initialized using the extension table specified in extension_table.
user-extensions,RETURN VALUES:
user-extensions,The requested operation was successful.
user-extensions,The name parameter was invalid.
user-extensions,The extension_table parameter was NULL.
user-extensions,The id parameter was NULL.
user-extensions,There was no inactive object available to create an extension set.  The number of extension sets available to the application is configured through the CONFIGURE_MAXIMUM_USER_EXTENSIONS application configuration option.
user-extensions,NOTES:
user-extensions,The user-provided extension table is not used after the return of the directive.
user-extensions,Each extension of the extension table is optional and may be NULL.  All extensions except the task switch extension of the extension table are atomically and immediately installed.  A task switch extension is separately installed after the other extensions.  The extensions of the extension table are invoked upon the next system event supporting an extension.
user-extensions,"An alternative to dynamically created extension sets are initial extensions, see CONFIGURE_INITIAL_EXTENSIONS.  Initial extensions are recommended for extension sets which provide a fatal error extension."
user-extensions,"For control and maintenance of the extension set, RTEMS allocates a ESCB from the local ESCB free pool and initializes it."
user-extensions,CONSTRAINTS:
user-extensions,The following constraints apply to this directive:
user-extensions,The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted. The number of extension sets available to the application is configured through the CONFIGURE_MAXIMUM_USER_EXTENSIONS application configuration option.
user-extensions,The directive may be called from within device driver initialization context.
user-extensions,The directive may be called from within task context.
user-extensions,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
user-extensions,The number of extension sets available to the application is configured through the CONFIGURE_MAXIMUM_USER_EXTENSIONS application configuration option.
user-extensions,Deletes the extension set.
user-extensions,CALLING SEQUENCE:
user-extensions,PARAMETERS:
user-extensions,This parameter is the extension set identifier.
user-extensions,DESCRIPTION:
user-extensions,This directive deletes the extension set specified by id.
user-extensions,RETURN VALUES:
user-extensions,The requested operation was successful.
user-extensions,There was no extension set associated with the identifier specified by id.
user-extensions,NOTES:
user-extensions,The ESCB for the deleted extension set is reclaimed by RTEMS.
user-extensions,CONSTRAINTS:
user-extensions,The following constraints apply to this directive:
user-extensions,The directive may be called from within device driver initialization context. The directive may be called from within task context. The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted. The calling task does not have to be the task that created the object.  Any local task that knows the object identifier can delete the object.
user-extensions,The directive may be called from within device driver initialization context.
user-extensions,The directive may be called from within task context.
user-extensions,The directive may obtain and release the object allocator mutex.  This may cause the calling task to be preempted.
user-extensions,The calling task does not have to be the task that created the object.  Any local task that knows the object identifier can delete the object.
user-extensions,Identifies an extension set by the object name.
user-extensions,CALLING SEQUENCE:
user-extensions,PARAMETERS:
user-extensions,This parameter is the object name to look up.
user-extensions,"This parameter is the pointer to an rtems_id object.  When the directive call is successful, the object identifier of an object with the specified name will be stored in this object."
user-extensions,DESCRIPTION:
user-extensions,This directive obtains an extension set identifier associated with the extension set name specified in name.
user-extensions,RETURN VALUES:
user-extensions,The requested operation was successful.
user-extensions,The id parameter was NULL.
user-extensions,The name parameter was 0.
user-extensions,There was no object with the specified name on the local node.
user-extensions,NOTES:
user-extensions,"If the extension set name is not unique, then the extension set identifier will match the first extension set with that name in the search order. However, this extension set identifier is not guaranteed to correspond to the desired extension set."
user-extensions,The objects are searched from lowest to the highest index.  Only the local node is searched.
user-extensions,The extension set identifier is used with other extension related directives to access the extension set.
user-extensions,CONSTRAINTS:
user-extensions,The following constraints apply to this directive:
user-extensions,The directive may be called from within device driver initialization context. The directive will not cause the calling task to be preempted.
user-extensions,The directive may be called from within device driver initialization context.
user-extensions,The directive will not cause the calling task to be preempted.
user-extensions,"© Copyright 1988, 2024 RTEMS Project and contributors."
user-extensions,The User Extensions Manager allows the application developer to augment the executive by allowing them to supply extension routines which are invoked at critical system events. The directives provided by the User Extensions Manager are:
user-extensions,rtems_extension_create() - Creates an extension set. rtems_extension_delete() - Deletes the extension set. rtems_extension_ident() - Identifies an extension set by the object name.
user-extensions,rtems_extension_create() - Creates an extension set.
user-extensions,rtems_extension_delete() - Deletes the extension set.
user-extensions,rtems_extension_ident() - Identifies an extension set by the object name.
user-extensions,"© Copyright 1988, 2024 RTEMS Project and contributors."
