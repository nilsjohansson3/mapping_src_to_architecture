Module,Text
barrier,"A barrier can be viewed as a gate at which tasks wait until the gate is opened. This has many analogies in the real world.  Horses and other farm animals may approach a closed gate and gather in front of it, waiting for someone to open the gate so they may proceed.  Similarly, ticket holders gather at the gates of arenas before concerts or sporting events waiting for the arena personnel to open the gates so they may enter."
barrier,"Barriers are useful during application initialization.  Each application task can perform its local initialization before waiting for the application as a whole to be initialized.  Once all tasks have completed their independent initializations, the “application ready” barrier can be released."
barrier,"Just as with a real-world gate, barriers may be configured to be manually opened or automatically opened.  All tasks calling the rtems_barrier_wait directive will block until a controlling task invokes the rtems_barrier_release directive."
barrier,"Automatic barriers are created with a limit to the number of tasks which may simultaneously block at the barrier.  Once this limit is reached, all of the tasks are released.  For example, if the automatic limit is ten tasks, then the first nine tasks calling the rtems_barrier_wait directive will block.  When the tenth task calls the rtems_barrier_wait directive, the nine blocked tasks will be released and the tenth task returns to the caller without blocking."
barrier,"In general, an attribute set is built by a bitwise OR of the desired attribute components.  The following table lists the set of valid barrier attributes:"
barrier,automatically release the barrier when the configured number of tasks are blocked
barrier,only release the barrier when the application invokes the rtems_barrier_release directive.  (default)
barrier,Note
barrier,Barriers only support FIFO blocking order because all waiting tasks are released as a set.  Thus the released tasks will all become ready to execute at the same time and compete for the processor based upon their priority.
barrier,"Attribute values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each attribute appears exactly once in the component list.  An attribute listed as a default is not required to appear in the attribute list, although it is a good programming practice to specify default attributes.  If all defaults are desired, the attribute RTEMS_DEFAULT_ATTRIBUTES should be specified on this call."
barrier,"This example demonstrates the attribute_set parameter needed to create a barrier with the automatic release policy.  The attribute_set parameter passed to the rtems_barrier_create directive will be RTEMS_BARRIER_AUTOMATIC_RELEASE.  In this case, the user must also specify the maximum_waiters parameter."
barrier,"© Copyright 1988, 2024 RTEMS Project and contributors."
barrier,The Barrier Manager provides a unique synchronization capability which can be used to have a set of tasks block and be unblocked as a set. The directives provided by the Barrier Manager are:
barrier,rtems_barrier_create() - Creates a barrier. rtems_barrier_ident() - Identifies a barrier by the object name. rtems_barrier_delete() - Deletes the barrier. rtems_barrier_wait() - Waits at the barrier. rtems_barrier_release() - Releases the barrier.
barrier,rtems_barrier_create() - Creates a barrier.
barrier,rtems_barrier_ident() - Identifies a barrier by the object name.
barrier,rtems_barrier_delete() - Deletes the barrier.
barrier,rtems_barrier_wait() - Waits at the barrier.
barrier,rtems_barrier_release() - Releases the barrier.
barrier,"© Copyright 1988, 2024 RTEMS Project and contributors."
cache,The Cache Manager provides functions to perform maintenance operations for data and instruction caches.
cache,The actual actions of the Cache Manager operations depend on the hardware and the implementation provided by the CPU architecture port or a board support package.  Cache implementations tend to be highly hardware dependent. The directives provided by the Cache Manager are:
cache,"rtems_cache_flush_multiple_data_lines() - Flushes the data cache lines covering the memory area. rtems_cache_invalidate_multiple_data_lines() - Invalidates the data cache lines covering the memory area. rtems_cache_invalidate_multiple_instruction_lines() - Invalidates the instruction cache lines covering the memory area. rtems_cache_instruction_sync_after_code_change() - Ensures necessary synchronization required after code changes. rtems_cache_get_maximal_line_size() - Gets the maximal cache line size in bytes of all caches (data, instruction, or unified). rtems_cache_get_data_line_size() - Gets the data cache line size in bytes. rtems_cache_get_instruction_line_size() - Gets the instruction cache line size in bytes. rtems_cache_get_data_cache_size() - Gets the data cache size in bytes for the cache level. rtems_cache_get_instruction_cache_size() - Gets the instruction cache size in bytes for the cache level. rtems_cache_flush_entire_data() - Flushes the entire data cache. rtems_cache_invalidate_entire_data() - Invalidates the entire data cache. rtems_cache_invalidate_entire_instruction() - Invalidates the entire instruction cache. rtems_cache_enable_data() - Enables the data cache. rtems_cache_disable_data() - Disables the data cache. rtems_cache_enable_instruction() - Enables the instruction cache. rtems_cache_disable_instruction() - Disables the instruction cache. rtems_cache_aligned_malloc() - Allocates memory from the C Program Heap which begins at a cache line boundary."
cache,rtems_cache_flush_multiple_data_lines() - Flushes the data cache lines covering the memory area.
cache,rtems_cache_invalidate_multiple_data_lines() - Invalidates the data cache lines covering the memory area.
cache,rtems_cache_invalidate_multiple_instruction_lines() - Invalidates the instruction cache lines covering the memory area.
cache,rtems_cache_instruction_sync_after_code_change() - Ensures necessary synchronization required after code changes.
cache,"rtems_cache_get_maximal_line_size() - Gets the maximal cache line size in bytes of all caches (data, instruction, or unified)."
cache,rtems_cache_get_data_line_size() - Gets the data cache line size in bytes.
cache,rtems_cache_get_instruction_line_size() - Gets the instruction cache line size in bytes.
cache,rtems_cache_get_data_cache_size() - Gets the data cache size in bytes for the cache level.
cache,rtems_cache_get_instruction_cache_size() - Gets the instruction cache size in bytes for the cache level.
cache,rtems_cache_flush_entire_data() - Flushes the entire data cache.
cache,rtems_cache_invalidate_entire_data() - Invalidates the entire data cache.
cache,rtems_cache_invalidate_entire_instruction() - Invalidates the entire instruction cache.
cache,rtems_cache_enable_data() - Enables the data cache.
cache,rtems_cache_disable_data() - Disables the data cache.
cache,rtems_cache_enable_instruction() - Enables the instruction cache.
cache,rtems_cache_disable_instruction() - Disables the instruction cache.
cache,rtems_cache_aligned_malloc() - Allocates memory from the C Program Heap which begins at a cache line boundary.
cache,"© Copyright 1988, 2024 RTEMS Project and contributors."
clock,"For the features provided by the Clock Manager to be utilized, a Clock Driver is required.  The Clock Driver usually provides a clock interrupt which is serviced on each configured processor at each clock tick.  In addition, the Clock Driver provides three clock sources:"
clock,clock tick CLOCK_REALTIME CLOCK_MONOTONIC
clock,clock tick
clock,CLOCK_REALTIME
clock,CLOCK_MONOTONIC
clock,"The time of these clock sources advances at each clock tick.  This yields the time of the clock sources in a coarse resolution.  To get the time of the CLOCK_REALTIME or CLOCK_MONOTONIC clock sources in a higher resolution, the Clock Driver may use a clock device to get the time between clock ticks."
clock,The clock facilities of the Clock Manager operate upon calendar time.  These directives utilize the following date and time structure for the native time and date format:
clock,"The native date and time format is the only format supported when setting the system date and time using the rtems_clock_set() directive.  Some applications expect to operate on a UNIX-style date and time data structure. For example, the rtems_clock_get_tod_timeval() returns the date and time in struct timeval format."
clock,"Some directives use data structures defined by POSIX.  The struct timeval data structure has two members: tv_sec and tv_usec which are seconds and microseconds, respectively.  The struct timespec data structure has two members: tv_sec and tv_nsec which are seconds and nanoseconds, respectively.  For CLOCK_REALTIME time points, the tv_sec member in these data structures is the number of seconds since the Unix epoch but will never be prior to the RTEMS epoch."
clock,"The struct bintime and sbintime_t time formats used by some directives originate in FreeBSD.  The struct bintime data structure which represents time in a binary time format has two members: sec and frac which are seconds and fractions of a second in units of \(1 / 2^{64}\) seconds, respectively.  The sbintime_t type is a signed 64-bit integer type used to represent time in units of \(1 / 2^{32}\) seconds."
clock,Timeslicing is a task scheduling discipline in which tasks of equal priority are executed for a specific period of time before control of the CPU is passed to another task.  It is also sometimes referred to as the automatic round-robin scheduling algorithm.  The length of time allocated to each task is known as the quantum or timeslice.
clock,"The system’s timeslice is defined as an integral number of ticks, and is specified by the CONFIGURE_TICKS_PER_TIMESLICE application configuration option.  The timeslice is defined for the entire system of tasks, but timeslicing is enabled and disabled on a per task basis."
clock,"The clock tick directives implement timeslicing by decrementing the running task’s time-remaining counter when both timeslicing and preemption are enabled.  If the task’s timeslice has expired, then that task will be preempted if there exists a ready task of equal priority."
clock,"A sleep timer allows a task to delay for a given interval or up until a given time, and then wake and continue execution.  This type of timer is created automatically by the rtems_task_wake_after() and rtems_task_wake_when() directives and, as a result, does not have an object identifier.  Once activated, a sleep timer cannot be explicitly deleted. Each task may activate one and only one sleep timer at a time."
clock,"Timeouts are a special type of timer automatically created when the timeout option is used on the rtems_barrier_wait(), rtems_event_receive(), rtems_message_queue_receive(), rtems_region_get_segment(), and rtems_semaphore_obtain() directives.  Each task may have one and only one timeout active at a time. When a timeout expires, it unblocks the task with a timeout status code."
clock,"© Copyright 1988, 2024 RTEMS Project and contributors."
clock,The Clock Manager provides support for time of day and other time related capabilities. The directives provided by the Clock Manager are:
clock,rtems_clock_set() - Sets the CLOCK_REALTIME to the time of day. rtems_clock_get_tod() - Gets the time of day associated with the current CLOCK_REALTIME. rtems_clock_get_tod_timeval() - Gets the seconds and microseconds elapsed since the Unix epoch and the current CLOCK_REALTIME. rtems_clock_get_realtime() - Gets the time elapsed since the Unix epoch measured using CLOCK_REALTIME in seconds and nanoseconds format. rtems_clock_get_realtime_bintime() - Gets the time elapsed since the Unix epoch measured using CLOCK_REALTIME in binary time format. rtems_clock_get_realtime_timeval() - Gets the time elapsed since the Unix epoch measured using CLOCK_REALTIME in seconds and microseconds format. rtems_clock_get_realtime_coarse() - Gets the time elapsed since the Unix epoch measured using CLOCK_REALTIME in coarse resolution in seconds and nanoseconds format. rtems_clock_get_realtime_coarse_bintime() - Gets the time elapsed since the Unix epoch measured using CLOCK_REALTIME in coarse resolution in binary time format. rtems_clock_get_realtime_coarse_timeval() - Gets the time elapsed since the Unix epoch measured using CLOCK_REALTIME in coarse resolution in seconds and microseconds format. rtems_clock_get_monotonic() - Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in seconds and nanoseconds format. rtems_clock_get_monotonic_bintime() - Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in binary time format. rtems_clock_get_monotonic_sbintime() - Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in signed binary time format. rtems_clock_get_monotonic_timeval() - Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in seconds and microseconds format. rtems_clock_get_monotonic_coarse() - Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in coarse resolution in seconds and nanoseconds format. rtems_clock_get_monotonic_coarse_bintime() - Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in coarse resolution in binary time format. rtems_clock_get_monotonic_coarse_timeval() - Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in coarse resolution in seconds and microseconds format. rtems_clock_get_boot_time() - Gets the time elapsed since the Unix epoch at some time point during system initialization in seconds and nanoseconds format. rtems_clock_get_boot_time_bintime() - Gets the time elapsed since the Unix epoch at some time point during system initialization in binary time format. rtems_clock_get_boot_time_timeval() - Gets the time elapsed since the Unix epoch at some time point during system initialization in seconds and microseconds format. rtems_clock_get_seconds_since_epoch() - Gets the seconds elapsed since the RTEMS epoch and the current CLOCK_REALTIME. rtems_clock_get_ticks_per_second() - Gets the number of clock ticks per second configured for the application. rtems_clock_get_ticks_since_boot() - Gets the number of clock ticks since some time point during the system initialization or the last overflow of the clock tick counter. rtems_clock_get_uptime() - Gets the seconds and nanoseconds elapsed since some time point during the system initialization using CLOCK_MONOTONIC. rtems_clock_get_uptime_timeval() - Gets the seconds and microseconds elapsed since some time point during the system initialization using CLOCK_MONOTONIC. rtems_clock_get_uptime_seconds() - Gets the seconds elapsed since some time point during the system initialization using CLOCK_MONOTONIC. rtems_clock_get_uptime_nanoseconds() - Gets the nanoseconds elapsed since some time point during the system initialization using CLOCK_MONOTONIC. rtems_clock_tick_later() - Gets a clock tick value which is at least delta clock ticks in the future. rtems_clock_tick_later_usec() - Gets a clock tick value which is at least delta microseconds in the future. rtems_clock_tick_before() - Indicates if the current clock tick counter is before the ticks.
clock,rtems_clock_set() - Sets the CLOCK_REALTIME to the time of day.
clock,rtems_clock_get_tod() - Gets the time of day associated with the current CLOCK_REALTIME.
clock,rtems_clock_get_tod_timeval() - Gets the seconds and microseconds elapsed since the Unix epoch and the current CLOCK_REALTIME.
clock,rtems_clock_get_realtime() - Gets the time elapsed since the Unix epoch measured using CLOCK_REALTIME in seconds and nanoseconds format.
clock,rtems_clock_get_realtime_bintime() - Gets the time elapsed since the Unix epoch measured using CLOCK_REALTIME in binary time format.
clock,rtems_clock_get_realtime_timeval() - Gets the time elapsed since the Unix epoch measured using CLOCK_REALTIME in seconds and microseconds format.
clock,rtems_clock_get_realtime_coarse() - Gets the time elapsed since the Unix epoch measured using CLOCK_REALTIME in coarse resolution in seconds and nanoseconds format.
clock,rtems_clock_get_realtime_coarse_bintime() - Gets the time elapsed since the Unix epoch measured using CLOCK_REALTIME in coarse resolution in binary time format.
clock,rtems_clock_get_realtime_coarse_timeval() - Gets the time elapsed since the Unix epoch measured using CLOCK_REALTIME in coarse resolution in seconds and microseconds format.
clock,rtems_clock_get_monotonic() - Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in seconds and nanoseconds format.
clock,rtems_clock_get_monotonic_bintime() - Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in binary time format.
clock,rtems_clock_get_monotonic_sbintime() - Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in signed binary time format.
clock,rtems_clock_get_monotonic_timeval() - Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in seconds and microseconds format.
clock,rtems_clock_get_monotonic_coarse() - Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in coarse resolution in seconds and nanoseconds format.
clock,rtems_clock_get_monotonic_coarse_bintime() - Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in coarse resolution in binary time format.
clock,rtems_clock_get_monotonic_coarse_timeval() - Gets the time elapsed since some fixed time point in the past measured using the CLOCK_MONOTONIC in coarse resolution in seconds and microseconds format.
clock,rtems_clock_get_boot_time() - Gets the time elapsed since the Unix epoch at some time point during system initialization in seconds and nanoseconds format.
clock,rtems_clock_get_boot_time_bintime() - Gets the time elapsed since the Unix epoch at some time point during system initialization in binary time format.
clock,rtems_clock_get_boot_time_timeval() - Gets the time elapsed since the Unix epoch at some time point during system initialization in seconds and microseconds format.
clock,rtems_clock_get_seconds_since_epoch() - Gets the seconds elapsed since the RTEMS epoch and the current CLOCK_REALTIME.
clock,rtems_clock_get_ticks_per_second() - Gets the number of clock ticks per second configured for the application.
clock,rtems_clock_get_ticks_since_boot() - Gets the number of clock ticks since some time point during the system initialization or the last overflow of the clock tick counter.
clock,rtems_clock_get_uptime() - Gets the seconds and nanoseconds elapsed since some time point during the system initialization using CLOCK_MONOTONIC.
clock,rtems_clock_get_uptime_timeval() - Gets the seconds and microseconds elapsed since some time point during the system initialization using CLOCK_MONOTONIC.
clock,rtems_clock_get_uptime_seconds() - Gets the seconds elapsed since some time point during the system initialization using CLOCK_MONOTONIC.
clock,rtems_clock_get_uptime_nanoseconds() - Gets the nanoseconds elapsed since some time point during the system initialization using CLOCK_MONOTONIC.
clock,rtems_clock_tick_later() - Gets a clock tick value which is at least delta clock ticks in the future.
clock,rtems_clock_tick_later_usec() - Gets a clock tick value which is at least delta microseconds in the future.
clock,rtems_clock_tick_before() - Indicates if the current clock tick counter is before the ticks.
clock,"© Copyright 1988, 2024 RTEMS Project and contributors."
clock,"RTEMS provides the several clock tick directives which are called from the user’s real-time clock ISR to inform RTEMS that a tick has elapsed.  Depending on the timer hardware capabilities the clock driver must choose the most appropriate clock tick directive.  The tick frequency value, defined in microseconds, is a configuration parameter found in the Configuration Table. RTEMS divides one million microseconds (one second) by the number of microseconds per tick to determine the number of calls to the clock tick directive per second.  The frequency of clock tick calls determines the resolution (granularity) for all time dependent RTEMS actions.  For example, calling the clock tick directive ten times per second yields a higher resolution than calling the clock tick two times per second.  The clock tick directives are responsible for maintaining both calendar time and the dynamic set of timers."
clock,"The rtems_clock_set directive allows a task or an ISR to set the date and time maintained by RTEMS.  If setting the date and time causes any outstanding timers to pass their deadline, then the expired timers will be fired during the invocation of the rtems_clock_set directive."
clock,"RTEMS provides multiple directives which can be used by an application to obtain the current date and time or date and time related information.  These directives allow a task or an ISR to obtain the current date and time or date and time related information.  The current date and time can be returned in either native or UNIX-style format.  Additionally, the application can obtain date and time related information such as the number of seconds since the RTEMS epoch, the number of ticks since the executive was initialized, and the number of ticks per second.  The following directives are available:"
clock,obtain native style date and time
clock,obtain UNIX-style date and time
clock,obtain number of ticks since RTEMS was initialized
clock,obtain number of seconds since RTEMS epoch
clock,obtain number of clock ticks per second
clock,Calendar time operations will return an error code if invoked before the date and time have been set.
clock,The directive CLOCK_GET - Get date and time information took an untyped pointer with an options argument to indicate the time information desired. This has been replaced with a set of typed directives:
clock,rtems_clock_get_seconds_since_epoch rtems_clock_get_ticks_per_second rtems_clock_get_ticks_since_boot rtems_clock_get_tod rtems_clock_get_tod_timeval
clock,rtems_clock_get_seconds_since_epoch
clock,rtems_clock_get_ticks_per_second
clock,rtems_clock_get_ticks_since_boot
clock,rtems_clock_get_tod
clock,rtems_clock_get_tod_timeval
clock,These directives directly correspond to what were previously referred to as clock options.  These strongly typed directives were available for multiple releases in parallel with rtems_clock_get() until that directive was removed.
clock,"© Copyright 1988, 2024 RTEMS Project and contributors."
config,The application configuration information group provides an API to get the configuration of an application.
config,"RTEMS must be configured for an application.  This configuration encompasses a variety of information including the length of each clock tick, the maximum number of each information RTEMS object that can be created, the application initialization tasks, the task scheduling algorithm to be used, and the device drivers in the application."
config,"Although this information is contained in data structures that are used by RTEMS at system initialization time, the data structures themselves must not be generated by hand. RTEMS provides a set of macros system which provides a simple standard mechanism to automate the generation of these structures."
config,The RTEMS header file <rtems/confdefs.h> is at the core of the automatic generation of system configuration. It is based on the idea of setting macros which define configuration parameters of interest to the application and defaulting or calculating all others. This variety of macros can automatically produce all of the configuration data required for an RTEMS application.  The term confdefs is shorthand for a Configuration Defaults.
config,"As a general rule, application developers only specify values for the configuration parameters of interest to them. They define what resources or features they require. In most cases, when a parameter is not specified, it defaults to zero (0) instances, a standards compliant value, or disabled as appropriate. For example, by default there will be 256 task priority levels but this can be lowered by the application. This number of priority levels is required to be compliant with the RTEID/ORKID standards upon which the Classic API is based. There are similar cases where the default is selected to be compliant with the POSIX standard."
config,"For each configuration parameter in the configuration tables, the macro corresponding to that field is discussed. The RTEMS Maintainers expect that all systems can be easily configured using the <rtems/confdefs.h> mechanism and that using this mechanism will avoid internal RTEMS configuration changes impacting applications."
config,Some application configuration settings and other system parameters can be queried by the application. The directives provided by the Application Configuration Information are:
config,rtems_get_build_label() - Gets the RTEMS build label. rtems_get_copyright_notice() - Gets the RTEMS copyright notice. rtems_get_target_hash() - Gets the RTEMS target hash. rtems_get_version_string() - Gets the RTEMS version string. rtems_configuration_get_do_zero_of_workspace() - Indicates if the RTEMS Workspace is configured to be zeroed during system initialization for this application. rtems_configuration_get_idle_task_stack_size() - Gets the IDLE task stack size in bytes of this application. rtems_configuration_get_idle_task() - Gets the IDLE task body of this application. rtems_configuration_get_interrupt_stack_size() - Gets the interrupt stack size in bytes of this application. rtems_configuration_get_maximum_barriers() - Gets the resource number of Barrier Manager objects configured for this application. rtems_configuration_get_maximum_extensions() - Gets the resource number of User Extensions Manager objects configured for this application. rtems_configuration_get_maximum_message_queues() - Gets the resource number of Message Manager objects configured for this application. rtems_configuration_get_maximum_partitions() - Gets the resource number of Partition Manager objects configured for this application. rtems_configuration_get_maximum_periods() - Gets the resource number of Rate Monotonic Manager objects configured for this application. rtems_configuration_get_maximum_ports() - Gets the resource number of Dual-Ported Memory Manager objects configured for this application. rtems_configuration_get_maximum_processors() - Gets the maximum number of processors configured for this application. rtems_configuration_get_maximum_regions() - Gets the resource number of Region Manager objects configured for this application. rtems_configuration_get_maximum_semaphores() - Gets the resource number of Semaphore Manager objects configured for this application. rtems_configuration_get_maximum_tasks() - Gets the resource number of Task Manager objects configured for this application. rtems_configuration_get_maximum_timers() - Gets the resource number of Timer Manager objects configured for this application. rtems_configuration_get_microseconds_per_tick() - Gets the number of microseconds per clock tick configured for this application. rtems_configuration_get_milliseconds_per_tick() - Gets the number of milliseconds per clock tick configured for this application. rtems_configuration_get_nanoseconds_per_tick() - Gets the number of microseconds per clock tick configured for this application. rtems_configuration_get_number_of_initial_extensions() - Gets the number of initial extensions configured for this application. rtems_configuration_get_stack_allocate_for_idle_hook() - Gets the task stack allocator allocate hook used to allocate the stack of each IDLE task configured for this application. rtems_configuration_get_stack_allocate_hook() - Gets the task stack allocator allocate hook configured for this application. rtems_configuration_get_stack_allocate_init_hook() - Gets the task stack allocator initialization hook configured for this application. rtems_configuration_get_stack_allocator_avoids_work_space() - Indicates if the task stack allocator is configured to avoid the RTEMS Workspace for this application. rtems_configuration_get_stack_free_hook() - Gets the task stack allocator free hook configured for this application. rtems_configuration_get_stack_space_size() - Gets the configured size in bytes of the memory space used to allocate thread stacks for this application. rtems_configuration_get_ticks_per_timeslice() - Gets the clock ticks per timeslice configured for this application. rtems_configuration_get_unified_work_area() - Indicates if the RTEMS Workspace and C Program Heap are configured to be unified for this application. rtems_configuration_get_user_extension_table() - Gets the initial extensions table configured for this application. rtems_configuration_get_user_multiprocessing_table() - Gets the MPCI configuration table configured for this application. rtems_configuration_get_work_space_size() - Gets the RTEMS Workspace size in bytes configured for this application. rtems_configuration_get_rtems_api_configuration() - Gets the Classic API Configuration Table of this application. rtems_resource_is_unlimited() - Indicates if the resource is unlimited. rtems_resource_maximum_per_allocation() - Gets the maximum number per allocation of a resource number. rtems_resource_unlimited() - Augments the resource number so that it indicates an unlimited resource.
config,rtems_get_build_label() - Gets the RTEMS build label.
config,rtems_get_copyright_notice() - Gets the RTEMS copyright notice.
config,rtems_get_target_hash() - Gets the RTEMS target hash.
config,rtems_get_version_string() - Gets the RTEMS version string.
config,rtems_configuration_get_do_zero_of_workspace() - Indicates if the RTEMS Workspace is configured to be zeroed during system initialization for this application.
config,rtems_configuration_get_idle_task_stack_size() - Gets the IDLE task stack size in bytes of this application.
config,rtems_configuration_get_idle_task() - Gets the IDLE task body of this application.
config,rtems_configuration_get_interrupt_stack_size() - Gets the interrupt stack size in bytes of this application.
config,rtems_configuration_get_maximum_barriers() - Gets the resource number of Barrier Manager objects configured for this application.
config,rtems_configuration_get_maximum_extensions() - Gets the resource number of User Extensions Manager objects configured for this application.
config,rtems_configuration_get_maximum_message_queues() - Gets the resource number of Message Manager objects configured for this application.
config,rtems_configuration_get_maximum_partitions() - Gets the resource number of Partition Manager objects configured for this application.
config,rtems_configuration_get_maximum_periods() - Gets the resource number of Rate Monotonic Manager objects configured for this application.
config,rtems_configuration_get_maximum_ports() - Gets the resource number of Dual-Ported Memory Manager objects configured for this application.
config,rtems_configuration_get_maximum_processors() - Gets the maximum number of processors configured for this application.
config,rtems_configuration_get_maximum_regions() - Gets the resource number of Region Manager objects configured for this application.
config,rtems_configuration_get_maximum_semaphores() - Gets the resource number of Semaphore Manager objects configured for this application.
config,rtems_configuration_get_maximum_tasks() - Gets the resource number of Task Manager objects configured for this application.
config,rtems_configuration_get_maximum_timers() - Gets the resource number of Timer Manager objects configured for this application.
config,rtems_configuration_get_microseconds_per_tick() - Gets the number of microseconds per clock tick configured for this application.
config,rtems_configuration_get_milliseconds_per_tick() - Gets the number of milliseconds per clock tick configured for this application.
config,rtems_configuration_get_nanoseconds_per_tick() - Gets the number of microseconds per clock tick configured for this application.
config,rtems_configuration_get_number_of_initial_extensions() - Gets the number of initial extensions configured for this application.
config,rtems_configuration_get_stack_allocate_for_idle_hook() - Gets the task stack allocator allocate hook used to allocate the stack of each IDLE task configured for this application.
config,rtems_configuration_get_stack_allocate_hook() - Gets the task stack allocator allocate hook configured for this application.
config,rtems_configuration_get_stack_allocate_init_hook() - Gets the task stack allocator initialization hook configured for this application.
config,rtems_configuration_get_stack_allocator_avoids_work_space() - Indicates if the task stack allocator is configured to avoid the RTEMS Workspace for this application.
config,rtems_configuration_get_stack_free_hook() - Gets the task stack allocator free hook configured for this application.
config,rtems_configuration_get_stack_space_size() - Gets the configured size in bytes of the memory space used to allocate thread stacks for this application.
config,rtems_configuration_get_ticks_per_timeslice() - Gets the clock ticks per timeslice configured for this application.
config,rtems_configuration_get_unified_work_area() - Indicates if the RTEMS Workspace and C Program Heap are configured to be unified for this application.
config,rtems_configuration_get_user_extension_table() - Gets the initial extensions table configured for this application.
config,rtems_configuration_get_user_multiprocessing_table() - Gets the MPCI configuration table configured for this application.
config,rtems_configuration_get_work_space_size() - Gets the RTEMS Workspace size in bytes configured for this application.
config,rtems_configuration_get_rtems_api_configuration() - Gets the Classic API Configuration Table of this application.
config,rtems_resource_is_unlimited() - Indicates if the resource is unlimited.
config,rtems_resource_maximum_per_allocation() - Gets the maximum number per allocation of a resource number.
config,rtems_resource_unlimited() - Augments the resource number so that it indicates an unlimited resource.
config,"© Copyright 1988, 2024 RTEMS Project and contributors."
dual-ported-memory,"A dual-ported memory area (DPMA) is an contiguous block of RAM owned by a particular processor but which can be accessed by other processors in the system.  The owner accesses the memory using internal addresses, while other processors must use external addresses.  RTEMS defines a port as a particular mapping of internal and external addresses."
dual-ported-memory,There are two system configurations in which dual-ported memory is commonly found.  The first is tightly-coupled multiprocessor computer systems where the dual-ported memory is shared between all nodes and is used for inter-node communication.  The second configuration is computer systems with intelligent peripheral controllers.  These controllers typically utilize the DPMA for high-performance data transfers.
dual-ported-memory,"© Copyright 1988, 2024 RTEMS Project and contributors."
dual-ported-memory,The Dual-Ported Memory Manager provides a mechanism for converting addresses between internal and external representations for multiple dual-ported memory areas (DPMA). The directives provided by the Dual-Ported Memory Manager are:
dual-ported-memory,rtems_port_create() - Creates a port. rtems_port_ident() - Identifies a port by the object name. rtems_port_delete() - Deletes the port. rtems_port_external_to_internal() - Converts the external address to the internal address. rtems_port_internal_to_external() - Converts the internal address to the external address.
dual-ported-memory,rtems_port_create() - Creates a port.
dual-ported-memory,rtems_port_ident() - Identifies a port by the object name.
dual-ported-memory,rtems_port_delete() - Deletes the port.
dual-ported-memory,rtems_port_external_to_internal() - Converts the external address to the internal address.
dual-ported-memory,rtems_port_internal_to_external() - Converts the internal address to the external address.
dual-ported-memory,"© Copyright 1988, 2024 RTEMS Project and contributors."
dual-ported-memory,The rtems_port_create directive creates a port into a DPMA with the user-defined name.  The user specifies the association between internal and external representations for the port being created.  RTEMS allocates a Dual-Ported Memory Control Block (DPCB) from the DPCB free list to maintain the newly created DPMA.  RTEMS also generates a unique dual-ported memory port ID which is returned to the calling task.  RTEMS does not initialize the dual-ported memory area or access any memory within it.
dual-ported-memory,"When a port is created, RTEMS generates a unique port ID and assigns it to the created port until it is deleted.  The port ID may be obtained by either of two methods.  First, as the result of an invocation of the``rtems_port_create`` directive, the task ID is stored in a user provided location.  Second, the port ID may be obtained later using the rtems_port_ident directive.  The port ID is used by other dual-ported memory manager directives to access this port."
dual-ported-memory,"The rtems_port_external_to_internal directive is used to convert an address from external to internal representation for the specified port.  The rtems_port_internal_to_external directive is used to convert an address from internal to external representation for the specified port.  If an attempt is made to convert an address which lies outside the specified DPMA, then the address to be converted will be returned."
dual-ported-memory,"A port can be removed from the system and returned to RTEMS with the rtems_port_delete directive.  When a port is deleted, its control block is returned to the DPCB free list."
dual-ported-memory,"© Copyright 1988, 2024 RTEMS Project and contributors."
event,An event flag is used by a task (or ISR) to inform another task of the occurrence of a significant situation.  Thirty-two event flags are associated with each task.  A collection of one or more event flags is referred to as an event set.  The data type rtems_event_set is used to manage event sets.
event,The application developer should remember the following key characteristics of event operations when utilizing the event manager:
event,"Events provide a simple synchronization facility. Events are aimed at tasks. Tasks can wait on more than one event simultaneously. Events are independent of one another. Events do not hold or transport data. Events are not queued.  In other words, if an event is sent more than once to a task before being received, the second and subsequent send operations to that same task have no effect."
event,Events provide a simple synchronization facility.
event,Events are aimed at tasks.
event,Tasks can wait on more than one event simultaneously.
event,Events are independent of one another.
event,Events do not hold or transport data.
event,"Events are not queued.  In other words, if an event is sent more than once to a task before being received, the second and subsequent send operations to that same task have no effect."
event,An event set is posted when it is directed (or sent) to a task.  A pending event is an event that has been posted but not received.  An event condition is used to specify the event set which the task desires to receive and the algorithm which will be used to determine when the request is satisfied. An event condition is satisfied based upon one of two algorithms which are selected by the user.  The RTEMS_EVENT_ANY algorithm states that an event condition is satisfied when at least a single requested event is posted.  The RTEMS_EVENT_ALL algorithm states that an event condition is satisfied when every requested event is posted.
event,"An event set or condition is built by a bitwise OR of the desired events.  The set of valid events is RTEMS_EVENT_0 through RTEMS_EVENT_31.  If an event is not explicitly specified in the set or condition, then it is not present.  Events are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each event appears exactly once in the event set list."
event,"For example, when sending the event set consisting of RTEMS_EVENT_6, RTEMS_EVENT_15, and RTEMS_EVENT_31, the event parameter to the rtems_event_send directive should be RTEMS_EVENT_6 | RTEMS_EVENT_15 | RTEMS_EVENT_31."
event,"In general, an option is built by a bitwise OR of the desired option components.  The set of valid options for the rtems_event_receive directive are listed in the following table:"
event,RTEMS_WAIT task will wait for event (default) RTEMS_NO_WAIT task should not wait RTEMS_EVENT_ALL return after all events (default) RTEMS_EVENT_ANY return after any events
event,RTEMS_WAIT
event,task will wait for event (default)
event,RTEMS_NO_WAIT
event,task should not wait
event,RTEMS_EVENT_ALL
event,return after all events (default)
event,RTEMS_EVENT_ANY
event,return after any events
event,"Option values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each option appears exactly once in the component list.  An option listed as a default is not required to appear in the option list, although it is a good programming practice to specify default options.  If all defaults are desired, the option RTEMS_DEFAULT_OPTIONS should be specified on this call."
event,This example demonstrates the option parameter needed to poll for all events in a particular event condition to arrive.  The option parameter passed to the rtems_event_receive directive should be either RTEMS_EVENT_ALL | RTEMS_NO_WAIT or RTEMS_NO_WAIT.  The option parameter can be set to RTEMS_NO_WAIT because RTEMS_EVENT_ALL is the default condition for rtems_event_receive.
event,"© Copyright 1988, 2024 RTEMS Project and contributors."
event,The Event Manager provides a high performance method of inter-task communication and synchronization. The directives provided by the Event Manager are:
event,rtems_event_send() - Sends the event set to the task. rtems_event_receive() - Receives or gets an event set from the calling task.
event,rtems_event_send() - Sends the event set to the task.
event,rtems_event_receive() - Receives or gets an event set from the calling task.
event,"© Copyright 1988, 2024 RTEMS Project and contributors."
event,"The rtems_event_send directive allows a task (or an ISR) to direct an event set to a target task.  Based upon the state of the target task, one of the following situations applies:"
event,"Target Task is Blocked Waiting for Events If the waiting task’s input event condition is satisfied, then the task is made ready for execution. If the waiting task’s input event condition is not satisfied, then the event set is posted but left pending and the task remains blocked. If the waiting task’s input event condition is satisfied, then the task is made ready for execution. If the waiting task’s input event condition is not satisfied, then the event set is posted but left pending and the task remains blocked. Target Task is Not Waiting for Events The event set is posted and left pending. The event set is posted and left pending."
event,Target Task is Blocked Waiting for Events
event,"If the waiting task’s input event condition is satisfied, then the task is made ready for execution. If the waiting task’s input event condition is not satisfied, then the event set is posted but left pending and the task remains blocked."
event,"If the waiting task’s input event condition is satisfied, then the task is made ready for execution."
event,"If the waiting task’s input event condition is not satisfied, then the event set is posted but left pending and the task remains blocked."
event,Target Task is Not Waiting for Events
event,The event set is posted and left pending.
event,The event set is posted and left pending.
event,"The rtems_event_receive directive is used by tasks to accept a specific input event condition.  The task also specifies whether the request is satisfied when all requested events are available or any single requested event is available.  If the requested event condition is satisfied by pending events, then a successful return code and the satisfying event set are returned immediately.  If the condition is not satisfied, then one of the following situations applies:"
event,"By default, the calling task will wait forever for the event condition to be satisfied. Specifying the RTEMS_NO_WAIT option forces an immediate return with an error status code. Specifying a timeout limits the period the task will wait before returning with an error status code."
event,"By default, the calling task will wait forever for the event condition to be satisfied."
event,Specifying the RTEMS_NO_WAIT option forces an immediate return with an error status code.
event,Specifying a timeout limits the period the task will wait before returning with an error status code.
event,A task can determine the pending event set by calling the rtems_event_receive directive with a value of RTEMS_PENDING_EVENTS for the input event condition.  The pending events are returned to the calling task but the event set is left unaltered.
event,A task can receive all of the currently pending events by calling the rtems_event_receive directive with a value of RTEMS_ALL_EVENTS for the input event condition and RTEMS_NO_WAIT | RTEMS_EVENT_ANY for the option set.  The pending events are returned to the calling task and the event set is cleared.  If no events are pending then the RTEMS_UNSATISFIED status code will be returned.
event,"© Copyright 1988, 2024 RTEMS Project and contributors."
fatal-error,"The fatal error manager is called upon detection of an irrecoverable error condition by either RTEMS or the application software.  Fatal errors are also used in case it is difficult or impossible to return an error condition by other means, e.g. a return value of a directive call.  Fatal errors can be detected from various sources, for example"
fatal-error,"the executive (RTEMS), support libraries, user system code, user application code, and processor interrupts and exceptions (data abort, instruction prefetch errors, ECC errors, spurious interrupts, etc.)."
fatal-error,"the executive (RTEMS),"
fatal-error,"support libraries,"
fatal-error,"user system code,"
fatal-error,"user application code, and"
fatal-error,"processor interrupts and exceptions (data abort, instruction prefetch errors, ECC errors, spurious interrupts, etc.)."
fatal-error,"RTEMS automatically invokes the fatal error manager upon detection of an error it considers to be fatal.  Similarly, the user should invoke the fatal error manager upon detection of a fatal error."
fatal-error,"Each user extensions set may include a fatal error handler.  The fatal error handler in the initial extension sets can be used to provide access to debuggers and monitors which may be present on the target hardware. If any user-supplied fatal error handlers are installed, the fatal error manager will invoke them.  Usually, the board support package provides a fatal error extension which resets the board.  If no user handlers are configured or if all the user handler return control to the fatal error manager, then the CPU port provided idle loop executes."
fatal-error,"The _Terminate() handler is invoked to terminate the system.  It is called by all services which determine that a system termination is required. For example, it is called by all higher level directives which announce a fatal error, see Announcing a Fatal Error."
fatal-error,The first action of the system termination handler is to disable maskable interrupts.  This ensures that interrupts on this processor do not interfere with the system termination procedure.  This reduces the likelihood to end up in a recursive system termination procedure.
fatal-error,The second action of the system termination handler is to call the fatal extensions of the user extensions.
fatal-error,The fatal extensions are called with three parameters:
fatal-error,"the fatal source, a legacy parameter which is always set to false, and an error code with a fatal source dependent content."
fatal-error,"the fatal source,"
fatal-error,"a legacy parameter which is always set to false, and"
fatal-error,an error code with a fatal source dependent content.
fatal-error,"The fatal extensions of the initial extension sets are invoked first. For them, the following execution environment is required"
fatal-error,"a valid stack pointer and enough stack space, a valid code memory, and valid read-only data."
fatal-error,"a valid stack pointer and enough stack space,"
fatal-error,"a valid code memory, and"
fatal-error,valid read-only data.
fatal-error,"In uniprocessor configurations, the read-write data (including .bss segment) is not required.  In SMP configurations, however, the read-write data must have been initialized to determine the state of the other processors and request them to shut-down if necessary.  The board support package (BSP) may install an initial extension that performs a system reset.  See the BSP documentation in the RTEMS User Manual for more information how the system reset is done.  The BSP provided fatal extension can be disabled by the CONFIGURE_DISABLE_BSP_SETTINGS application configuration option.  It is recommended to provide an application-specific fatal extension using the CONFIGURE_INITIAL_EXTENSIONS application configuration option."
fatal-error,"In certain error conditions, it may be unreliable to carry out the following steps of the termination procedure since the read-write data may be corrupt. One of the fatal extensions of the initial extension set should reset the system to stop the system termination procedure."
fatal-error,"After invoking the fatal extensions of the initial extension sets, the fatal extensions of the dynamic extension sets are invoked.  For this procedure valid read-write data is required."
fatal-error,"The last action of the system termination handler is to execute the CPU port provided idle loop with maskable interrupts disabled.  Please note, that properly configured applications should not reach this point."
fatal-error,The following fatal sources are defined for RTEMS via the rtems_fatal_source enumeration.  Each symbolic name has the corresponding numeric fatal source in parenthesis.
fatal-error,Errors of the core operating system.  See Internal Error Codes.
fatal-error,Errors of the Classic API.
fatal-error,Errors of the POSIX API.
fatal-error,Fatal source for the block device cache.  See rtems_bdbuf_fatal_code.
fatal-error,Fatal source for application-specific errors.  The fatal code is application-specific.
fatal-error,Fatal source of exit().  The fatal code is the exit() status code.
fatal-error,Fatal source for BSP errors.  The fatal codes are defined in <bsp/fatal.h>.  Examples are interrupt and exception initialization.  See bsp_fatal_code and bsp_fatal().
fatal-error,Fatal source of assert().  The fatal code is the pointer value of the assert context.  See rtems_assert_context.
fatal-error,Fatal source of the stack checker.  The fatal code is the object name of the executing task.
fatal-error,Fatal source of the exceptions.  The fatal code is the pointer value of the exception frame pointer.  See rtems_exception_frame and rtems_exception_frame_print.
fatal-error,Fatal source of SMP domain.  See SMP_Fatal_code.
fatal-error,"Fatal source of rtems_panic(), see rtems_panic."
fatal-error,Fatal source for invalid C program heap frees via free().  The fatal code is the bad pointer.
fatal-error,Fatal source for heap errors.  The fatal code is the address to a heap error context.  See Heap_Error_context.
fatal-error,The following error codes are defined for the INTERNAL_ERROR_CORE fatal source.  Each symbolic name has the corresponding numeric error code in parenthesis.
fatal-error,There is not enough memory for the workspace.  This fatal error may occur during system initialization.  It is an application configuration error.
fatal-error,A non-POSIX thread entry function returned.  This is an API usage error.
fatal-error,An example code to provoke this fatal error is:
fatal-error,This fatal error can only occur on MPCI configurations.  The MPCI nodes or global objects configuration is inconsistent.  This fatal error may occur during system initialization.  It is an application configuration error.
fatal-error,This fatal error can only occur on MPCI configurations.  The own MPCI node number is invalid.  This fatal error may occur during system initialization.  It is an application configuration error.
fatal-error,This fatal error can only occur on MPCI configurations.  There is no MPCI configuration table.  This fatal error may occur during system initialization.  It is an application configuration error.
fatal-error,This fatal error can only occur on MPCI configurations.  The MPCI server thread received a bad packet.
fatal-error,This fatal error can only occur on MPCI configurations.  The MPCI packet pool is empty.  It is an application configuration error.
fatal-error,This fatal error can only occur on MPCI configurations.  The MPCI global objects pool is empty.  It is an application configuration error.
fatal-error,This fatal error can only occur on MPCI configurations.  The MPCI thread proxy pool is empty.  It is an application configuration error.
fatal-error,"This fatal error can only occur on MPCI configurations.  The system cannot find the global object for a specific object identifier.  In case this happens, then this is probably an operating system bug."
fatal-error,There is not enough memory for the C program heap.  This fatal error may occur during system initialization.  It is an application configuration error.
fatal-error,The use of _CPU_ISR_install_vector() is illegal on this system.
fatal-error,This fatal error can only occur on debug configurations.  It happens in case a thread which owns mutexes is deleted.  Mutexes owned by a deleted thread are in an inconsistent state.
fatal-error,An RTEMS initialization task entry function is NULL.  This fatal error may occur during system initialization.  It is an application configuration error.
fatal-error,A deadlock was detected during a thread queue enqueue operation.
fatal-error,"This fatal error can only happen in SMP configurations.  It is not allowed to obtain MrsP semaphores in a context with thread dispatching disabled, for example interrupt context."
fatal-error,An example code to provoke this fatal error is:
fatal-error,"It is illegal to call blocking operating system services with thread dispatching disabled, for example in interrupt context."
fatal-error,An example code to provoke this fatal error is:
fatal-error,"In SMP configurations, it is a fatal error to call blocking operating system with interrupts disabled, since this prevents delivery of inter-processor interrupts.  This could lead to executing threads which are not allowed to execute resulting in undefined system behaviour."
fatal-error,"Some CPU ports, for example the ARM Cortex-M port, have a similar problem, since the interrupt state is not a part of the thread context."
fatal-error,This fatal error is detected in the operating system core function _Thread_Do_dispatch() responsible to carry out a thread dispatch.
fatal-error,An example code to provoke this fatal error is:
fatal-error,The creation of the RTEMS initialization task failed.  This fatal error may occur during system initialization.  It is an application configuration error.
fatal-error,The creation of the POSIX initialization thread failed.  This fatal error may occur during system initialization.  It is an application configuration error.
fatal-error,Open of the standard output file descriptor failed or resulted in an unexpected file descriptor number.  This fatal error may occur during system initialization.  It is an application configuration error.
fatal-error,Open of the standard error file descriptor failed or resulted in an unexpected file descriptor number.  This fatal error may occur during system initialization.  It is an application configuration error.
fatal-error,"The floating point unit was used illegally, for example in interrupt context on some architectures."
fatal-error,A getentropy() system call failed in one of the ARC4RANDOM(3) functions.  This fatal error can only be fixed with a different implementation of getentropy().
fatal-error,"This fatal error may happen during workspace initialization.  There is not enough memory available to populate the per-CPU data areas, see <rtems/score/percpudata.h>."
fatal-error,"This fatal error may happen during system initialization.  The actual thread-local storage (TLS) size of the application exceeds the configured maximum, see CONFIGURE_MAXIMUM_THREAD_LOCAL_STORAGE_SIZE. You can get the thread-local storage size of an application using the RTEMS tool rtems-execinfo."
fatal-error,The construction of the RTEMS initialization task failed.  This fatal error may occur during system initialization.  It is an application configuration error.
fatal-error,The creation of an IDLE task failed.  This fatal error may occur during system initialization.  It happens if a task create extension fails for an IDLE task.
fatal-error,There was not enough memory available to allocate an IDLE task stack.  This fatal error may occur during system initialization.  It is an application configuration error.
fatal-error,"The task stack size of an IDLE task would have been less than the configured stack size for IDLE tasks, see CONFIGURE_IDLE_TASK_STACK_SIZE. This fatal error may occur during system initialization.  It is an application configuration error."
fatal-error,"This fatal error may be caused by rtems_cache_disable_data() if the data cache cannot be disabled for a particular target or configuration.  The data cache may be necessary to provide atomic operations.  In SMP configurations, the data cache may be required to ensure data coherency.  See the BSP documentation in the RTEMS User Manual for more information."
fatal-error,"© Copyright 1988, 2024 RTEMS Project and contributors."
fatal-error,The Fatal Error Manager processes all fatal or irrecoverable errors and other sources of system termination (for example after exit()).  Fatal errors are identified by the fatal source and code pair. The directives provided by the Fatal Error Manager are:
fatal-error,rtems_fatal() - Invokes the fatal error handler. rtems_panic() - Prints the message and invokes the fatal error handler. rtems_shutdown_executive() - Invokes the fatal error handler. rtems_exception_frame_print() - Prints the exception frame. rtems_fatal_source_text() - Returns a descriptive text for the fatal source. rtems_internal_error_text() - Returns a descriptive text for the internal error code. rtems_fatal_error_occurred() - Invokes the fatal error handler.
fatal-error,rtems_fatal() - Invokes the fatal error handler.
fatal-error,rtems_panic() - Prints the message and invokes the fatal error handler.
fatal-error,rtems_shutdown_executive() - Invokes the fatal error handler.
fatal-error,rtems_exception_frame_print() - Prints the exception frame.
fatal-error,rtems_fatal_source_text() - Returns a descriptive text for the fatal source.
fatal-error,rtems_internal_error_text() - Returns a descriptive text for the internal error code.
fatal-error,rtems_fatal_error_occurred() - Invokes the fatal error handler.
fatal-error,"© Copyright 1988, 2024 RTEMS Project and contributors."
fatal-error,"A fatal error can be announced by calling for example rtems_fatal(), rtems_shutdown_executive(), rtems_panic(), rtems_fatal_error_occurred(), or exit()."
fatal-error,"© Copyright 1988, 2024 RTEMS Project and contributors."
initialization,"Initialization task(s) are the mechanism by which RTEMS transfers initial control to the user’s application.  Initialization tasks differ from other application tasks in that they are defined in the User Initialization Tasks Table and automatically created and started by RTEMS as part of its initialization sequence.  Since the initialization tasks are scheduled using the same algorithm as all other RTEMS tasks, they must be configured at a priority and mode which will ensure that they will complete execution before other application tasks execute.  Although there is no upper limit on the number of initialization tasks, an application is required to define at least one."
initialization,A typical initialization task will create and start the static set of application tasks.  It may also create any other objects used by the application.  Initialization tasks which only perform initialization should delete themselves upon completion to free resources for other tasks. Initialization tasks may transform themselves into a “normal” application task. This transformation typically involves changing priority and execution mode. RTEMS does not automatically delete the initialization tasks.
initialization,"The Idle Task is the lowest priority task in a system and executes only when no other task is ready to execute.  The default implementation of this task consists of an infinite loop. RTEMS allows the Idle Task body to be replaced by a CPU specific implementation, a BSP specific implementation or an application specific implementation."
initialization,The Idle Task is preemptible and WILL be preempted when any other task is made ready to execute.  This characteristic is critical to the overall behavior of any application.
initialization,System initialization errors are fatal.  See Internal Error Codes.
initialization,"© Copyright 1988, 2024 RTEMS Project and contributors."
initialization,The Initialization Manager is responsible for initializing the system.
initialization,"The system initialization includes the initialization of the Board Support Package, RTEMS, device drivers, the root filesystem, and the application. The Fatal Error Manager is responsible for the system shutdown. The directives provided by the Initialization Manager are:"
initialization,rtems_initialize_executive() - Initializes the system and starts multitasking.
initialization,rtems_initialize_executive() - Initializes the system and starts multitasking.
initialization,"© Copyright 1988, 2024 RTEMS Project and contributors."
initialization,The Initialization Manager rtems_initialize_executive() directives is called by the boot_card() routine which is invoked by the Board Support Package once a basic C run-time environment is set up.  This consists of
initialization,"a valid and accessible text section, read-only data, read-write data and zero-initialized data, an initialization stack large enough to initialize the rest of the Board Support Package, RTEMS and the device drivers, all registers and components mandated by Application Binary Interface, and disabled interrupts."
initialization,"a valid and accessible text section, read-only data, read-write data and zero-initialized data,"
initialization,"an initialization stack large enough to initialize the rest of the Board Support Package, RTEMS and the device drivers,"
initialization,"all registers and components mandated by Application Binary Interface, and"
initialization,disabled interrupts.
initialization,The rtems_initialize_executive() directive uses a system initialization linker set to initialize only those parts of the overall RTEMS feature set that is necessary for a particular application.  Each RTEMS feature used the application may optionally register an initialization handler.  The system initialization API is available via #included <rtems/sysinit.h>.
initialization,A list of all initialization steps follows.  Some steps are optional depending on the requested feature set of the application.  The initialization steps are execute in the order presented here.
initialization,Initialization of the event recording is the first initialization step. This allows to record the further system initialization.  This step is optional and depends on the CONFIGURE_RECORD_PER_PROCESSOR_ITEMS configuration option.
initialization,The Board Support Package may perform an early platform initialization in this step.  This step is optional.
initialization,The Board Support Package should initialize everything so that calls to _Memory_Get() can be made after this step.  This step is optional.
initialization,The free memory is dirtied in this step.  This step is optional and depends on the BSP_DIRTY_MEMORY BSP option.
initialization,The stack checker initializes the ISR stacks in this step.  This step is optional and depends on the CONFIGURE_STACK_CHECKER_ENABLED configuration option.
initialization,The per-CPU data is initialized in this step.  This step is mandatory.
initialization,The Board Support Package may initialize the sbrk() support in this step.  This step is optional.
initialization,The workspace is initialized in this step.  This step is optional and depends on the application configuration.
initialization,The C program heap is initialized in this step.  This step is optional and depends on the application configuration.
initialization,The Board Support Package should perform a general platform initialization in this step (e.g. interrupt controller initialization).  This step is mandatory.
initialization,Initialization of the CPU counter hardware and support functions.  The CPU counter is initialized early to allow its use in the tracing and profiling of the system initialization sequence.  This step is optional and depends on the application configuration.
initialization,Registers the initial extensions.  This step is optional and depends on the application configuration.
initialization,"In MPCI configurations, an early MPCI initialization is performed in this step.  This step is mandatory in MPCI configurations."
initialization,"This directive is called when the Board Support Package has completed its basic initialization and allows RTEMS to initialize the application environment based upon the information in the Configuration Table, User Initialization Tasks Table, Device Driver Table, User Extension Table, Multiprocessor Configuration Table, and the Multiprocessor Communications Interface (MPCI) Table."
initialization,"In MPCI configurations, a general MPCI initialization is performed in this step.  This step is mandatory in MPCI configurations."
initialization,Initialization of the User Extensions object class.  This step is optional and depends on the application configuration.
initialization,Initialization of the Classic Tasks object class.  This step is optional and depends on the application configuration.
initialization,"In MPCI configurations, the Classic Tasks MPCI support is initialized in this step.  This step is optional and depends on the application configuration."
initialization,Initialization of the Classic Timer object class.  This step is optional and depends on the application configuration.
initialization,Initialization of the Classic Signal support.  This step is optional and depends on the application configuration.
initialization,"In MPCI configurations, the Classic Signal MPCI support is initialized in this step.  This step is optional and depends on the application configuration."
initialization,Initialization of the Classic Event support.  This step is optional and depends on the application configuration.  This step is only used on MPCI configurations.
initialization,"In MPCI configurations, the Classic Event MPCI support is initialized in this step.  This step is optional and depends on the application configuration."
initialization,Initialization of the Classic Message Queue object class.  This step is optional and depends on the application configuration.
initialization,Initialization of the Classic Semaphore object class.  This step is optional and depends on the application configuration.
initialization,"In MPCI configurations, the Classic Semaphore MPCI support is initialized in this step.  This step is optional and depends on the application configuration."
initialization,Initialization of the Classic Partition object class.  This step is optional and depends on the application configuration.
initialization,"In MPCI configurations, the Classic Partition MPCI support is initialized in this step.  This step is optional and depends on the application configuration."
initialization,Initialization of the Classic Region object class.  This step is optional and depends on the application configuration.
initialization,Initialization of the Classic Dual-Ported Memory object class.  This step is optional and depends on the application configuration.
initialization,Initialization of the Classic Rate-Monotonic object class.  This step is optional and depends on the application configuration.
initialization,Initialization of the Classic Barrier object class.  This step is optional and depends on the application configuration.
initialization,Initialization of the POSIX Signals support.  This step is optional and depends on the application configuration.
initialization,Initialization of the POSIX Threads object class.  This step is optional and depends on the application configuration.
initialization,Initialization of the POSIX Message Queue object class.  This step is optional and depends on the application configuration.
initialization,Initialization of the POSIX Semaphore object class.  This step is optional and depends on the application configuration.
initialization,Initialization of the POSIX Timer object class.  This step is optional and depends on the application configuration.
initialization,Initialization of the POSIX Shared Memory object class.  This step is optional and depends on the application configuration.
initialization,Initialization of the POSIX Keys object class.  This step is optional and depends on the application configuration.
initialization,Initialization of the POSIX Cleanup support.  This step is optional and depends on the application configuration.
initialization,Initialization of idle threads.  This step is mandatory.
initialization,Initialization of IO library.  This step is optional and depends on the application configuration.
initialization,Initialization of the root filesystem.  This step is optional and depends on the application configuration.
initialization,Driver manager initialization.  This step is optional and depends on the application configuration.  Only available if the driver manager is enabled.
initialization,"In MPCI configurations, the MPCI server is initialized in this step.  This step is mandatory in MPCI configurations."
initialization,Initialization step performed right before device drivers are initialized. This step is mandatory.
initialization,Driver manager level 1 initialization.  This step is optional and depends on the application configuration.  Only available if the driver manager is enabled.
initialization,"This step initializes all statically configured device drivers and performs all RTEMS initialization which requires device drivers to be initialized. This step is mandatory.  In a multiprocessor configuration, this service will initialize the Multiprocessor Communications Interface (MPCI) and synchronize with the other nodes in the system."
initialization,Driver manager level 2 initialization.  This step is optional and depends on the application configuration.  Only available if the driver manager is enabled.
initialization,Driver manager level 3 initialization.  This step is optional and depends on the application configuration.  Only available if the driver manager is enabled.
initialization,Driver manager level 4 initialization.  This step is optional and depends on the application configuration.  Only available if the driver manager is enabled.
initialization,Finalize MPCI initialization.  This step is mandatory on MPCI configurations.
initialization,Creates and starts the Classic initialization tasks.  This step is optional and depends on the application configuration.
initialization,Creates POSIX initialization threads.  This step is optional and depends on the application configuration.
initialization,"Open the standard input, output and error file descriptors.  This step is optional and depends on the application configuration."
initialization,The final action of the rtems_initialize_executive() directive is to start multitasking and switch to the highest priority ready thread.  RTEMS does not return to the initialization context and the initialization stack may be re-used for interrupt processing.
initialization,"Many of RTEMS actions during initialization are based upon the contents of the Configuration Table.  For more information regarding the format and contents of this table, please refer to the chapter Configuring a System."
initialization,"The global construction is carried out by the Classic API initialization task.  If no Classic API initialization task exists, then it is carried out by the POSIX API initialization thread.  If no initialization task or thread exists, then no global construction is performed.  The Classic API task or POSIX API thread which carries out global construction is called the main thread.  For configuration options related to initialization tasks, see CONFIGURE_RTEMS_INIT_TASKS_TABLE, CONFIGURE_POSIX_INIT_THREAD_TABLE, and CONFIGURE_IDLE_TASK_INITIALIZES_APPLICATION."
initialization,"Global construction runs before the task entry of the main thread.  The configuration of the main thread must take the global construction into account.  In particular, the main thread stack size, priority, attributes and initial modes must be set accordingly.  Thread-local objects and POSIX key values created during global construction are accessible by the main thread. If other initialization tasks are configured, and one of them has a higher priority than the main thread and the main thread is preemptible, this task executes before the global construction.  In case the main thread blocks during global construction, then other tasks may run.  In SMP configurations, other initialization tasks may run in parallel with global construction.  Tasks created during global construction may preempt the main thread or run in parallel in SMP configurations.  All RTEMS services allowed in task context are allowed during global construction."
initialization,"Global constructors are C++ global object constructors or functions with the constructor attribute.  For example, the following test program"
initialization,should output:
initialization,"© Copyright 1988, 2024 RTEMS Project and contributors."
interrupt,"The interrupt manager allows the application to connect a function to a hardware interrupt vector.  When an interrupt occurs, the processor will automatically vector to RTEMS.  RTEMS saves and restores all registers which are not preserved by the normal C calling convention for the target processor and invokes the user’s ISR.  The user’s ISR is responsible for processing the interrupt, clearing the interrupt if necessary, and device specific manipulation."
interrupt,The rtems_interrupt_catch directive connects a procedure to an interrupt vector.  The vector number is managed using the rtems_vector_number data type.
interrupt,The interrupt service routine is assumed to abide by these conventions and have a prototype similar to the following:
interrupt,"The vector number argument is provided by RTEMS to allow the application to identify the interrupt source.  This could be used to allow a single routine to service interrupts from multiple instances of the same device.  For example, a single routine could service interrupts from multiple serial ports and use the vector number to identify which port requires servicing."
interrupt,"To minimize the masking of lower or equal priority level interrupts, the ISR should perform the minimum actions required to service the interrupt.  Other non-essential actions should be handled by application tasks.  Once the user’s ISR has completed, it returns control to the RTEMS interrupt manager which will perform task dispatching and restore the registers saved before the ISR was invoked."
interrupt,"The RTEMS interrupt manager guarantees that proper task scheduling and dispatching are performed at the conclusion of an ISR.  A system call made by the ISR may have readied a task of higher priority than the interrupted task. Therefore, when the ISR completes, the postponed dispatch processing must be performed.  No dispatch processing is performed as part of directives which have been invoked by an ISR."
interrupt,Applications must adhere to the following rule if proper task scheduling and dispatching is to be performed:
interrupt,Note
interrupt,The interrupt manager must be used for all ISRs which may be interrupted by the highest priority ISR which invokes an RTEMS directive.
interrupt,"Consider a processor which allows a numerically low interrupt level to interrupt a numerically greater interrupt level.  In this example, if an RTEMS directive is used in a level 4 ISR, then all ISRs which execute at levels 0 through 4 must use the interrupt manager."
interrupt,Interrupts are nested whenever an interrupt occurs during the execution of another ISR.  RTEMS supports efficient interrupt nesting by allowing the nested ISRs to terminate without performing any dispatch processing.  Only when the outermost ISR terminates will the postponed dispatching occur.
interrupt,"Many processors support multiple interrupt levels or priorities.  The exact number of interrupt levels is processor dependent.  RTEMS internally supports 256 interrupt levels which are mapped to the processor’s interrupt levels.  For specific information on the mapping between RTEMS and the target processor’s interrupt levels, refer to the Interrupt Processing chapter of the Applications Supplement document for a specific target processor."
interrupt,"During the execution of directive calls, critical sections of code may be executed.  When these sections are encountered, RTEMS disables all maskable interrupts before the execution of the section and restores them to the previous level upon completion of the section.  RTEMS has been optimized to ensure that interrupts are disabled for a minimum length of time.  The maximum length of time interrupts are disabled by RTEMS is processor dependent and is detailed in the Timing Specification chapter of the Applications Supplement document for a specific target processor."
interrupt,"Non-maskable interrupts (NMI) cannot be disabled, and ISRs which execute at this level MUST NEVER issue RTEMS system calls.  If a directive is invoked, unpredictable results may occur due to the inability of RTEMS to protect its critical sections.  However, ISRs that make no system calls may safely execute as non-maskable interrupts."
interrupt,"© Copyright 1988, 2024 RTEMS Project and contributors."
interrupt,Any real-time executive must provide a mechanism for quick response to externally generated interrupts to satisfy the critical time constraints of the application.  The Interrupt Manager provides this mechanism for RTEMS. This manager permits quick interrupt response times by providing the critical ability to alter task execution which allows a task to be preempted upon exit from an ISR. The directives provided by the Interrupt Manager are:
interrupt,rtems_interrupt_catch() - Establishes an interrupt service routine. rtems_interrupt_disable() - Disables the maskable interrupts on the current processor. rtems_interrupt_enable() - Restores the previous interrupt level on the current processor. rtems_interrupt_flash() - Flashes interrupts on the current processor. rtems_interrupt_local_disable() - Disables the maskable interrupts on the current processor. rtems_interrupt_local_enable() - Restores the previous interrupt level on the current processor. rtems_interrupt_is_in_progress() - Checks if an ISR is in progress on the current processor. rtems_interrupt_lock_initialize() - Initializes the ISR lock. rtems_interrupt_lock_destroy() - Destroys the ISR lock. rtems_interrupt_lock_acquire() - Acquires the ISR lock. rtems_interrupt_lock_release() - Releases the ISR lock. rtems_interrupt_lock_acquire_isr() - Acquires the ISR lock from within an ISR. rtems_interrupt_lock_release_isr() - Releases the ISR lock from within an ISR. rtems_interrupt_lock_interrupt_disable() - Disables maskable interrupts on the current processor. RTEMS_INTERRUPT_LOCK_DECLARE() - Declares an ISR lock object. RTEMS_INTERRUPT_LOCK_DEFINE() - Defines an ISR lock object. RTEMS_INTERRUPT_LOCK_INITIALIZER() - Statically initializes an ISR lock object. RTEMS_INTERRUPT_LOCK_MEMBER() - Defines an ISR lock member. RTEMS_INTERRUPT_LOCK_REFERENCE() - Defines an ISR lock object reference. RTEMS_INTERRUPT_ENTRY_INITIALIZER() - Statically initializes an interrupt entry object. rtems_interrupt_entry_initialize() - Initializes the interrupt entry. rtems_interrupt_entry_install() - Installs the interrupt entry at the interrupt vector. rtems_interrupt_entry_remove() - Removes the interrupt entry from the interrupt vector. rtems_interrupt_handler_install() - Installs the interrupt handler routine and argument at the interrupt vector. rtems_interrupt_handler_remove() - Removes the interrupt handler routine and argument from the interrupt vector. rtems_interrupt_vector_is_enabled() - Checks if the interrupt vector is enabled. rtems_interrupt_vector_enable() - Enables the interrupt vector. rtems_interrupt_vector_disable() - Disables the interrupt vector. rtems_interrupt_is_pending() - Checks if the interrupt is pending. rtems_interrupt_raise() - Raises the interrupt vector. rtems_interrupt_raise_on() - Raises the interrupt vector on the processor. rtems_interrupt_clear() - Clears the interrupt vector. rtems_interrupt_get_priority() - Gets the priority of the interrupt vector. rtems_interrupt_set_priority() - Sets the priority of the interrupt vector. rtems_interrupt_get_affinity() - Gets the processor affinity set of the interrupt vector. rtems_interrupt_set_affinity() - Sets the processor affinity set of the interrupt vector. rtems_interrupt_get_attributes() - Gets the attributes of the interrupt vector. rtems_interrupt_handler_iterate() - Iterates over all interrupt handler installed at the interrupt vector. rtems_interrupt_server_initialize() - Initializes the interrupt server tasks. rtems_interrupt_server_create() - Creates an interrupt server. rtems_interrupt_server_handler_install() - Installs the interrupt handler routine and argument at the interrupt vector on the interrupt server. rtems_interrupt_server_handler_remove() - Removes the interrupt handler routine and argument from the interrupt vector and the interrupt server. rtems_interrupt_server_set_affinity() - Sets the processor affinity of the interrupt server. rtems_interrupt_server_delete() - Deletes the interrupt server. rtems_interrupt_server_suspend() - Suspends the interrupt server. rtems_interrupt_server_resume() - Resumes the interrupt server. rtems_interrupt_server_move() - Moves the interrupt handlers installed at the interrupt vector and the source interrupt server to the destination interrupt server. rtems_interrupt_server_handler_iterate() - Iterates over all interrupt handler installed at the interrupt vector and interrupt server. rtems_interrupt_server_entry_initialize() - Initializes the interrupt server entry. rtems_interrupt_server_action_prepend() - Prepends the interrupt server action to the list of actions of the interrupt server entry. rtems_interrupt_server_entry_destroy() - Destroys the interrupt server entry. rtems_interrupt_server_entry_submit() - Submits the interrupt server entry to be serviced by the interrupt server. rtems_interrupt_server_entry_move() - Moves the interrupt server entry to the interrupt server. rtems_interrupt_server_request_initialize() - Initializes the interrupt server request. rtems_interrupt_server_request_set_vector() - Sets the interrupt vector in the interrupt server request. rtems_interrupt_server_request_destroy() - Destroys the interrupt server request. rtems_interrupt_server_request_submit() - Submits the interrupt server request to be serviced by the interrupt server.
interrupt,rtems_interrupt_catch() - Establishes an interrupt service routine.
interrupt,rtems_interrupt_disable() - Disables the maskable interrupts on the current processor.
interrupt,rtems_interrupt_enable() - Restores the previous interrupt level on the current processor.
interrupt,rtems_interrupt_flash() - Flashes interrupts on the current processor.
interrupt,rtems_interrupt_local_disable() - Disables the maskable interrupts on the current processor.
interrupt,rtems_interrupt_local_enable() - Restores the previous interrupt level on the current processor.
interrupt,rtems_interrupt_is_in_progress() - Checks if an ISR is in progress on the current processor.
interrupt,rtems_interrupt_lock_initialize() - Initializes the ISR lock.
interrupt,rtems_interrupt_lock_destroy() - Destroys the ISR lock.
interrupt,rtems_interrupt_lock_acquire() - Acquires the ISR lock.
interrupt,rtems_interrupt_lock_release() - Releases the ISR lock.
interrupt,rtems_interrupt_lock_acquire_isr() - Acquires the ISR lock from within an ISR.
interrupt,rtems_interrupt_lock_release_isr() - Releases the ISR lock from within an ISR.
interrupt,rtems_interrupt_lock_interrupt_disable() - Disables maskable interrupts on the current processor.
interrupt,RTEMS_INTERRUPT_LOCK_DECLARE() - Declares an ISR lock object.
interrupt,RTEMS_INTERRUPT_LOCK_DEFINE() - Defines an ISR lock object.
interrupt,RTEMS_INTERRUPT_LOCK_INITIALIZER() - Statically initializes an ISR lock object.
interrupt,RTEMS_INTERRUPT_LOCK_MEMBER() - Defines an ISR lock member.
interrupt,RTEMS_INTERRUPT_LOCK_REFERENCE() - Defines an ISR lock object reference.
interrupt,RTEMS_INTERRUPT_ENTRY_INITIALIZER() - Statically initializes an interrupt entry object.
interrupt,rtems_interrupt_entry_initialize() - Initializes the interrupt entry.
interrupt,rtems_interrupt_entry_install() - Installs the interrupt entry at the interrupt vector.
interrupt,rtems_interrupt_entry_remove() - Removes the interrupt entry from the interrupt vector.
interrupt,rtems_interrupt_handler_install() - Installs the interrupt handler routine and argument at the interrupt vector.
interrupt,rtems_interrupt_handler_remove() - Removes the interrupt handler routine and argument from the interrupt vector.
interrupt,rtems_interrupt_vector_is_enabled() - Checks if the interrupt vector is enabled.
interrupt,rtems_interrupt_vector_enable() - Enables the interrupt vector.
interrupt,rtems_interrupt_vector_disable() - Disables the interrupt vector.
interrupt,rtems_interrupt_is_pending() - Checks if the interrupt is pending.
interrupt,rtems_interrupt_raise() - Raises the interrupt vector.
interrupt,rtems_interrupt_raise_on() - Raises the interrupt vector on the processor.
interrupt,rtems_interrupt_clear() - Clears the interrupt vector.
interrupt,rtems_interrupt_get_priority() - Gets the priority of the interrupt vector.
interrupt,rtems_interrupt_set_priority() - Sets the priority of the interrupt vector.
interrupt,rtems_interrupt_get_affinity() - Gets the processor affinity set of the interrupt vector.
interrupt,rtems_interrupt_set_affinity() - Sets the processor affinity set of the interrupt vector.
interrupt,rtems_interrupt_get_attributes() - Gets the attributes of the interrupt vector.
interrupt,rtems_interrupt_handler_iterate() - Iterates over all interrupt handler installed at the interrupt vector.
interrupt,rtems_interrupt_server_initialize() - Initializes the interrupt server tasks.
interrupt,rtems_interrupt_server_create() - Creates an interrupt server.
interrupt,rtems_interrupt_server_handler_install() - Installs the interrupt handler routine and argument at the interrupt vector on the interrupt server.
interrupt,rtems_interrupt_server_handler_remove() - Removes the interrupt handler routine and argument from the interrupt vector and the interrupt server.
interrupt,rtems_interrupt_server_set_affinity() - Sets the processor affinity of the interrupt server.
interrupt,rtems_interrupt_server_delete() - Deletes the interrupt server.
interrupt,rtems_interrupt_server_suspend() - Suspends the interrupt server.
interrupt,rtems_interrupt_server_resume() - Resumes the interrupt server.
interrupt,rtems_interrupt_server_move() - Moves the interrupt handlers installed at the interrupt vector and the source interrupt server to the destination interrupt server.
interrupt,rtems_interrupt_server_handler_iterate() - Iterates over all interrupt handler installed at the interrupt vector and interrupt server.
interrupt,rtems_interrupt_server_entry_initialize() - Initializes the interrupt server entry.
interrupt,rtems_interrupt_server_action_prepend() - Prepends the interrupt server action to the list of actions of the interrupt server entry.
interrupt,rtems_interrupt_server_entry_destroy() - Destroys the interrupt server entry.
interrupt,rtems_interrupt_server_entry_submit() - Submits the interrupt server entry to be serviced by the interrupt server.
interrupt,rtems_interrupt_server_entry_move() - Moves the interrupt server entry to the interrupt server.
interrupt,rtems_interrupt_server_request_initialize() - Initializes the interrupt server request.
interrupt,rtems_interrupt_server_request_set_vector() - Sets the interrupt vector in the interrupt server request.
interrupt,rtems_interrupt_server_request_destroy() - Destroys the interrupt server request.
interrupt,rtems_interrupt_server_request_submit() - Submits the interrupt server request to be serviced by the interrupt server.
interrupt,"© Copyright 1988, 2024 RTEMS Project and contributors."
interrupt,The rtems_interrupt_catch directive establishes an ISR for the system.  The address of the ISR and its associated CPU vector number are specified to this directive.  This directive installs the RTEMS interrupt wrapper in the processor’s Interrupt Vector Table and the address of the user’s ISR in the RTEMS’ Vector Table.  This directive returns the previous contents of the specified vector in the RTEMS’ Vector Table.
interrupt,"Using the interrupt manager ensures that RTEMS knows when a directive is being called from an ISR.  The ISR may then use system calls to synchronize itself with an application task.  The synchronization may involve messages, events or signals being passed by the ISR to the desired task.  Directives invoked by an ISR must operate only on objects which reside on the local node.  The following is a list of RTEMS system calls that may be made from an ISR:"
interrupt,"Task Management Although it is acceptable to operate on the RTEMS_SELF task (e.g.  the currently executing task), while in an ISR, this will refer to the interrupted task.  Most of the time, it is an application implementation error to use RTEMS_SELF from an ISR. rtems_task_suspend rtems_task_resume rtems_task_suspend rtems_task_resume Interrupt Management rtems_interrupt_enable rtems_interrupt_disable rtems_interrupt_flash rtems_interrupt_lock_acquire rtems_interrupt_lock_release rtems_interrupt_lock_acquire_isr rtems_interrupt_lock_release_isr rtems_interrupt_is_in_progress rtems_interrupt_catch rtems_interrupt_enable rtems_interrupt_disable rtems_interrupt_flash rtems_interrupt_lock_acquire rtems_interrupt_lock_release rtems_interrupt_lock_acquire_isr rtems_interrupt_lock_release_isr rtems_interrupt_is_in_progress rtems_interrupt_catch Clock Management rtems_clock_set rtems_clock_get_tod rtems_clock_get_tod_timeval rtems_clock_get_seconds_since_epoch rtems_clock_get_ticks_per_second rtems_clock_get_ticks_since_boot rtems_clock_get_uptime rtems_clock_set rtems_clock_get_tod rtems_clock_get_tod_timeval rtems_clock_get_seconds_since_epoch rtems_clock_get_ticks_per_second rtems_clock_get_ticks_since_boot rtems_clock_get_uptime Timer Management rtems_timer_cancel rtems_timer_reset rtems_timer_fire_after rtems_timer_fire_when rtems_timer_server_fire_after rtems_timer_server_fire_when rtems_timer_cancel rtems_timer_reset rtems_timer_fire_after rtems_timer_fire_when rtems_timer_server_fire_after rtems_timer_server_fire_when Event Management rtems_event_send rtems_event_system_send rtems_event_transient_send rtems_event_send rtems_event_system_send rtems_event_transient_send Semaphore Management rtems_semaphore_release rtems_semaphore_release Message Management rtems_message_queue_broadcast rtems_message_queue_send rtems_message_queue_urgent rtems_message_queue_broadcast rtems_message_queue_send rtems_message_queue_urgent Signal Management rtems_signal_send rtems_signal_send Dual-Ported Memory Management rtems_port_external_to_internal rtems_port_internal_to_external rtems_port_external_to_internal rtems_port_internal_to_external IO Management The following services are safe to call from an ISR if and only if the device driver service invoked is also safe.  The IO Manager itself is safe but the invoked driver entry point may or may not be. rtems_io_initialize rtems_io_open rtems_io_close rtems_io_read rtems_io_write rtems_io_control rtems_io_initialize rtems_io_open rtems_io_close rtems_io_read rtems_io_write rtems_io_control Fatal Error Management rtems_fatal rtems_fatal_error_occurred rtems_fatal rtems_fatal_error_occurred Multiprocessing rtems_multiprocessing_announce rtems_multiprocessing_announce"
interrupt,"Task Management Although it is acceptable to operate on the RTEMS_SELF task (e.g.  the currently executing task), while in an ISR, this will refer to the interrupted task.  Most of the time, it is an application implementation error to use RTEMS_SELF from an ISR."
interrupt,rtems_task_suspend rtems_task_resume
interrupt,rtems_task_suspend
interrupt,rtems_task_resume
interrupt,Interrupt Management
interrupt,rtems_interrupt_enable rtems_interrupt_disable rtems_interrupt_flash rtems_interrupt_lock_acquire rtems_interrupt_lock_release rtems_interrupt_lock_acquire_isr rtems_interrupt_lock_release_isr rtems_interrupt_is_in_progress rtems_interrupt_catch
interrupt,rtems_interrupt_enable
interrupt,rtems_interrupt_disable
interrupt,rtems_interrupt_flash
interrupt,rtems_interrupt_lock_acquire
interrupt,rtems_interrupt_lock_release
interrupt,rtems_interrupt_lock_acquire_isr
interrupt,rtems_interrupt_lock_release_isr
interrupt,rtems_interrupt_is_in_progress
interrupt,rtems_interrupt_catch
interrupt,Clock Management
interrupt,rtems_clock_set rtems_clock_get_tod rtems_clock_get_tod_timeval rtems_clock_get_seconds_since_epoch rtems_clock_get_ticks_per_second rtems_clock_get_ticks_since_boot rtems_clock_get_uptime
interrupt,rtems_clock_set
interrupt,rtems_clock_get_tod
interrupt,rtems_clock_get_tod_timeval
interrupt,rtems_clock_get_seconds_since_epoch
interrupt,rtems_clock_get_ticks_per_second
interrupt,rtems_clock_get_ticks_since_boot
interrupt,rtems_clock_get_uptime
interrupt,Timer Management
interrupt,rtems_timer_cancel rtems_timer_reset rtems_timer_fire_after rtems_timer_fire_when rtems_timer_server_fire_after rtems_timer_server_fire_when
interrupt,rtems_timer_cancel
interrupt,rtems_timer_reset
interrupt,rtems_timer_fire_after
interrupt,rtems_timer_fire_when
interrupt,rtems_timer_server_fire_after
interrupt,rtems_timer_server_fire_when
interrupt,Event Management
interrupt,rtems_event_send rtems_event_system_send rtems_event_transient_send
interrupt,rtems_event_send
interrupt,rtems_event_system_send
interrupt,rtems_event_transient_send
interrupt,Semaphore Management
interrupt,rtems_semaphore_release
interrupt,rtems_semaphore_release
interrupt,Message Management
interrupt,rtems_message_queue_broadcast rtems_message_queue_send rtems_message_queue_urgent
interrupt,rtems_message_queue_broadcast
interrupt,rtems_message_queue_send
interrupt,rtems_message_queue_urgent
interrupt,Signal Management
interrupt,rtems_signal_send
interrupt,rtems_signal_send
interrupt,Dual-Ported Memory Management
interrupt,rtems_port_external_to_internal rtems_port_internal_to_external
interrupt,rtems_port_external_to_internal
interrupt,rtems_port_internal_to_external
interrupt,IO Management The following services are safe to call from an ISR if and only if the device driver service invoked is also safe.  The IO Manager itself is safe but the invoked driver entry point may or may not be.
interrupt,rtems_io_initialize rtems_io_open rtems_io_close rtems_io_read rtems_io_write rtems_io_control
interrupt,rtems_io_initialize
interrupt,rtems_io_open
interrupt,rtems_io_close
interrupt,rtems_io_read
interrupt,rtems_io_write
interrupt,rtems_io_control
interrupt,Fatal Error Management
interrupt,rtems_fatal rtems_fatal_error_occurred
interrupt,rtems_fatal
interrupt,rtems_fatal_error_occurred
interrupt,Multiprocessing
interrupt,rtems_multiprocessing_announce
interrupt,rtems_multiprocessing_announce
interrupt,"© Copyright 1988, 2024 RTEMS Project and contributors."
io,Each application utilizing the RTEMS I/O manager must specify the address of a Device Driver Table in its Configuration Table. This table contains each device driver’s entry points that is to be initialised by RTEMS during initialization. Each device driver may contain the following entry points:
io,Initialization Open Close Read Write Control
io,Initialization
io,Open
io,Close
io,Read
io,Write
io,Control
io,"If the device driver does not support a particular entry point, then that entry in the Configuration Table should be NULL.  RTEMS will return RTEMS_SUCCESSFUL as the executive’s and zero (0) as the device driver’s return code for these device driver entry points."
io,Applications can register and unregister drivers with the RTEMS I/O manager avoiding the need to have all drivers statically defined and linked into this table.
io,The confdefs.h entry CONFIGURE_MAXIMUM_DRIVERS configures the number of driver slots available to the application.
io,"Each call to the I/O manager must provide a device’s major and minor numbers as arguments.  The major number is the index of the requested driver’s entry points in the Device Driver Table, and is used to select a specific device driver.  The exact usage of the minor number is driver specific, but is commonly used to distinguish between a number of devices controlled by the same driver."
io,"The data types rtems_device_major_number and rtems_device_minor_number are used to manipulate device major and minor numbers, respectively."
io,The I/O Manager provides facilities to associate a name with a particular device.  Directives are provided to register the name of a device and to look up the major/minor number pair associated with a device name.
io,"Application developers, as well as device driver developers, must be aware of the following regarding the RTEMS I/O Manager:"
io,"A device driver routine executes in the context of the invoking task.  Thus if the driver blocks, the invoking task blocks. The device driver is free to change the modes of the invoking task, although the driver should restore them to their original values. Device drivers may be invoked from ISRs. Only local device drivers are accessible through the I/O manager. A device driver routine may invoke all other RTEMS directives, including I/O directives, on both local and global objects."
io,"A device driver routine executes in the context of the invoking task.  Thus if the driver blocks, the invoking task blocks."
io,"The device driver is free to change the modes of the invoking task, although the driver should restore them to their original values."
io,Device drivers may be invoked from ISRs.
io,Only local device drivers are accessible through the I/O manager.
io,"A device driver routine may invoke all other RTEMS directives, including I/O directives, on both local and global objects."
io,"Although the RTEMS I/O manager provides a framework for device drivers, it makes no assumptions regarding the construction or operation of a device driver."
io,Board support package and application developers can select wether a device driver is statically entered into the default device table or registered at runtime.
io,Dynamic registration helps applications where:
io,The BSP and kernel libraries are common to a range of applications for a specific target platform. An application may be built upon a common library with all drivers. The application selects and registers the drivers. Uniform driver name lookup protects the application. The type and range of drivers may vary as the application probes a bus during initialization. Support for hot swap bus system such as Compact PCI. Support for runtime loadable driver modules.
io,The BSP and kernel libraries are common to a range of applications for a specific target platform. An application may be built upon a common library with all drivers. The application selects and registers the drivers. Uniform driver name lookup protects the application.
io,The type and range of drivers may vary as the application probes a bus during initialization.
io,Support for hot swap bus system such as Compact PCI.
io,Support for runtime loadable driver modules.
io,"When an application invokes an I/O manager directive, RTEMS determines which device driver entry point must be invoked.  The information passed by the application to RTEMS is then passed to the correct device driver entry point. RTEMS will invoke each device driver entry point assuming it is compatible with the following prototype:"
io,The format and contents of the parameter block are device driver and entry point dependent.
io,It is recommended that a device driver avoid generating error codes which conflict with those used by application components.  A common technique used to generate driver specific error codes is to make the most significant part of the status indicate a driver specific code.
io,RTEMS automatically initializes all device drivers when multitasking is initiated via the rtems_initialize_executive directive.  RTEMS initializes the device drivers by invoking each device driver initialization entry point with the following parameters:
io,the major device number for this device driver.
io,zero.
io,will point to  the Configuration Table.
io,"The returned status will be ignored by RTEMS.  If the driver cannot successfully initialize the device, then it should invoke the fatal_error_occurred directive."
io,"© Copyright 1988, 2024 RTEMS Project and contributors."
io,The Input/Output (I/O) Manager provides a well-defined mechanism for accessing device drivers and a structured methodology for organizing device drivers. The directives provided by the I/O Manager are:
io,rtems_io_register_driver() - Registers and initializes the device with the specified device driver address table and device major number in the Device Driver Table. rtems_io_unregister_driver() - Removes a device driver specified by the device major number from the Device Driver Table. rtems_io_initialize() - Initializes the device specified by the device major and minor numbers. rtems_io_register_name() - Registers the device specified by the device major and minor numbers in the file system under the specified name. rtems_io_open() - Opens the device specified by the device major and minor numbers. rtems_io_close() - Closes the device specified by the device major and minor numbers. rtems_io_read() - Reads from the device specified by the device major and minor numbers. rtems_io_write() - Writes to the device specified by the device major and minor numbers. rtems_io_control() - Controls the device specified by the device major and minor numbers.
io,rtems_io_register_driver() - Registers and initializes the device with the specified device driver address table and device major number in the Device Driver Table.
io,rtems_io_unregister_driver() - Removes a device driver specified by the device major number from the Device Driver Table.
io,rtems_io_initialize() - Initializes the device specified by the device major and minor numbers.
io,rtems_io_register_name() - Registers the device specified by the device major and minor numbers in the file system under the specified name.
io,rtems_io_open() - Opens the device specified by the device major and minor numbers.
io,rtems_io_close() - Closes the device specified by the device major and minor numbers.
io,rtems_io_read() - Reads from the device specified by the device major and minor numbers.
io,rtems_io_write() - Writes to the device specified by the device major and minor numbers.
io,rtems_io_control() - Controls the device specified by the device major and minor numbers.
io,"© Copyright 1988, 2024 RTEMS Project and contributors."
io,The rtems_io_register directive associates a name with the specified device (i.e. major/minor number pair).  Device names are typically registered as part of the device driver initialization sequence.  The rtems_io_lookup directive is used to determine the major/minor number pair associated with the specified device name.  The use of these directives frees the application from being dependent on the arbitrary assignment of major numbers in a particular application.  No device naming conventions are dictated by RTEMS.
io,"The I/O manager provides directives which enable the application program to utilize device drivers in a standard manner.  There is a direct correlation between the RTEMS I/O manager directives rtems_io_initialize, rtems_io_open, rtems_io_close, rtems_io_read, rtems_io_write, and rtems_io_control and the underlying device driver entry points."
io,"© Copyright 1988, 2024 RTEMS Project and contributors."
kernel-character-io,The kernel character input/output support is an extension of the I/O Manager to output characters to the kernel character output device and receive characters from the kernel character input device using a polled and non-blocking implementation.
kernel-character-io,"The directives may be used to print debug and test information.  The kernel character input/output support should work even if no Console Driver is configured, see CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER.  The kernel character input and output device is provided by the BSP. Applications may change the device. The directives provided by the Kernel Character I/O Support are:"
kernel-character-io,rtems_putc() - Outputs the character to the kernel character output device. rtems_put_char() - Puts the character using rtems_putc() putk() - Outputs the characters of the string and a newline character to the kernel character output device. printk() - Outputs the characters defined by the format string and the arguments to the kernel character output device. vprintk() - Outputs the characters defined by the format string and the variable argument list to the kernel character output device. rtems_printk_printer() - Outputs the characters defined by the format string and the variable argument list to the kernel character output device. getchark() - Tries to dequeue a character from the kernel character input device.
kernel-character-io,rtems_putc() - Outputs the character to the kernel character output device.
kernel-character-io,rtems_put_char() - Puts the character using rtems_putc()
kernel-character-io,putk() - Outputs the characters of the string and a newline character to the kernel character output device.
kernel-character-io,printk() - Outputs the characters defined by the format string and the arguments to the kernel character output device.
kernel-character-io,vprintk() - Outputs the characters defined by the format string and the variable argument list to the kernel character output device.
kernel-character-io,rtems_printk_printer() - Outputs the characters defined by the format string and the variable argument list to the kernel character output device.
kernel-character-io,getchark() - Tries to dequeue a character from the kernel character input device.
kernel-character-io,"© Copyright 1988, 2024 RTEMS Project and contributors."
message,"A message is a variable length buffer where information can be stored to support communication.  The length of the message and the information stored in that message are user-defined and can be actual data, pointer(s), or empty."
message,"A message queue permits the passing of messages among tasks and ISRs.  Message queues can contain a variable number of messages.  Normally messages are sent to and received from the queue in FIFO order using the rtems_message_queue_send directive.  However, the rtems_message_queue_urgent directive can be used to place messages at the head of a queue in LIFO order."
message,"Synchronization can be accomplished when a task can wait for a message to arrive at a queue.  Also, a task may poll a queue for the arrival of a message."
message,The maximum length message which can be sent is set on a per message queue basis.  The message content must be copied in general to/from an internal buffer of the message queue or directly to a peer in certain cases.  This copy operation is performed with interrupts disabled.  So it is advisable to keep the messages as short as possible.
message,"In general, an attribute set is built by a bitwise OR of the desired attribute components.  The set of valid message queue attributes is provided in the following table:"
message,RTEMS_FIFO tasks wait by FIFO (default) RTEMS_PRIORITY tasks wait by priority RTEMS_LOCAL local message queue (default) RTEMS_GLOBAL global message queue
message,RTEMS_FIFO
message,tasks wait by FIFO (default)
message,RTEMS_PRIORITY
message,tasks wait by priority
message,RTEMS_LOCAL
message,local message queue (default)
message,RTEMS_GLOBAL
message,global message queue
message,"An attribute listed as a default is not required to appear in the attribute list, although it is a good programming practice to specify default attributes. If all defaults are desired, the attribute RTEMS_DEFAULT_ATTRIBUTES should be specified on this call."
message,"This example demonstrates the attribute_set parameter needed to create a local message queue with the task priority waiting queue discipline.  The attribute_set parameter to the rtems_message_queue_create directive could be either RTEMS_PRIORITY or RTEMS_LOCAL | RTEMS_PRIORITY.  The attribute_set parameter can be set to RTEMS_PRIORITY because RTEMS_LOCAL is the default for all created message queues.  If a similar message queue were to be known globally, then the attribute_set parameter would be RTEMS_GLOBAL | RTEMS_PRIORITY."
message,"In general, an option is built by a bitwise OR of the desired option components.  The set of valid options for the rtems_message_queue_receive directive are listed in the following table:"
message,RTEMS_WAIT task will wait for a message (default) RTEMS_NO_WAIT task should not wait
message,RTEMS_WAIT
message,task will wait for a message (default)
message,RTEMS_NO_WAIT
message,task should not wait
message,"An option listed as a default is not required to appear in the option OR list, although it is a good programming practice to specify default options.  If all defaults are desired, the option RTEMS_DEFAULT_OPTIONS should be specified on this call."
message,This example demonstrates the option parameter needed to poll for a message to arrive.  The option parameter passed to the rtems_message_queue_receive directive should be RTEMS_NO_WAIT.
message,"© Copyright 1988, 2024 RTEMS Project and contributors."
message,The Message Manager provides communication and synchronization capabilities using RTEMS message queues. The directives provided by the Message Manager are:
message,rtems_message_queue_create() - Creates a message queue. rtems_message_queue_construct() - Constructs a message queue from the specified the message queue configuration. rtems_message_queue_ident() - Identifies a message queue by the object name. rtems_message_queue_delete() - Deletes the message queue. rtems_message_queue_send() - Puts the message at the rear of the queue. rtems_message_queue_urgent() - Puts the message at the front of the queue. rtems_message_queue_broadcast() - Broadcasts the messages to the tasks waiting at the queue. rtems_message_queue_receive() - Receives a message from the queue. rtems_message_queue_get_number_pending() - Gets the number of messages pending on the queue. rtems_message_queue_flush() - Flushes all messages on the queue. RTEMS_MESSAGE_QUEUE_BUFFER() - Defines a structure which can be used as a message queue buffer for messages of the specified maximum size.
message,rtems_message_queue_create() - Creates a message queue.
message,rtems_message_queue_construct() - Constructs a message queue from the specified the message queue configuration.
message,rtems_message_queue_ident() - Identifies a message queue by the object name.
message,rtems_message_queue_delete() - Deletes the message queue.
message,rtems_message_queue_send() - Puts the message at the rear of the queue.
message,rtems_message_queue_urgent() - Puts the message at the front of the queue.
message,rtems_message_queue_broadcast() - Broadcasts the messages to the tasks waiting at the queue.
message,rtems_message_queue_receive() - Receives a message from the queue.
message,rtems_message_queue_get_number_pending() - Gets the number of messages pending on the queue.
message,rtems_message_queue_flush() - Flushes all messages on the queue.
message,RTEMS_MESSAGE_QUEUE_BUFFER() - Defines a structure which can be used as a message queue buffer for messages of the specified maximum size.
message,"© Copyright 1988, 2024 RTEMS Project and contributors."
message,The rtems_message_queue_create directive creates a message queue with the user-defined name.  The user specifies the maximum message size and maximum number of messages which can be placed in the message queue at one time.  The user may select FIFO or task priority as the method for placing waiting tasks in the task wait queue.  RTEMS allocates a Queue Control Block (QCB) from the QCB free list to maintain the newly created queue as well as memory for the message buffer pool associated with this message queue.  RTEMS also generates a message queue ID which is returned to the calling task.
message,"For GLOBAL message queues, the maximum message size is effectively limited to the longest message which the MPCI is capable of transmitting."
message,"When a message queue is created, RTEMS generates a unique message queue ID. The message queue ID may be obtained by either of two methods.  First, as the result of an invocation of the rtems_message_queue_create directive, the queue ID is stored in a user provided location.  Second, the queue ID may be obtained later using the rtems_message_queue_ident directive.  The queue ID is used by other message manager directives to access this message queue."
message,"The rtems_message_queue_receive directive attempts to retrieve a message from the specified message queue.  If at least one message is in the queue, then the message is removed from the queue, copied to the caller’s message buffer, and returned immediately along with the length of the message.  When messages are unavailable, one of the following situations applies:"
message,"By default, the calling task will wait forever for the message to arrive. Specifying the RTEMS_NO_WAIT option forces an immediate return with an error status code. Specifying a timeout limits the period the task will wait before returning with an error status."
message,"By default, the calling task will wait forever for the message to arrive."
message,Specifying the RTEMS_NO_WAIT option forces an immediate return with an error status code.
message,Specifying a timeout limits the period the task will wait before returning with an error status.
message,"If the task waits for a message, then it is placed in the message queue’s task wait queue in either FIFO or task priority order.  All tasks waiting on a message queue are returned an error code when the message queue is deleted."
message,"Messages can be sent to a queue with the rtems_message_queue_send and rtems_message_queue_urgent directives.  These directives work identically when tasks are waiting to receive a message.  A task is removed from the task waiting queue, unblocked, and the message is copied to a waiting task’s message buffer."
message,"When no tasks are waiting at the queue, rtems_message_queue_send places the message at the rear of the message queue, while rtems_message_queue_urgent places the message at the front of the queue.  The message is copied to a message buffer from this message queue’s buffer pool and then placed in the message queue.  Neither directive can successfully send a message to a message queue which has a full queue of pending messages."
message,The rtems_message_queue_broadcast directive sends the same message to every task waiting on the specified message queue as an atomic operation.  The message is copied to each waiting task’s message buffer and each task is unblocked.  The number of tasks which were unblocked is returned to the caller.
message,"The rtems_message_queue_delete directive removes a message queue from the system and frees its control block as well as the memory associated with this message queue’s message buffer pool.  A message queue can be deleted by any local task that knows the message queue’s ID.  As a result of this directive, all tasks blocked waiting to receive a message from the message queue will be readied and returned a status code which indicates that the message queue was deleted.  Any subsequent references to the message queue’s name and ID are invalid.  Any messages waiting at the message queue are also deleted and deallocated."
message,"© Copyright 1988, 2024 RTEMS Project and contributors."
multiprocessing,"RTEMS makes no assumptions regarding the connection media or topology of a multiprocessor system.  The tasks which compose a particular application can be spread among as many processors as needed to satisfy the application’s timing requirements.  The application tasks can interact using a subset of the RTEMS directives as if they were on the same processor.  These directives allow application tasks to exchange data, communicate, and synchronize regardless of which processor they reside upon."
multiprocessing,"The RTEMS multiprocessor execution model is multiple instruction streams with multiple data streams (MIMD).  This execution model has each of the processors executing code independent of the other processors.  Because of this parallelism, the application designer can more easily guarantee deterministic behavior."
multiprocessing,"By supporting heterogeneous environments, RTEMS allows the systems designer to select the most efficient processor for each subsystem of the application. Configuring RTEMS for a heterogeneous environment is no more difficult than for a homogeneous one.  In keeping with RTEMS philosophy of providing transparent physical node boundaries, the minimal heterogeneous processing required is isolated in the MPCI layer."
multiprocessing,"A processor in a RTEMS system is referred to as a node.  Each node is assigned a unique non-zero node number by the application designer.  RTEMS assumes that node numbers are assigned consecutively from one to the maximum_nodes configuration parameter.  The node number, node, and the maximum number of nodes, maximum_nodes, in a system are found in the Multiprocessor Configuration Table.  The maximum_nodes field and the number of global objects, maximum_global_objects, is required to be the same on all nodes in a system."
multiprocessing,"The node number is used by RTEMS to identify each node when performing remote operations.  Thus, the Multiprocessor Communications Interface Layer (MPCI) must be able to route messages based on the node number."
multiprocessing,"All RTEMS objects which are created with the GLOBAL attribute will be known on all other nodes.  Global objects can be referenced from any node in the system, although certain directive specific restrictions (e.g. one cannot delete a remote object) may apply.  A task does not have to be global to perform operations involving remote objects.  The maximum number of global objects is the system is user configurable and can be found in the maximum_global_objects field in the Multiprocessor Configuration Table.  The distribution of tasks to processors is performed during the application design phase.  Dynamic task relocation is not supported by RTEMS."
multiprocessing,"RTEMS maintains two tables containing object information on every node in a multiprocessor system: a local object table and a global object table.  The local object table on each node is unique and contains information for all objects created on this node whether those objects are local or global.  The global object table contains information regarding all global objects in the system and, consequently, is the same on every node."
multiprocessing,"Since each node must maintain an identical copy of the global object table, the maximum number of entries in each copy of the table must be the same.  The maximum number of entries in each copy is determined by the maximum_global_objects parameter in the Multiprocessor Configuration Table. This parameter, as well as the maximum_nodes parameter, is required to be the same on all nodes.  To maintain consistency among the table copies, every node in the system must be informed of the creation or deletion of a global object."
multiprocessing,"When an application performs an operation on a remote global object, RTEMS must generate a Remote Request (RQ) message and send it to the appropriate node. After completing the requested operation, the remote node will build a Remote Response (RR) message and send it to the originating node.  Messages generated as a side-effect of a directive (such as deleting a global task) are known as Remote Processes (RP) and do not require the receiving node to respond."
multiprocessing,"Other than taking slightly longer to execute directives on remote objects, the application is unaware of the location of the objects it acts upon.  The exact amount of overhead required for a remote operation is dependent on the media connecting the nodes and, to a lesser degree, on the efficiency of the user-provided MPCI routines."
multiprocessing,The following shows the typical transaction sequence during a remote application:
multiprocessing,The application issues a directive accessing a remote global object.
multiprocessing,RTEMS determines the node on which the object resides.
multiprocessing,RTEMS calls the user-provided MPCI routine GET_PACKET to obtain a packet in which to build a RQ message.
multiprocessing,"After building a message packet, RTEMS calls the user-provided MPCI routine SEND_PACKET to transmit the packet to the node on which the object resides (referred to as the destination node)."
multiprocessing,"The calling task is blocked until the RR message arrives, and control of the processor is transferred to another task."
multiprocessing,"The MPCI layer on the destination node senses the arrival of a packet (commonly in an ISR), and calls the rtems_multiprocessing_announce directive.  This directive readies the Multiprocessing Server."
multiprocessing,"The Multiprocessing Server calls the user-provided MPCI routine RECEIVE_PACKET, performs the requested operation, builds an RR message, and returns it to the originating node."
multiprocessing,"The MPCI layer on the originating node senses the arrival of a packet (typically via an interrupt), and calls the RTEMS rtems_multiprocessing_announce directive.  This directive readies the Multiprocessing Server."
multiprocessing,"The Multiprocessing Server calls the user-provided MPCI routine RECEIVE_PACKET, readies the original requesting task, and blocks until another packet arrives.  Control is transferred to the original task which then completes processing of the directive."
multiprocessing,"If an uncorrectable error occurs in the user-provided MPCI layer, the fatal error handler should be invoked.  RTEMS assumes the reliable transmission and reception of messages by the MPCI and makes no attempt to detect or correct errors."
multiprocessing,"A proxy is an RTEMS data structure which resides on a remote node and is used to represent a task which must block as part of a remote operation. This action can occur as part of the rtems_semaphore_obtain and rtems_message_queue_receive directives.  If the object were local, the task’s control block would be available for modification to indicate it was blocking on a message queue or semaphore.  However, the task’s control block resides only on the same node as the task.  As a result, the remote node must allocate a proxy to represent the task until it can be readied."
multiprocessing,The maximum number of proxies is defined in the Multiprocessor Configuration Table.  Each node in a multiprocessor system may require a different number of proxies to be configured.  The distribution of proxy control blocks is application dependent and is different from the distribution of tasks.
multiprocessing,The Multiprocessor Configuration Table contains information needed by RTEMS when used in a multiprocessor system.  This table is discussed in detail in the section Multiprocessor Configuration Table of the Configuring a System chapter.
multiprocessing,"The Multiprocessor Communications Interface Layer (MPCI) is a set of user-provided procedures which enable the nodes in a multiprocessor system to communicate with one another.  These routines are invoked by RTEMS at various times in the preparation and processing of remote requests.  Interrupts are enabled when an MPCI procedure is invoked.  It is assumed that if the execution mode and/or interrupt level are altered by the MPCI layer, that they will be restored prior to returning to RTEMS."
multiprocessing,"The MPCI layer is responsible for managing a pool of buffers called packets and for sending these packets between system nodes.  Packet buffers contain the messages sent between the nodes.  Typically, the MPCI layer will encapsulate the packet within an envelope which contains the information needed by the MPCI layer.  The number of packets available is dependent on the MPCI layer implementation."
multiprocessing,The entry points to the routines in the user’s MPCI layer should be placed in the Multiprocessor Communications Interface Table.  The user must provide entry points for each of the following table entries in a multiprocessor system:
multiprocessing,initialization initialize the MPCI get_packet obtain a packet buffer return_packet return a packet buffer send_packet send a packet to another node receive_packet called to get an arrived packet
multiprocessing,initialization
multiprocessing,initialize the MPCI
multiprocessing,get_packet
multiprocessing,obtain a packet buffer
multiprocessing,return_packet
multiprocessing,return a packet buffer
multiprocessing,send_packet
multiprocessing,send a packet to another node
multiprocessing,receive_packet
multiprocessing,called to get an arrived packet
multiprocessing,A packet is sent by RTEMS in each of the following situations:
multiprocessing,an RQ is generated on an originating node; an RR is generated on a destination node; a global object is created; a global object is deleted; a local task blocked on a remote object is deleted; during system initialization to check for system consistency.
multiprocessing,an RQ is generated on an originating node;
multiprocessing,an RR is generated on a destination node;
multiprocessing,a global object is created;
multiprocessing,a global object is deleted;
multiprocessing,a local task blocked on a remote object is deleted;
multiprocessing,during system initialization to check for system consistency.
multiprocessing,"If the target hardware supports it, the arrival of a packet at a node may generate an interrupt.  Otherwise, the real-time clock ISR can check for the arrival of a packet.  In any case, the rtems_multiprocessing_announce directive must be called to announce the arrival of a packet.  After exiting the ISR, control will be passed to the Multiprocessing Server to process the packet.  The Multiprocessing Server will call the get_packet entry to obtain a packet buffer and the receive_entry entry to copy the message into the buffer obtained."
multiprocessing,The INITIALIZATION component of the user-provided MPCI layer is called as part of the rtems_initialize_executive directive to initialize the MPCI layer and associated hardware.  It is invoked immediately after all of the device drivers have been initialized.  This component should be adhere to the following prototype:
multiprocessing,"Operations on global objects cannot be performed until this component is invoked.  The INITIALIZATION component is invoked only once in the life of any system.  If the MPCI layer cannot be successfully initialized, the fatal error manager should be invoked by this routine."
multiprocessing,One of the primary functions of the MPCI layer is to provide the executive with packet buffers.  The INITIALIZATION routine must create and initialize a pool of packet buffers.  There must be enough packet buffers so RTEMS can obtain one whenever needed.
multiprocessing,The GET_PACKET component of the user-provided MPCI layer is called when RTEMS must obtain a packet buffer to send or broadcast a message.  This component should be adhere to the following prototype:
multiprocessing,"where packet is the address of a pointer to a packet.  This routine always succeeds and, upon return, packet will contain the address of a packet.  If for any reason, a packet cannot be successfully obtained, then the fatal error manager should be invoked."
multiprocessing,"RTEMS has been optimized to avoid the need for obtaining a packet each time a message is sent or broadcast.  For example, RTEMS sends response messages (RR) back to the originator in the same packet in which the request message (RQ) arrived."
multiprocessing,The RETURN_PACKET component of the user-provided MPCI layer is called when RTEMS needs to release a packet to the free packet buffer pool.  This component should be adhere to the following prototype:
multiprocessing,"where packet is the address of a packet.  If the packet cannot be successfully returned, the fatal error manager should be invoked."
multiprocessing,The RECEIVE_PACKET component of the user-provided MPCI layer is called when RTEMS needs to obtain a packet which has previously arrived.  This component should be adhere to the following prototype:
multiprocessing,"where packet is a pointer to the address of a packet to place the message from another node.  If a message is available, then packet will contain the address of the message from another node.  If no messages are available, this entry packet should contain NULL."
multiprocessing,The SEND_PACKET component of the user-provided MPCI layer is called when RTEMS needs to send a packet containing a message to another node.  This component should be adhere to the following prototype:
multiprocessing,"where node is the node number of the destination and packet is the address of a packet which containing a message.  If the packet cannot be successfully sent, the fatal error manager should be invoked."
multiprocessing,"If node is set to zero, the packet is to be broadcasted to all other nodes in the system.  Although some MPCI layers will be built upon hardware which support a broadcast mechanism, others may be required to generate a copy of the packet for each node in the system."
multiprocessing,Many MPCI layers use the packet_length field of the rtems_packet_prefix portion of the packet to avoid sending unnecessary data.  This is especially useful if the media connecting the nodes is relatively slow.
multiprocessing,The to_convert field of the rtems_packet_prefix portion of the packet indicates how much of the packet in 32-bit units may require conversion in a heterogeneous system.
multiprocessing,Developing an MPCI layer for a heterogeneous system requires a thorough understanding of the differences between the processors which comprise the system.  One difficult problem is the varying data representation schemes used by different processor types.  The most pervasive data representation problem is the order of the bytes which compose a data entity.  Processors which place the least significant byte at the smallest address are classified as little endian processors.  Little endian byte-ordering is shown below:
multiprocessing,"Conversely, processors which place the most significant byte at the smallest address are classified as big endian processors.  Big endian byte-ordering is shown below:"
multiprocessing,"Unfortunately, sharing a data structure between big endian and little endian processors requires translation into a common endian format.  An application designer typically chooses the common endian format to minimize conversion overhead."
multiprocessing,"Another issue in the design of shared data structures is the alignment of data structure elements.  Alignment is both processor and compiler implementation dependent.  For example, some processors allow data elements to begin on any address boundary, while others impose restrictions.  Common restrictions are that data elements must begin on either an even address or on a long word boundary.  Violation of these restrictions may cause an exception or impose a performance penalty."
multiprocessing,"Other issues which commonly impact the design of shared data structures include the representation of floating point numbers, bit fields, decimal data, and character strings.  In addition, the representation method for negative integers could be one’s or two’s complement.  These factors combine to increase the complexity of designing and manipulating data structures shared between processors."
multiprocessing,"RTEMS addressed these issues in the design of the packets used to communicate between nodes.  The RTEMS packet format is designed to allow the MPCI layer to perform all necessary conversion without burdening the developer with the details of the RTEMS packet format.  As a result, the MPCI layer must be aware of the following:"
multiprocessing,All packets must begin on a four byte boundary. Packets are composed of both RTEMS and application data.  All RTEMS data is treated as 32-bit unsigned quantities and is in the first to_convert 32-bit quantities of the packet.  The to_convert field is part of the rtems_packet_prefix portion of the packet. The RTEMS data component of the packet must be in native endian format. Endian conversion may be performed by either the sending or receiving MPCI layer. RTEMS makes no assumptions regarding the application data component of the packet.
multiprocessing,All packets must begin on a four byte boundary.
multiprocessing,Packets are composed of both RTEMS and application data.  All RTEMS data is treated as 32-bit unsigned quantities and is in the first to_convert 32-bit quantities of the packet.  The to_convert field is part of the rtems_packet_prefix portion of the packet.
multiprocessing,The RTEMS data component of the packet must be in native endian format. Endian conversion may be performed by either the sending or receiving MPCI layer.
multiprocessing,RTEMS makes no assumptions regarding the application data component of the packet.
multiprocessing,"© Copyright 1988, 2024 RTEMS Project and contributors."
multiprocessing,The Multiprocessing Manager provides support for heterogeneous multiprocessing systems based on message passing in a network of multiprocessing nodes.
multiprocessing,"In multiprocessor real-time systems, new requirements, such as sharing data and global resources between processors, are introduced.  This requires an efficient and reliable communications vehicle which allows all processors to communicate with each other as necessary.  In addition, the ramifications of multiple processors affect each and every characteristic of a real-time system, almost always making them more complicated."
multiprocessing,"RTEMS addresses these issues by providing simple and flexible real-time multiprocessing capabilities.  The executive easily lends itself to both tightly-coupled and loosely-coupled configurations of the target system hardware.  In addition, RTEMS supports systems composed of both homogeneous and heterogeneous mixtures of processors and target boards."
multiprocessing,"A major design goal of the RTEMS executive was to transcend the physical boundaries of the target hardware configuration.  This goal is achieved by presenting the application software with a logical view of the target system where the boundaries between processor nodes are transparent.  As a result, the application developer may designate objects such as tasks, queues, events, signals, semaphores, and memory blocks as global objects.  These global objects may then be accessed by any task regardless of the physical location of the object and the accessing task.  RTEMS automatically determines that the object being accessed resides on another processor and performs the actions required to access the desired object.  Simply stated, RTEMS allows the entire system, both hardware and software, to be viewed logically as a single system. The directives provided by the Multiprocessing Manager are:"
multiprocessing,rtems_multiprocessing_announce() - Announces the arrival of a packet.
multiprocessing,rtems_multiprocessing_announce() - Announces the arrival of a packet.
multiprocessing,"© Copyright 1988, 2024 RTEMS Project and contributors."
multiprocessing,The rtems_multiprocessing_announce directive is called by the MPCI layer to inform RTEMS that a packet has arrived from another node.  This directive can be called from an interrupt service routine or from within a polling routine.
multiprocessing,"© Copyright 1988, 2024 RTEMS Project and contributors."
object-services,"RTEMS implements multiple APIs including an Internal API, the Classic API, and the POSIX API.  These APIs share the common foundation of SuperCore objects and thus share object management code. This includes a common scheme for object Ids and for managing object names whether those names be in the thirty-two bit form used by the Classic API or C strings."
object-services,The object Id contains a field indicating the API that an object instance is associated with.  This field holds a numerically small non-zero integer.
object-services,Each API consists of a collection of managers.  Each manager is responsible for instances of a particular object class.  Classic API Tasks and POSIX Mutexes example classes.
object-services,"The object Id contains a field indicating the class that an object instance is associated with.  This field holds a numerically small non-zero integer.  In all APIs, a class value of one is reserved for tasks or threads."
object-services,"Every RTEMS object which has an Id may also have a name associated with it. Depending on the API, names may be either thirty-two bit integers as in the Classic API or strings as in the POSIX API."
object-services,"Some objects have Ids but do not have a defined way to associate a name with them.  For example, POSIX threads have Ids but per POSIX do not have names. In RTEMS, objects not defined to have thirty-two bit names may have string names assigned to them via the rtems_object_set_name service.  The original impetus in providing this service was so the normally anonymous POSIX threads could have a user defined name in CPU Usage Reports."
object-services,"© Copyright 1988, 2024 RTEMS Project and contributors."
object-services,RTEMS provides a collection of services to assist in the management and usage of the objects created and utilized via other managers.  These services assist in the manipulation of RTEMS objects independent of the API used to create them. The directives provided by the Object Services are:
object-services,"rtems_build_id() - Builds the object identifier from the API, class, MPCI node, and index components. rtems_build_name() - Builds the object name composed of the four characters. rtems_object_get_classic_name() - Gets the object name associated with the object identifier. rtems_object_get_name() - Gets the object name associated with the object identifier as a string. rtems_object_set_name() - Sets the object name of the object associated with the object identifier. rtems_object_id_get_api() - Gets the API component of the object identifier. rtems_object_id_get_class() - Gets the class component of the object identifier. rtems_object_id_get_node() - Gets the MPCI node component of the object identifier. rtems_object_id_get_index() - Gets the index component of the object identifier. rtems_object_id_api_minimum() - Gets the lowest valid value for the API component of an object identifier. rtems_object_id_api_maximum() - Gets the highest valid value for the API component of an object identifier. rtems_object_api_minimum_class() - Gets the lowest valid class value of the object API. rtems_object_api_maximum_class() - Gets the highest valid class value of the object API. rtems_object_get_api_name() - Gets a descriptive name of the object API. rtems_object_get_api_class_name() - Gets a descriptive name of the object class of the object API. rtems_object_get_class_information() - Gets the object class information of the object class of the object API. rtems_object_get_local_node() - Gets the local MPCI node number. RTEMS_OBJECT_ID_INITIAL() - Builds the object identifier with the lowest index from the API, class, and MPCI node components."
object-services,"rtems_build_id() - Builds the object identifier from the API, class, MPCI node, and index components."
object-services,rtems_build_name() - Builds the object name composed of the four characters.
object-services,rtems_object_get_classic_name() - Gets the object name associated with the object identifier.
object-services,rtems_object_get_name() - Gets the object name associated with the object identifier as a string.
object-services,rtems_object_set_name() - Sets the object name of the object associated with the object identifier.
object-services,rtems_object_id_get_api() - Gets the API component of the object identifier.
object-services,rtems_object_id_get_class() - Gets the class component of the object identifier.
object-services,rtems_object_id_get_node() - Gets the MPCI node component of the object identifier.
object-services,rtems_object_id_get_index() - Gets the index component of the object identifier.
object-services,rtems_object_id_api_minimum() - Gets the lowest valid value for the API component of an object identifier.
object-services,rtems_object_id_api_maximum() - Gets the highest valid value for the API component of an object identifier.
object-services,rtems_object_api_minimum_class() - Gets the lowest valid class value of the object API.
object-services,rtems_object_api_maximum_class() - Gets the highest valid class value of the object API.
object-services,rtems_object_get_api_name() - Gets a descriptive name of the object API.
object-services,rtems_object_get_api_class_name() - Gets a descriptive name of the object class of the object API.
object-services,rtems_object_get_class_information() - Gets the object class information of the object class of the object API.
object-services,rtems_object_get_local_node() - Gets the local MPCI node number.
object-services,"RTEMS_OBJECT_ID_INITIAL() - Builds the object identifier with the lowest index from the API, class, and MPCI node components."
object-services,"© Copyright 1988, 2024 RTEMS Project and contributors."
object-services,Services are provided to decompose an object Id into its subordinate components. The following services are used to do this:
object-services,rtems_object_id_get_api rtems_object_id_get_class rtems_object_id_get_node rtems_object_id_get_index
object-services,rtems_object_id_get_api
object-services,rtems_object_id_get_class
object-services,rtems_object_id_get_node
object-services,rtems_object_id_get_index
object-services,The following C language example illustrates the decomposition of an Id and printing the values.
object-services,This prints the components of the Ids as integers.
object-services,It is also possible to construct an arbitrary Id using the rtems_build_id service.  The following C language example illustrates how to construct the “next Id.”
object-services,Note that this Id may not be valid in this system or associated with an allocated object.
object-services,RTEMS also provides services to associate the API and Class portions of an Object Id with strings.  This allows the application developer to provide more information about an object in diagnostic messages.
object-services,"In the following C language example, an Id is decomposed into its constituent parts and “pretty-printed.”"
object-services,"© Copyright 1988, 2024 RTEMS Project and contributors."
partition,A partition is a physically contiguous memory area divided into fixed-size buffers that can be dynamically allocated and deallocated.
partition,"Partitions are managed and maintained as a list of buffers.  Buffers are obtained from the front of the partition’s free buffer chain and returned to the rear of the same chain.  When a buffer is on the free buffer chain, RTEMS uses two pointers of memory from each buffer as the free buffer chain.  When a buffer is allocated, the entire buffer is available for application use. Therefore, modifying memory that is outside of an allocated buffer could destroy the free buffer chain or the contents of an adjacent allocated buffer."
partition,"In general, an attribute set is built by a bitwise OR of the desired attribute components.  The set of valid partition attributes is provided in the following table:"
partition,RTEMS_LOCAL local partition (default) RTEMS_GLOBAL global partition
partition,RTEMS_LOCAL
partition,local partition (default)
partition,RTEMS_GLOBAL
partition,global partition
partition,"Attribute values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each attribute appears exactly once in the component list.  An attribute listed as a default is not required to appear in the attribute list, although it is a good programming practice to specify default attributes.  If all defaults are desired, the attribute RTEMS_DEFAULT_ATTRIBUTES should be specified on this call.  The attribute_set parameter should be RTEMS_GLOBAL to indicate that the partition is to be known globally."
partition,"© Copyright 1988, 2024 RTEMS Project and contributors."
partition,The Partition Manager provides facilities to dynamically allocate memory in fixed-size units. The directives provided by the Partition Manager are:
partition,rtems_partition_create() - Creates a partition. rtems_partition_ident() - Identifies a partition by the object name. rtems_partition_delete() - Deletes the partition. rtems_partition_get_buffer() - Tries to get a buffer from the partition. rtems_partition_return_buffer() - Returns the buffer to the partition.
partition,rtems_partition_create() - Creates a partition.
partition,rtems_partition_ident() - Identifies a partition by the object name.
partition,rtems_partition_delete() - Deletes the partition.
partition,rtems_partition_get_buffer() - Tries to get a buffer from the partition.
partition,rtems_partition_return_buffer() - Returns the buffer to the partition.
partition,"© Copyright 1988, 2024 RTEMS Project and contributors."
partition,"The rtems_partition_create directive creates a partition with a user-specified name.  The partition’s name, starting address, length and buffer size are all specified to the rtems_partition_create directive.  RTEMS allocates a Partition Control Block (PTCB) from the PTCB free list.  This data structure is used by RTEMS to manage the newly created partition.  The number of buffers in the partition is calculated based upon the specified partition length and buffer size. If successful,the unique partition ID is returned to the calling task."
partition,"When a partition is created, RTEMS generates a unique partition ID and assigned it to the created partition until it is deleted.  The partition ID may be obtained by either of two methods.  First, as the result of an invocation of the rtems_partition_create directive, the partition ID is stored in a user provided location.  Second, the partition ID may be obtained later using the rtems_partition_ident directive.  The partition ID is used by other partition manager directives to access this partition."
partition,"A buffer can be obtained by calling the rtems_partition_get_buffer directive.  If a buffer is available, then it is returned immediately with a successful return code.  Otherwise, an unsuccessful return code is returned immediately to the caller.  Tasks cannot block to wait for a buffer to become available."
partition,Buffers are returned to a partition’s free buffer chain with the rtems_partition_return_buffer directive.  This directive returns an error status code if the returned buffer was not previously allocated from this partition.
partition,"The rtems_partition_delete directive allows a partition to be removed and returned to RTEMS.  When a partition is deleted, the PTCB for that partition is returned to the PTCB free list.  A partition with buffers still allocated cannot be deleted.  Any task attempting to do so will be returned an error status code."
partition,"© Copyright 1988, 2024 RTEMS Project and contributors."
rate-monotonic,"The rate monotonic manager provides facilities to manage the execution of periodic tasks.  This manager was designed to support application designers who utilize the Rate Monotonic Scheduling Algorithm (RMS) to ensure that their periodic tasks will meet their deadlines, even under transient overload conditions.  Although designed for hard real-time systems, the services provided by the rate monotonic manager may be used by any application which requires periodic tasks."
rate-monotonic,A clock tick is required to support the functionality provided by this manager.
rate-monotonic,This manager maintains a set of statistics on each period object.  These statistics are reset implictly at period creation time and may be reset or obtained at any time by the application.  The following is a list of the information kept:
rate-monotonic,is the id of the thread that owns this period.
rate-monotonic,is the total number of periods executed.
rate-monotonic,is the number of periods that were missed.
rate-monotonic,is the minimum amount of CPU execution time consumed on any execution of the periodic loop.
rate-monotonic,is the maximum amount of CPU execution time consumed on any execution of the periodic loop.
rate-monotonic,is the total amount of CPU execution time consumed by executions of the periodic loop.
rate-monotonic,is the minimum amount of wall time that passed on any execution of the periodic loop.
rate-monotonic,is the maximum amount of wall time that passed on any execution of the periodic loop.
rate-monotonic,is the total amount of wall time that passed during executions of the periodic loop.
rate-monotonic,"Each period is divided into two consecutive phases.  The period starts with the active phase of the task and is followed by the inactive phase of the task.  In the inactive phase the task is blocked and waits for the start of the next period.  The inactive phase is skipped in case of a period miss.  The wall time includes the time during the active phase of the task on which the task is not executing on a processor.  The task is either blocked (for example it waits for a resource) or a higher priority tasks executes, thus preventing it from executing.  In case the wall time exceeds the period time, then this is a period miss.  The gap between the wall time and the period time is the margin between a period miss or success."
rate-monotonic,"The period statistics information is inexpensive to maintain and can provide very useful insights into the execution characteristics of a periodic task loop.  But it is just information.  The period statistics reported must be analyzed by the user in terms of what the applications is.  For example, in an application where priorities are assigned by the Rate Monotonic Algorithm, it would be very undesirable for high priority (i.e. frequency) tasks to miss their period.  Similarly, in nearly any application, if a task were supposed to execute its periodic loop every 10 milliseconds and it averaged 11 milliseconds, then application requirements are not being met."
rate-monotonic,"The information reported can be used to determine the “hot spots” in the application.  Given a period’s id, the user can determine the length of that period.  From that information and the CPU usage, the user can calculate the percentage of CPU time consumed by that periodic task.  For example, a task executing for 20 milliseconds every 200 milliseconds is consuming 10 percent of the processor’s execution time.  This is usually enough to make it a good candidate for optimization."
rate-monotonic,"However, execution time alone is not enough to gauge the value of optimizing a particular task.  It is more important to optimize a task executing 2 millisecond every 10 milliseconds (20 percent of the CPU) than one executing 10 milliseconds every 100 (10 percent of the CPU).  As a general rule of thumb, the higher frequency at which a task executes, the more important it is to optimize that task."
rate-monotonic,"A periodic task is one which must be executed at a regular interval.  The interval between successive iterations of the task is referred to as its period.  Periodic tasks can be characterized by the length of their period and execution time.  The period and execution time of a task can be used to determine the processor utilization for that task.  Processor utilization is the percentage of processor time used and can be calculated on a per-task or system-wide basis.  Typically, the task’s worst-case execution time will be less than its period.  For example, a periodic task’s requirements may state that it should execute for 10 milliseconds every 100 milliseconds.  Although the execution time may be the average, worst, or best case, the worst-case execution time is more appropriate for use when analyzing system behavior under transient overload conditions."
rate-monotonic,"In contrast, an aperiodic task executes at irregular intervals and has only a soft deadline.  In other words, the deadlines for aperiodic tasks are not rigid, but adequate response times are desirable.  For example, an aperiodic task may process user input from a terminal."
rate-monotonic,"Finally, a sporadic task is an aperiodic task with a hard deadline and minimum interarrival time.  The minimum interarrival time is the minimum period of time which exists between successive iterations of the task.  For example, a sporadic task could be used to process the pressing of a fire button on a joystick.  The mechanical action of the fire button ensures a minimum time period between successive activations, but the missile must be launched by a hard deadline."
rate-monotonic,"The Rate Monotonic Scheduling Algorithm (RMS) is important to real-time systems designers because it allows one to sufficiently guarantee that a set of tasks is schedulable (see [LL73], [LSD89], [SG90], [Bur91])."
rate-monotonic,A set of tasks is said to be schedulable if all of the tasks can meet their deadlines.  RMS provides a set of rules which can be used to perform a guaranteed schedulability analysis for a task set.  This analysis determines whether a task set is schedulable under worst-case conditions and emphasizes the predictability of the system’s behavior.  It has been proven that:
rate-monotonic,RMS
rate-monotonic,"RMS is an optimal fixed-priority algorithm for scheduling independent, preemptible, periodic tasks on a single processor."
rate-monotonic,"RMS is optimal in the sense that if a set of tasks can be scheduled by any fixed-priority algorithm, then RMS will be able to schedule that task set. RMS bases it schedulability analysis on the processor utilization level below which all deadlines can be met."
rate-monotonic,"RMS calls for the static assignment of task priorities based upon their period. The shorter a task’s period, the higher its priority.  For example, a task with a 1 millisecond period has higher priority than a task with a 100 millisecond period.  If two tasks have the same period, then RMS does not distinguish between the tasks.  However, RTEMS specifies that when given tasks of equal priority, the task which has been ready longest will execute first.  RMS’s priority assignment scheme does not provide one with exact numeric values for task priorities.  For example, consider the following task set and priority assignments:"
rate-monotonic,"Task Period
(in milliseconds) Priority 1 100 Low 2 50 Medium 3 50 Medium 4 25 High"
rate-monotonic,Task
rate-monotonic,Period (in milliseconds)
rate-monotonic,Priority
rate-monotonic,1
rate-monotonic,100
rate-monotonic,Low
rate-monotonic,2
rate-monotonic,50
rate-monotonic,Medium
rate-monotonic,3
rate-monotonic,50
rate-monotonic,Medium
rate-monotonic,4
rate-monotonic,25
rate-monotonic,High
rate-monotonic,"RMS only calls for task 1 to have the lowest priority, task 4 to have the highest priority, and tasks 2 and 3 to have an equal priority between that of tasks 1 and 4.  The actual RTEMS priorities assigned to the tasks must only adhere to those guidelines."
rate-monotonic,"Many applications have tasks with both hard and soft deadlines.  The tasks with hard deadlines are typically referred to as the critical task set, with the soft deadline tasks being the non-critical task set.  The critical task set can be scheduled using RMS, with the non-critical tasks not executing under transient overload, by simply assigning priorities such that the lowest priority critical task (i.e. longest period) has a higher priority than the highest priority non-critical task.  Although RMS may be used to assign priorities to the non-critical tasks, it is not necessary.  In this instance, schedulability is only guaranteed for the critical task set."
rate-monotonic,"RMS allows application designers to ensure that tasks can meet all deadlines under fixed-priority assignment, even under transient overload, without knowing exactly when any given task will execute by applying proven schedulability analysis rules."
rate-monotonic,The schedulability analysis rules for RMS were developed based on the following assumptions:
rate-monotonic,"The requests for all tasks for which hard deadlines exist are periodic, with a constant interval between requests. Each task must complete before the next request for it occurs. The tasks are independent in that a task does not depend on the initiation or completion of requests for other tasks. The execution time for each task without preemption or interruption is constant and does not vary. Any non-periodic tasks in the system are special.  These tasks should not displace periodic tasks while executing and do not have hard, critical deadlines."
rate-monotonic,"The requests for all tasks for which hard deadlines exist are periodic, with a constant interval between requests."
rate-monotonic,Each task must complete before the next request for it occurs.
rate-monotonic,The tasks are independent in that a task does not depend on the initiation or completion of requests for other tasks.
rate-monotonic,The execution time for each task without preemption or interruption is constant and does not vary.
rate-monotonic,"Any non-periodic tasks in the system are special.  These tasks should not displace periodic tasks while executing and do not have hard, critical deadlines."
rate-monotonic,"Once the basic schedulability analysis is understood, some of the above assumptions can be relaxed and the side-effects accounted for."
rate-monotonic,The Processor Utilization Rule requires that processor utilization be calculated based upon the period and execution time of each task. The fraction of processor time spent executing task index is Time(i) / Period(i).  The processor utilization can be calculated as follows where n is the number of tasks in the set being analyzed:
rate-monotonic,"To ensure schedulability even under transient overload, the processor utilization must adhere to the following rule:"
rate-monotonic,"As the number of tasks increases, the above formula approaches ln(2) for a worst-case utilization factor of approximately 0.693.  Many tasks sets can be scheduled with a greater utilization factor.  In fact, the average processor utilization threshold for a randomly generated task set is approximately 0.88. See more detail in [LL73]."
rate-monotonic,"This example illustrates the application of the Processor Utilization Rule to an application with three critical periodic tasks.  The following table details the RMS priority, period, execution time, and processor utilization for each task:"
rate-monotonic,"Task RMS
Priority Period Execution
Time Processor
Utilization 1 High 100 15 0.15 2 Medium 200 50 0.25 3 Low 300 100 0.33"
rate-monotonic,Task
rate-monotonic,RMS Priority
rate-monotonic,Period
rate-monotonic,Execution Time
rate-monotonic,Processor Utilization
rate-monotonic,1
rate-monotonic,High
rate-monotonic,100
rate-monotonic,15
rate-monotonic,0.15
rate-monotonic,2
rate-monotonic,Medium
rate-monotonic,200
rate-monotonic,50
rate-monotonic,0.25
rate-monotonic,3
rate-monotonic,Low
rate-monotonic,300
rate-monotonic,100
rate-monotonic,0.33
rate-monotonic,"The total processor utilization for this task set is 0.73 which is below the upper bound of 3 * (2**(1/3) - 1), or 0.779, imposed by the Processor Utilization Rule.  Therefore, this task set is guaranteed to be schedulable using RMS."
rate-monotonic,"If a given set of tasks do exceed the processor utilization upper limit imposed by the Processor Utilization Rule, they can still be guaranteed to meet all their deadlines by application of the First Deadline Rule.  This rule can be stated as follows:"
rate-monotonic,"For a given set of independent periodic tasks, if each task meets its first deadline when all tasks are started at the same time, then the deadlines will always be met for any combination of start times."
rate-monotonic,"A key point with this rule is that ALL periodic tasks are assumed to start at the exact same instant in time.  Although this assumption may seem to be invalid, RTEMS makes it quite easy to ensure.  By having a non-preemptible user initialization task, all application tasks, regardless of priority, can be created and started before the initialization deletes itself.  This technique ensures that all tasks begin to compete for execution time at the same instant - when the user initialization task deletes itself. See more detail in [LSD89]."
rate-monotonic,"The First Deadline Rule can ensure schedulability even when the Processor Utilization Rule fails.  The example below is a modification of the Processor Utilization Rule example where task execution time has been increased from 15 to 25 units.  The following table details the RMS priority, period, execution time, and processor utilization for each task:"
rate-monotonic,"Task RMS
Priority Period Execution
Time Processor
Utilization 1 High 100 25 0.25 2 Medium 200 50 0.25 3 Low 300 100 0.33"
rate-monotonic,Task
rate-monotonic,RMS Priority
rate-monotonic,Period
rate-monotonic,Execution Time
rate-monotonic,Processor Utilization
rate-monotonic,1
rate-monotonic,High
rate-monotonic,100
rate-monotonic,25
rate-monotonic,0.25
rate-monotonic,2
rate-monotonic,Medium
rate-monotonic,200
rate-monotonic,50
rate-monotonic,0.25
rate-monotonic,3
rate-monotonic,Low
rate-monotonic,300
rate-monotonic,100
rate-monotonic,0.33
rate-monotonic,"The total processor utilization for the modified task set is 0.83 which is above the upper bound of 3 * (2**(1/3) - 1), or 0.779, imposed by the Processor Utilization Rule.  Therefore, this task set is not guaranteed to be schedulable using RMS.  However, the First Deadline Rule can guarantee the schedulability of this task set.  This rule calls for one to examine each occurrence of deadline until either all tasks have met their deadline or one task failed to meet its first deadline.  The following table details the time of each deadline occurrence, the maximum number of times each task may have run, the total execution time, and whether all the deadlines have been met:"
rate-monotonic,"Deadline
Time Task
1 Task
2 Task
3 Total
Execution Time All Deadlines
Met? 100 1 1 1 25 + 50 + 100 = 175 NO 200 2 1 1 50 + 50 + 100 = 200 YES"
rate-monotonic,Deadline Time
rate-monotonic,Task 1
rate-monotonic,Task 2
rate-monotonic,Task 3
rate-monotonic,Total Execution Time
rate-monotonic,All Deadlines Met?
rate-monotonic,100
rate-monotonic,1
rate-monotonic,1
rate-monotonic,1
rate-monotonic,25 + 50 + 100 = 175
rate-monotonic,NO
rate-monotonic,200
rate-monotonic,2
rate-monotonic,1
rate-monotonic,1
rate-monotonic,50 + 50 + 100 = 200
rate-monotonic,YES
rate-monotonic,"The key to this analysis is to recognize when each task will execute.  For example at time 100, task 1 must have met its first deadline, but tasks 2 and 3 may also have begun execution.  In this example, at time 100 tasks 1 and 2 have completed execution and thus have met their first deadline.  Tasks 1 and 2 have used (25 + 50) = 75 time units, leaving (100 - 75) = 25 time units for task 3 to begin.  Because task 3 takes 100 ticks to execute, it will not have completed execution at time 100.  Thus at time 100, all of the tasks except task 3 have met their first deadline."
rate-monotonic,"At time 200, task 1 must have met its second deadline and task 2 its first deadline.  As a result, of the first 200 time units, task 1 uses (2 * 25) = 50 and task 2 uses 50, leaving (200 - 100) time units for task 3.  Task 3 requires 100 time units to execute, thus it will have completed execution at time 200. Thus, all of the tasks have met their first deadlines at time 200, and the task set is schedulable using the First Deadline Rule."
rate-monotonic,"The assumptions used to develop the RMS schedulability rules are uncommon in most real-time systems.  For example, it was assumed that tasks have constant unvarying execution time.  It is possible to relax this assumption, simply by using the worst-case execution time of each task."
rate-monotonic,"Another assumption is that the tasks are independent.  This means that the tasks do not wait for one another or contend for resources.  This assumption can be relaxed by accounting for the amount of time a task spends waiting to acquire resources.  Similarly, each task’s execution time must account for any I/O performed and any RTEMS directive calls."
rate-monotonic,"In addition, the assumptions did not account for the time spent executing interrupt service routines.  This can be accounted for by including all the processor utilization by interrupt service routines in the utilization calculation.  Similarly, one should also account for the impact of delays in accessing local memory caused by direct memory access and other processors accessing local dual-ported memory."
rate-monotonic,"The assumption that nonperiodic tasks are used only for initialization or failure-recovery can be relaxed by placing all periodic tasks in the critical task set.  This task set can be scheduled and analyzed using RMS.  All nonperiodic tasks are placed in the non-critical task set.  Although the critical task set can be guaranteed to execute even under transient overload, the non-critical task set is not guaranteed to execute."
rate-monotonic,"In conclusion, the application designer must be fully cognizant of the system and its run-time behavior when performing schedulability analysis for a system using RMS.  Every hardware and software factor which impacts the execution time of each task must be accounted for in the schedulability analysis."
rate-monotonic,"© Copyright 1988, 2024 RTEMS Project and contributors."
rate-monotonic,"The Rate-Monotonic Manager provides facilities to implement tasks which execute in a periodic fashion.  Critically, it also gathers information about the execution of those periods and can provide important statistics to the user which can be used to analyze and tune the application. The directives provided by the Rate-Monotonic Manager are:"
rate-monotonic,"rtems_rate_monotonic_create() - Creates a period. rtems_rate_monotonic_ident() - Identifies a period by the object name. rtems_rate_monotonic_cancel() - Cancels the period. rtems_rate_monotonic_delete() - Deletes the period. rtems_rate_monotonic_period() - Concludes the current period and start the next period, or gets the period status. rtems_rate_monotonic_get_status() - Gets the detailed status of the period. rtems_rate_monotonic_get_statistics() - Gets the statistics of the period. rtems_rate_monotonic_reset_statistics() - Resets the statistics of the period. rtems_rate_monotonic_reset_all_statistics() - Resets the statistics of all periods. rtems_rate_monotonic_report_statistics() - Reports the period statistics using the printk() printer. rtems_rate_monotonic_report_statistics_with_plugin() - Reports the period statistics using the printer plugin."
rate-monotonic,rtems_rate_monotonic_create() - Creates a period.
rate-monotonic,rtems_rate_monotonic_ident() - Identifies a period by the object name.
rate-monotonic,rtems_rate_monotonic_cancel() - Cancels the period.
rate-monotonic,rtems_rate_monotonic_delete() - Deletes the period.
rate-monotonic,"rtems_rate_monotonic_period() - Concludes the current period and start the next period, or gets the period status."
rate-monotonic,rtems_rate_monotonic_get_status() - Gets the detailed status of the period.
rate-monotonic,rtems_rate_monotonic_get_statistics() - Gets the statistics of the period.
rate-monotonic,rtems_rate_monotonic_reset_statistics() - Resets the statistics of the period.
rate-monotonic,rtems_rate_monotonic_reset_all_statistics() - Resets the statistics of all periods.
rate-monotonic,rtems_rate_monotonic_report_statistics() - Reports the period statistics using the printk() printer.
rate-monotonic,rtems_rate_monotonic_report_statistics_with_plugin() - Reports the period statistics using the printer plugin.
rate-monotonic,"© Copyright 1988, 2024 RTEMS Project and contributors."
rate-monotonic,The rtems_rate_monotonic_create directive creates a rate monotonic period which is to be used by the calling task to delineate a period.  RTEMS allocates a Period Control Block (PCB) from the PCB free list.  This data structure is used by RTEMS to manage the newly created rate monotonic period.  RTEMS returns a unique period ID to the application which is used by other rate monotonic manager directives to access this rate monotonic period.
rate-monotonic,"The rtems_rate_monotonic_period directive is used to establish and maintain periodic execution utilizing a previously created rate monotonic period.  Once initiated by the rtems_rate_monotonic_period directive, the period is said to run until it either expires or is reinitiated.  The state of the rate monotonic period results in one of the following scenarios:"
rate-monotonic,"If the rate monotonic period is running, the calling task will be blocked for the remainder of the outstanding period and, upon completion of that period, the period will be reinitiated with the specified period. If the rate monotonic period is not currently running and has not expired, it is initiated with a length of period ticks and the calling task returns immediately. If the rate monotonic period has expired before the task invokes the rtems_rate_monotonic_period directive, the postponed job will be released until there is no more postponed jobs. The calling task returns immediately with a timeout error status. In the watchdog routine, the period will still be updated periodically and track the count of the postponed jobs [CvdBruggenC16]. Please note, the count of the postponed jobs is only saturated until 0xffffffff."
rate-monotonic,"If the rate monotonic period is running, the calling task will be blocked for the remainder of the outstanding period and, upon completion of that period, the period will be reinitiated with the specified period."
rate-monotonic,"If the rate monotonic period is not currently running and has not expired, it is initiated with a length of period ticks and the calling task returns immediately."
rate-monotonic,"If the rate monotonic period has expired before the task invokes the rtems_rate_monotonic_period directive, the postponed job will be released until there is no more postponed jobs. The calling task returns immediately with a timeout error status. In the watchdog routine, the period will still be updated periodically and track the count of the postponed jobs [CvdBruggenC16]. Please note, the count of the postponed jobs is only saturated until 0xffffffff."
rate-monotonic,"If the rtems_rate_monotonic_period directive is invoked with a period of RTEMS_PERIOD_STATUS ticks, the current state of the specified rate monotonic period will be returned.  The following table details the relationship between the period’s status and the directive status code returned by the rtems_rate_monotonic_period directive:"
rate-monotonic,RTEMS_SUCCESSFUL period is running RTEMS_TIMEOUT period has expired RTEMS_NOT_DEFINED period has never been initiated
rate-monotonic,RTEMS_SUCCESSFUL
rate-monotonic,period is running
rate-monotonic,RTEMS_TIMEOUT
rate-monotonic,period has expired
rate-monotonic,RTEMS_NOT_DEFINED
rate-monotonic,period has never been initiated
rate-monotonic,Obtaining the status of a rate monotonic period does not alter the state or length of that period.
rate-monotonic,The rtems_rate_monotonic_cancel directive is used to stop the period maintained by the specified rate monotonic period.  The period is stopped and the rate monotonic period can be reinitiated using the rtems_rate_monotonic_period directive.
rate-monotonic,"The rtems_rate_monotonic_delete directive is used to delete a rate monotonic period.  If the period is running and has not expired, the period is automatically canceled.  The rate monotonic period’s control block is returned to the PCB free list when it is deleted.  A rate monotonic period can be deleted by a task other than the task which created the period."
rate-monotonic,The following sections illustrate common uses of rate monotonic periods to construct periodic tasks.
rate-monotonic,"This example consists of a single periodic task which, after initialization, executes every 100 clock ticks."
rate-monotonic,"The above task creates a rate monotonic period as part of its initialization. The first time the loop is executed, the rtems_rate_monotonic_period directive will initiate the period for 100 ticks and return immediately. Subsequent invocations of the rtems_rate_monotonic_period directive will result in the task blocking for the remainder of the 100 tick period.  If, for any reason, the body of the loop takes more than 100 ticks to execute, the rtems_rate_monotonic_period directive will return the RTEMS_TIMEOUT status. If the above task misses its deadline, it will delete the rate monotonic period and itself."
rate-monotonic,"This example consists of a single periodic task which, after initialization, performs two sets of actions every 100 clock ticks.  The first set of actions is performed in the first forty clock ticks of every 100 clock ticks, while the second set of actions is performed between the fortieth and seventieth clock ticks.  The last thirty clock ticks are not used by this task."
rate-monotonic,"The above task creates two rate monotonic periods as part of its initialization.  The first time the loop is executed, the rtems_rate_monotonic_period directive will initiate the period_1 period for 100 ticks and return immediately.  Subsequent invocations of the rtems_rate_monotonic_period directive for period_1 will result in the task blocking for the remainder of the 100 tick period.  The period_2 period is used to control the execution time of the two sets of actions within each 100 tick period established by period_1.  The rtems_rate_monotonic_cancel( period_2 ) call is performed to ensure that the period_2 period does not expire while the task is blocked on the period_1 period.  If this cancel operation were not performed, every time the rtems_rate_monotonic_period( period_2, 40 ) call is executed, except for the initial one, a directive status of RTEMS_TIMEOUT is returned.  It is important to note that every time this call is made, the period_2 period will be initiated immediately and the task will not block."
rate-monotonic,"If, for any reason, the task misses any deadline, the rtems_rate_monotonic_period directive will return the RTEMS_TIMEOUT directive status. If the above task misses its deadline, it will delete the rate monotonic periods and itself."
rate-monotonic,"© Copyright 1988, 2024 RTEMS Project and contributors."
region,"A region makes up a physically contiguous memory space with user-defined boundaries from which variable-sized segments are dynamically allocated and deallocated.  A segment is a variable size section of memory which is allocated in multiples of a user-defined page size.  This page size is required to be a multiple of four greater than or equal to four.  For example, if a request for a 350-byte segment is made in a region with 256-byte pages, then a 512-byte segment is allocated."
region,"Regions are organized as doubly linked chains of variable sized memory blocks. Memory requests are allocated using a first-fit algorithm.  If available, the requester receives the number of bytes requested (rounded up to the next page size).  RTEMS requires some overhead from the region’s memory for each segment that is allocated.  Therefore, an application should only modify the memory of a segment that has been obtained from the region.  The application should NOT modify the memory outside of any obtained segments and within the region’s boundaries while the region is currently active in the system."
region,"Upon return to the region, the free block is coalesced with its neighbors (if free) on both sides to produce the largest possible unused block."
region,"In general, an attribute set is built by a bitwise OR of the desired attribute components.  The set of valid region attributes is provided in the following table:"
region,RTEMS_FIFO tasks wait by FIFO (default) RTEMS_PRIORITY tasks wait by priority
region,RTEMS_FIFO
region,tasks wait by FIFO (default)
region,RTEMS_PRIORITY
region,tasks wait by priority
region,"Attribute values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each attribute appears exactly once in the component list.  An attribute listed as a default is not required to appear in the attribute list, although it is a good programming practice to specify default attributes.  If all defaults are desired, the attribute RTEMS_DEFAULT_ATTRIBUTES should be specified on this call."
region,This example demonstrates the attribute_set parameter needed to create a region with the task priority waiting queue discipline.  The attribute_set parameter to the rtems_region_create directive should be RTEMS_PRIORITY.
region,"In general, an option is built by a bitwise OR of the desired option components.  The set of valid options for the rtems_region_get_segment directive are listed in the following table:"
region,RTEMS_WAIT task will wait for segment (default) RTEMS_NO_WAIT task should not wait
region,RTEMS_WAIT
region,task will wait for segment (default)
region,RTEMS_NO_WAIT
region,task should not wait
region,"Option values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each option appears exactly once in the component list.  An option listed as a default is not required to appear in the option list, although it is a good programming practice to specify default options.  If all defaults are desired, the option RTEMS_DEFAULT_OPTIONS should be specified on this call."
region,This example demonstrates the option parameter needed to poll for a segment. The option parameter passed to the rtems_region_get_segment directive should be RTEMS_NO_WAIT.
region,"© Copyright 1988, 2024 RTEMS Project and contributors."
region,The Region Manager provides facilities to dynamically allocate memory in variable sized units. The directives provided by the Region Manager are:
region,rtems_region_create() - Creates a region. rtems_region_ident() - Identifies a region by the object name. rtems_region_delete() - Deletes the region. rtems_region_extend() - Extends the region. rtems_region_get_segment() - Gets a segment from the region. rtems_region_return_segment() - Returns the segment to the region. rtems_region_resize_segment() - Changes the size of the segment. rtems_region_get_information() - Gets the region information. rtems_region_get_free_information() - Gets the region free information. rtems_region_get_segment_size() - Gets the size of the region segment.
region,rtems_region_create() - Creates a region.
region,rtems_region_ident() - Identifies a region by the object name.
region,rtems_region_delete() - Deletes the region.
region,rtems_region_extend() - Extends the region.
region,rtems_region_get_segment() - Gets a segment from the region.
region,rtems_region_return_segment() - Returns the segment to the region.
region,rtems_region_resize_segment() - Changes the size of the segment.
region,rtems_region_get_information() - Gets the region information.
region,rtems_region_get_free_information() - Gets the region free information.
region,rtems_region_get_segment_size() - Gets the size of the region segment.
region,"© Copyright 1988, 2024 RTEMS Project and contributors."
region,The rtems_region_create directive creates a region with the user-defined name.  The user may select FIFO or task priority as the method for placing waiting tasks in the task wait queue.  RTEMS allocates a Region Control Block (RNCB) from the RNCB free list to maintain the newly created region.  RTEMS also generates a unique region ID which is returned to the calling task.
region,"It is not possible to calculate the exact number of bytes available to the user since RTEMS requires overhead for each segment allocated.  For example, a region with one segment that is the size of the entire region has more available bytes than a region with two segments that collectively are the size of the entire region.  This is because the region with one segment requires only the overhead for one segment, while the other region requires the overhead for two segments."
region,"Due to automatic coalescing, the number of segments in the region dynamically changes.  Therefore, the total overhead required by RTEMS dynamically changes."
region,"When a region is created, RTEMS generates a unique region ID and assigns it to the created region until it is deleted.  The region ID may be obtained by either of two methods.  First, as the result of an invocation of the rtems_region_create directive, the region ID is stored in a user provided location.  Second, the region ID may be obtained later using the rtems_region_ident directive.  The region ID is used by other region manager directives to access this region."
region,The rtems_region_extend directive may be used to add memory to an existing region.  The caller specifies the size in bytes and starting address of the memory being added.
region,"The rtems_region_get_segment directive attempts to acquire a segment from a specified region.  If the region has enough available free memory, then a segment is returned successfully to the caller.  When the segment cannot be allocated, one of the following situations applies:"
region,"By default, the calling task will wait forever to acquire the segment. Specifying the RTEMS_NO_WAIT option forces an immediate return with an error status code. Specifying a timeout limits the interval the task will wait before returning with an error status code."
region,"By default, the calling task will wait forever to acquire the segment."
region,Specifying the RTEMS_NO_WAIT option forces an immediate return with an error status code.
region,Specifying a timeout limits the interval the task will wait before returning with an error status code.
region,"If the task waits for the segment, then it is placed in the region’s task wait queue in either FIFO or task priority order.  All tasks waiting on a region are returned an error when the message queue is deleted."
region,"When a segment is returned to a region by the rtems_region_return_segment directive, it is merged with its unallocated neighbors to form the largest possible segment.  The first task on the wait queue is examined to determine if its segment request can now be satisfied.  If so, it is given a segment and unblocked.  This process is repeated until the first task’s segment request cannot be satisfied."
region,The rtems_region_get_segment_size directive returns the size in bytes of the specified segment.  The size returned includes any “extra” memory included in the segment because of rounding up to a page size boundary.
region,"The rtems_region_resize_segment directive is used to change the size in bytes of the specified segment.  The size may be increased or decreased.  When increasing the size of a segment, it is possible that the request cannot be satisfied.  This directive provides functionality similar to the realloc() function in the Standard C Library."
region,"A region can be removed from the system and returned to RTEMS with the rtems_region_delete directive.  When a region is deleted, its control block is returned to the RNCB free list.  A region with segments still allocated is not allowed to be deleted.  Any task attempting to do so will be returned an error.  As a result of this directive, all tasks blocked waiting to obtain a segment from the region will be readied and returned a status code which indicates that the region was deleted."
region,"© Copyright 1988, 2024 RTEMS Project and contributors."
regulator,"The regulator provides facilities to accept bursty input and buffer it as needed before delivering it at a pre-defined periodic rate. The input is referred to as the Source, with the output referred to as the Destination. Messages are accepted from the Source and delivered to the Destination by a user-provided Delivery function."
regulator,The Regulator implementation uses the RTEMS Classic API Partition Manager to manage the buffer pool and the RTEMS Classic API Message Queue Manager to send the buffer to the Delivery thread. The Delivery thread invokes a user-provided delivery function to get the message to the Destination.
regulator,"The regulator is designed to sit logically between two entities – a source and a destination, where it limits the traffic sent to the destination to prevent it from being flooded with messages from the source. This can be used to accommodate bursts of input from a source and meter it out to a destination.  The maximum number of messages which can be buffered in the regulator is specified by the maximum_messages field in the rtems_regulator_attributes structure passed as an argument to rtems_regulator_create()."
regulator,"The regulator library accepts an input stream of messages from a source and delivers them to a destination. The regulator assumes that the input stream from the source contains sporadic bursts of data which can exceed the acceptable rate of the destination. By limiting the message rate, the regulator prevents an overflow of messages."
regulator,"The regulator can be configured for the input buffering required to manage the maximum burst and for the metering rate for the delivery. The delivery rate is in messages per second. If the sender produces data too fast, the regulator will buffer the configured number of messages."
regulator,"A configuration capability is provided to allow for adaptation to different message streams. The regulator can also support running multiple instances, which could be used on independent message streams."
regulator,"It is assumed that the application has a design limit on the number of messages which may be buffered. All messages accepted by the regulator, assuming no overflow on input, will eventually be output by the Delivery thread."
regulator,The Source sends buffers to the Regulator instance. The Regulator then sends the buffer via a message queue which delivers them to the Delivery thread.  The Delivery thread executes periodically at a rate specified by the delivery_thread_period field in the rtems_regulator_attributes structure passed as an argument to rtems_regulator_create().
regulator,"During each period, the Delivery thread attempts to receive up to maximum_to_dequeue_per_period number of buffers and invoke the Delivery function to deliver each of them to the Destination. The maximum_to_dequeue_per_period field in the rtems_regulator_attributes structure passed as an argument to rtems_regulator_create()."
regulator,"For example, consider a Source that may produce a burst of up to seven messages every five seconds. But the Destination cannot handle a burst of seven and either drops messages or gives an error. This can be accommodated by a Regulator instance configured as follows:"
regulator,maximum_messages - 7 delivery_thread_period - one second maximum_to_dequeue_per_period - 3
regulator,maximum_messages - 7
regulator,delivery_thread_period - one second
regulator,maximum_to_dequeue_per_period - 3
regulator,"In this scenario, the application will use the Delivery thread rtems_regulator_send() to enqueue the seven messages when they arrive. The Delivery thread will deliver three messages per second. The following illustrates this sequence:"
regulator,Time 0: Source sends seven messages Time 1: Delivery of messages 1 to 3 Time 3: Delivery of messages 4 to 6 Time 3: Delivery of message 7 Time 4: No messages to deliver
regulator,Time 0: Source sends seven messages
regulator,Time 1: Delivery of messages 1 to 3
regulator,Time 3: Delivery of messages 4 to 6
regulator,Time 3: Delivery of message 7
regulator,Time 4: No messages to deliver
regulator,This configuration of the regulator ensures that the Destination does not overflow.
regulator,"© Copyright 1988, 2024 RTEMS Project and contributors."
regulator,The Regulator Manager provides a set of directives to manage a data flow from a source to a destination. The focus is on regulating the bursty input so that it is delivered to the destination at a regular rate. The directives provided by the Regulator Manager are:
regulator,rtems_regulator_create() - Creates a regulator. rtems_regulator_delete() - Deletes the regulator. rtems_regulator_obtain_buffer() - Obtain buffer from a regulator. rtems_regulator_release_buffer() - Release buffer to a regulator. rtems_regulator_send() - Send buffer to a regulator. rtems_regulator_get_statistics() - Obtain statistics for a regulator.
regulator,rtems_regulator_create() - Creates a regulator.
regulator,rtems_regulator_delete() - Deletes the regulator.
regulator,rtems_regulator_obtain_buffer() - Obtain buffer from a regulator.
regulator,rtems_regulator_release_buffer() - Release buffer to a regulator.
regulator,rtems_regulator_send() - Send buffer to a regulator.
regulator,rtems_regulator_get_statistics() - Obtain statistics for a regulator.
regulator,"© Copyright 1988, 2024 RTEMS Project and contributors."
regulator,"The application interacting with the Source will obtain buffers from the regulator instance, fill them with information, and send them to the regulator instance. This allows the regulator to buffer bursty input."
regulator,A regulator instance is used as follows from the Source side:
regulator,The delivery of message buffers to the Destination and subsequent release is performed in the context of the delivery thread by either the delivery function or delivery thread. Details are below.
regulator,"The sequence diagram below shows the interaction between a message Source, a Regulator instance, and RTEMS, given the usage described in the above paragraphs."
regulator,"As illustrated in the preceding sequence diagram, the Source usually corresponds to application software reading a system input. The Source obtains a buffer from the Regulator instance and fills it with incoming data.  The application explicitly obtaining a buffer and filling it in allows for zero copy operations on the Source side."
regulator,"After the Source has sent the message to the Regulator instance, the Source is free to process another input and the Regulator instance will ensure that the buffer is delivered to the Delivery function and Destination."
regulator,"The Delivery function is provided by the application for a specific Regulator instance. Depending on the Destination, it may use a function which copies the buffer contents (e.g., write()) or which operates directly on the buffer contents (e.g. DMA from buffer). In the case of a Destination which copies the buffer contents, the buffer can be released via  rtems_regulator_release_buffer()  as soon as the function or copying completes. In the case where the delivery uses the buffer and returns, the call to rtems_regulator_release_buffer() will occur when the use of the buffer is complete (e.g. completion of DMA transfer).  This explicit and deliberate exposure of buffering provides the application with the ability to avoid copying the contents."
regulator,"© Copyright 1988, 2024 RTEMS Project and contributors."
scheduling-concepts,"RTEMS provides a plugin framework that allows it to support multiple scheduling algorithms. RTEMS includes multiple scheduling algorithms, and the user can select which of these they wish to use in their application at link-time.  In addition, the user can implement their own scheduling algorithm and configure RTEMS to use it."
scheduling-concepts,"Supporting multiple scheduling algorithms gives the end user the option to select the algorithm which is most appropriate to their use case. Most real-time operating systems schedule tasks using a priority based algorithm, possibly with preemption control.  The classic RTEMS scheduling algorithm which was the only algorithm available in RTEMS 4.10 and earlier, is a fixed-priority scheduling algorithm.  This scheduling algorithm is suitable for uniprocessor (e.g., non-SMP) systems and is known as the Deterministic Priority Scheduler.  Unless the user configures another scheduling algorithm, RTEMS will use this on uniprocessor systems."
scheduling-concepts,"When using priority based scheduling, RTEMS allocates the processor using a priority-based, preemptive algorithm augmented to provide round-robin characteristics within individual priority groups.  The goal of this algorithm is to guarantee that the task which is executing on the processor at any point in time is the one with the highest priority among all tasks in the ready state."
scheduling-concepts,"When a task is added to the ready chain, it is placed behind all other tasks of the same priority.  This rule provides a round-robin within a priority group scheduling characteristic.  This means that in a group of equal priority tasks, tasks will execute in the order they become ready or FIFO order.  Even though there are ways to manipulate and adjust task priorities, the most important rule to remember is:"
scheduling-concepts,Note
scheduling-concepts,Priority based scheduling algorithms will always select the highest priority task that is ready to run when allocating the processor to a task.
scheduling-concepts,"Priority scheduling is the most commonly used scheduling algorithm.  It should be used by applications in which multiple tasks contend for CPU time or other resources, and there is a need to ensure certain tasks are given priority over other tasks."
scheduling-concepts,There are a few common methods of accomplishing the mechanics of this algorithm.  These ways involve a list or chain of tasks in the ready state.
scheduling-concepts,"The least efficient method is to randomly place tasks in the ready chain forcing the scheduler to scan the entire chain to determine which task receives the processor. A more efficient method is to schedule the task by placing it in the proper place on the ready chain based on the designated scheduling criteria at the time it enters the ready state.  Thus, when the processor is free, the first task on the ready chain is allocated the processor. Another mechanism is to maintain a list of FIFOs per priority.  When a task is readied, it is placed on the rear of the FIFO for its priority.  This method is often used with a bitmap to assist in locating which FIFOs have ready tasks on them.  This data structure has \(O(1)\) insert, extract and find highest ready run-time complexities. A red-black tree may be used for the ready queue with the priority as the key.  This data structure has \(O(log(n))\) insert, extract and find highest ready run-time complexities while \(n\) is the count of tasks in the ready queue."
scheduling-concepts,The least efficient method is to randomly place tasks in the ready chain forcing the scheduler to scan the entire chain to determine which task receives the processor.
scheduling-concepts,"A more efficient method is to schedule the task by placing it in the proper place on the ready chain based on the designated scheduling criteria at the time it enters the ready state.  Thus, when the processor is free, the first task on the ready chain is allocated the processor."
scheduling-concepts,"Another mechanism is to maintain a list of FIFOs per priority.  When a task is readied, it is placed on the rear of the FIFO for its priority.  This method is often used with a bitmap to assist in locating which FIFOs have ready tasks on them.  This data structure has \(O(1)\) insert, extract and find highest ready run-time complexities."
scheduling-concepts,"A red-black tree may be used for the ready queue with the priority as the key.  This data structure has \(O(log(n))\) insert, extract and find highest ready run-time complexities while \(n\) is the count of tasks in the ready queue."
scheduling-concepts,RTEMS currently includes multiple priority based scheduling algorithms as well as other algorithms that incorporate deadline.  Each algorithm is discussed in the following sections.
scheduling-concepts,RTEMS provides four mechanisms which allow the user to alter the task scheduling decisions:
scheduling-concepts,user-selectable task priority level task preemption control task timeslicing control manual round-robin selection
scheduling-concepts,user-selectable task priority level
scheduling-concepts,task preemption control
scheduling-concepts,task timeslicing control
scheduling-concepts,manual round-robin selection
scheduling-concepts,"Each of these methods provides a powerful capability to customize sets of tasks to satisfy the unique and particular requirements encountered in custom real-time applications.  Although each mechanism operates independently, there is a precedence relationship which governs the effects of scheduling modifications.  The evaluation order for scheduling characteristics is always priority, preemption mode, and timeslicing.  When reading the descriptions of timeslicing and manual round-robin it is important to keep in mind that preemption (if enabled) of a task by higher priority tasks will occur as required, overriding the other factors presented in the description."
scheduling-concepts,"The most significant task scheduling modification mechanism is the ability for the user to assign a priority level to each individual task when it is created and to alter a task’s priority at run-time, see Task Priority."
scheduling-concepts,"Another way the user can alter the basic scheduling algorithm is by manipulating the preemption mode flag (RTEMS_PREEMPT_MASK) of individual tasks.  If preemption is disabled for a task (RTEMS_NO_PREEMPT), then the task will not relinquish control of the processor until it terminates, blocks, or re-enables preemption.  Even tasks which become ready to run and possess higher priority levels will not be allowed to execute.  Note that the preemption setting has no effect on the manner in which a task is scheduled. It only applies once a task has control of the processor."
scheduling-concepts,"Timeslicing or round-robin scheduling is an additional method which can be used to alter the basic scheduling algorithm.  Like preemption, timeslicing is specified on a task by task basis using the timeslicing mode flag (RTEMS_TIMESLICE_MASK).  If timeslicing is enabled for a task (RTEMS_TIMESLICE), then RTEMS will limit the amount of time the task can execute before the processor is allocated to another task.  Each tick of the real-time clock reduces the currently running task’s timeslice.  When the execution time equals the timeslice, RTEMS will dispatch another task of the same priority to execute.  If there are no other tasks of the same priority ready to execute, then the current task is allocated an additional timeslice and continues to run.  Remember that a higher priority task will preempt the task (unless preemption is disabled) as soon as it is ready to run, even if the task has not used up its entire timeslice."
scheduling-concepts,"The final mechanism for altering the RTEMS scheduling algorithm is called manual round-robin.  Manual round-robin is invoked by using the rtems_task_wake_after directive with a ticks parameter of RTEMS_YIELD_PROCESSOR.  This allows a task to give up the processor and be immediately returned to the ready chain at the end of its priority group.  If no other tasks of the same priority are ready to run, then the task does not lose control of the processor."
scheduling-concepts,"The dispatcher is the RTEMS component responsible for allocating the processor to a ready task.  In order to allocate the processor to one task, it must be deallocated or retrieved from the task currently using it.  This involves a concept called a context switch.  To perform a context switch, the dispatcher saves the context of the current task and restores the context of the task which has been allocated to the processor.  Saving and restoring a task’s context is the storing/loading of all the essential information about a task to enable it to continue execution without any effects of the interruption.  For example, the contents of a task’s register set must be the same when it is given the processor as they were when it was taken away.  All of the information that must be saved or restored for a context switch is located either in the TCB or on the task’s stacks."
scheduling-concepts,"Tasks that utilize a numeric coprocessor and are created with the RTEMS_FLOATING_POINT attribute require additional operations during a context switch.  These additional operations are necessary to save and restore the floating point context of RTEMS_FLOATING_POINT tasks.  To avoid unnecessary save and restore operations, the state of the numeric coprocessor is only saved when a RTEMS_FLOATING_POINT task is dispatched and that task was not the last task to utilize the coprocessor."
scheduling-concepts,"Tasks in an RTEMS system must always be in one of the five allowable task states.  These states are: executing, ready, blocked, dormant, and non-existent."
scheduling-concepts,"A task occupies the non-existent state before a rtems_task_create has been issued on its behalf.  A task enters the non-existent state from any other state in the system when it is deleted with the rtems_task_delete directive.  While a task occupies this state it does not have a TCB or a task ID assigned to it; therefore, no other tasks in the system may reference this task."
scheduling-concepts,"When a task is created via the rtems_task_create directive, it enters the dormant state.  This state is not entered through any other means.  Although the task exists in the system, it cannot actively compete for system resources. It will remain in the dormant state until it is started via the rtems_task_start directive, at which time it enters the ready state.  The task is now permitted to be scheduled for the processor and to compete for other system resources."
scheduling-concepts,A task occupies the blocked state whenever it is unable to be scheduled to run. A running task may block itself or be blocked by other tasks in the system. The running task blocks itself through voluntary operations that cause the task to wait.  The only way a task can block a task other than itself is with the rtems_task_suspend directive.  A task enters the blocked state due to any of the following conditions:
scheduling-concepts,"A task issues a rtems_task_suspend directive which blocks either itself or another task in the system. The running task issues a rtems_barrier_wait directive. The running task issues a rtems_message_queue_receive directive with the wait option, and the message queue is empty. The running task issues a rtems_event_receive directive with the wait option, and the currently pending events do not satisfy the request. The running task issues a rtems_semaphore_obtain directive with the wait option and the requested semaphore is unavailable. The running task issues a rtems_task_wake_after directive which blocks the task for the given count of ticks.  If the count of ticks specified is zero, the task yields the processor and remains in the ready state. The running task issues a rtems_task_wake_when directive which blocks the task until the requested date and time arrives. The running task issues a rtems_rate_monotonic_period directive and must wait for the specified rate monotonic period to conclude. The running task issues a rtems_region_get_segment directive with the wait option and there is not an available segment large enough to satisfy the task’s request."
scheduling-concepts,A task issues a rtems_task_suspend directive which blocks either itself or another task in the system.
scheduling-concepts,The running task issues a rtems_barrier_wait directive.
scheduling-concepts,"The running task issues a rtems_message_queue_receive directive with the wait option, and the message queue is empty."
scheduling-concepts,"The running task issues a rtems_event_receive directive with the wait option, and the currently pending events do not satisfy the request."
scheduling-concepts,The running task issues a rtems_semaphore_obtain directive with the wait option and the requested semaphore is unavailable.
scheduling-concepts,"The running task issues a rtems_task_wake_after directive which blocks the task for the given count of ticks.  If the count of ticks specified is zero, the task yields the processor and remains in the ready state."
scheduling-concepts,The running task issues a rtems_task_wake_when directive which blocks the task until the requested date and time arrives.
scheduling-concepts,The running task issues a rtems_rate_monotonic_period directive and must wait for the specified rate monotonic period to conclude.
scheduling-concepts,The running task issues a rtems_region_get_segment directive with the wait option and there is not an available segment large enough to satisfy the task’s request.
scheduling-concepts,"A blocked task may also be suspended.  Therefore, both the suspension and the blocking condition must be removed before the task becomes ready to run again."
scheduling-concepts,"A task occupies the ready state when it is able to be scheduled to run, but currently does not have control of the processor.  Tasks of the same or higher priority will yield the processor by either becoming blocked, completing their timeslice, or being deleted.  All tasks with the same priority will execute in FIFO order.  A task enters the ready state due to any of the following conditions:"
scheduling-concepts,"A running task issues a rtems_task_resume directive for a task that is suspended and the task is not blocked waiting on any resource. A running task issues a rtems_message_queue_send, rtems_message_queue_broadcast, or a rtems_message_queue_urgent directive which posts a message to the queue on which the blocked task is waiting. A running task issues an rtems_event_send directive which sends an event condition to a task that is blocked waiting on that event condition. A running task issues a rtems_semaphore_release directive which releases the semaphore on which the blocked task is waiting. The requested count of ticks has elapsed for a task which was blocked by a call to the rtems_task_wake_after directive. A timeout period expires for a task which blocked by a call to the rtems_task_wake_when directive. A running task issues a rtems_region_return_segment directive which releases a segment to the region on which the blocked task is waiting and a resulting segment is large enough to satisfy the task’s request. A rate monotonic period expires for a task which blocked by a call to the rtems_rate_monotonic_period directive. A timeout interval expires for a task which was blocked waiting on a message, event, semaphore, or segment with a timeout specified. A running task issues a directive which deletes a message queue, a semaphore, or a region on which the blocked task is waiting. A running task issues a rtems_task_restart directive for the blocked task. The running task, with its preemption mode enabled, may be made ready by issuing any of the directives that may unblock a task with a higher priority. This directive may be issued from the running task itself or from an ISR.  A ready task occupies the executing state when it has control of the CPU.  A task enters the executing state due to any of the following conditions: The task is the highest priority ready task in the system. The running task blocks and the task is next in the scheduling queue.  The task may be of equal priority as in round-robin scheduling or the task may possess the highest priority of the remaining ready tasks. The running task may reenable its preemption mode and a task exists in the ready queue that has a higher priority than the running task. The running task lowers its own priority and another task is of higher priority as a result. The running task raises the priority of a task above its own and the running task is in preemption mode."
scheduling-concepts,A running task issues a rtems_task_resume directive for a task that is suspended and the task is not blocked waiting on any resource.
scheduling-concepts,"A running task issues a rtems_message_queue_send, rtems_message_queue_broadcast, or a rtems_message_queue_urgent directive which posts a message to the queue on which the blocked task is waiting."
scheduling-concepts,A running task issues an rtems_event_send directive which sends an event condition to a task that is blocked waiting on that event condition.
scheduling-concepts,A running task issues a rtems_semaphore_release directive which releases the semaphore on which the blocked task is waiting.
scheduling-concepts,The requested count of ticks has elapsed for a task which was blocked by a call to the rtems_task_wake_after directive.
scheduling-concepts,A timeout period expires for a task which blocked by a call to the rtems_task_wake_when directive.
scheduling-concepts,A running task issues a rtems_region_return_segment directive which releases a segment to the region on which the blocked task is waiting and a resulting segment is large enough to satisfy the task’s request.
scheduling-concepts,A rate monotonic period expires for a task which blocked by a call to the rtems_rate_monotonic_period directive.
scheduling-concepts,"A timeout interval expires for a task which was blocked waiting on a message, event, semaphore, or segment with a timeout specified."
scheduling-concepts,"A running task issues a directive which deletes a message queue, a semaphore, or a region on which the blocked task is waiting."
scheduling-concepts,A running task issues a rtems_task_restart directive for the blocked task.
scheduling-concepts,"The running task, with its preemption mode enabled, may be made ready by issuing any of the directives that may unblock a task with a higher priority. This directive may be issued from the running task itself or from an ISR.  A ready task occupies the executing state when it has control of the CPU.  A task enters the executing state due to any of the following conditions:"
scheduling-concepts,The task is the highest priority ready task in the system.
scheduling-concepts,The running task blocks and the task is next in the scheduling queue.  The task may be of equal priority as in round-robin scheduling or the task may possess the highest priority of the remaining ready tasks.
scheduling-concepts,The running task may reenable its preemption mode and a task exists in the ready queue that has a higher priority than the running task.
scheduling-concepts,The running task lowers its own priority and another task is of higher priority as a result.
scheduling-concepts,The running task raises the priority of a task above its own and the running task is in preemption mode.
scheduling-concepts,"© Copyright 1988, 2024 RTEMS Project and contributors."
scheduling-concepts,The scheduling concepts relate to the allocation of processing time for tasks.
scheduling-concepts,"The concept of scheduling in real-time systems dictates the ability to provide an immediate response to specific external events, particularly the necessity of scheduling tasks to run within a specified time limit after the occurrence of an event. For example, software embedded in life-support systems used to monitor hospital patients must take instant action if a change in the patient’s status is detected."
scheduling-concepts,The component of RTEMS responsible for providing this capability is appropriately called the scheduler. The scheduler’s sole purpose is to allocate the all important resource of processor time to the various tasks competing for attention. The directives provided by the Scheduler Manager are:
scheduling-concepts,rtems_scheduler_ident() - Identifies a scheduler by the object name. rtems_scheduler_ident_by_processor() - Identifies a scheduler by the processor index. rtems_scheduler_ident_by_processor_set() - Identifies a scheduler by the processor set. rtems_scheduler_get_maximum_priority() - Gets the maximum task priority of the scheduler. rtems_scheduler_map_priority_to_posix() - Maps a Classic API task priority to the corresponding POSIX thread priority. rtems_scheduler_map_priority_from_posix() - Maps a POSIX thread priority to the corresponding Classic API task priority. rtems_scheduler_get_processor() - Returns the index of the current processor. rtems_scheduler_get_processor_maximum() - Returns the processor maximum supported by the system. rtems_scheduler_get_processor_set() - Gets the set of processors owned by the scheduler. rtems_scheduler_add_processor() - Adds the processor to the set of processors owned by the scheduler. rtems_scheduler_remove_processor() - Removes the processor from the set of processors owned by the scheduler.
scheduling-concepts,rtems_scheduler_ident() - Identifies a scheduler by the object name.
scheduling-concepts,rtems_scheduler_ident_by_processor() - Identifies a scheduler by the processor index.
scheduling-concepts,rtems_scheduler_ident_by_processor_set() - Identifies a scheduler by the processor set.
scheduling-concepts,rtems_scheduler_get_maximum_priority() - Gets the maximum task priority of the scheduler.
scheduling-concepts,rtems_scheduler_map_priority_to_posix() - Maps a Classic API task priority to the corresponding POSIX thread priority.
scheduling-concepts,rtems_scheduler_map_priority_from_posix() - Maps a POSIX thread priority to the corresponding Classic API task priority.
scheduling-concepts,rtems_scheduler_get_processor() - Returns the index of the current processor.
scheduling-concepts,rtems_scheduler_get_processor_maximum() - Returns the processor maximum supported by the system.
scheduling-concepts,rtems_scheduler_get_processor_set() - Gets the set of processors owned by the scheduler.
scheduling-concepts,rtems_scheduler_add_processor() - Adds the processor to the set of processors owned by the scheduler.
scheduling-concepts,rtems_scheduler_remove_processor() - Removes the processor from the set of processors owned by the scheduler.
scheduling-concepts,"© Copyright 1988, 2024 RTEMS Project and contributors."
semaphore,"A semaphore can be viewed as a protected variable whose value can be modified only with the rtems_semaphore_create, rtems_semaphore_obtain, and rtems_semaphore_release directives.  RTEMS supports both binary and counting semaphores. A binary semaphore is restricted to values of zero or one, while a counting semaphore can assume any non-negative integer value."
semaphore,"A binary semaphore (not a simple binary semaphore) can be used to control access to a single resource.  In particular, it can be used to enforce mutual exclusion for a critical section in user code (mutex).  In this instance, the semaphore would be created with an initial count of one to indicate that no task is executing the critical section of code.  Upon entry to the critical section, a task must issue the rtems_semaphore_obtain directive to prevent other tasks from entering the critical section.  Upon exit from the critical section, the task that obtained the binary semaphore must issue the rtems_semaphore_release directive to allow another task to execute the critical section.  A binary semaphore must be released by the task that obtained it."
semaphore,"A counting semaphore can be used to control access to a pool of two or more resources.  For example, access to three printers could be administered by a semaphore created with an initial count of three.  When a task requires access to one of the printers, it issues the rtems_semaphore_obtain directive to obtain access to a printer.  If a printer is not currently available, the task can wait for a printer to become available or return immediately.  When the task has completed printing, it should issue the rtems_semaphore_release directive to allow other tasks access to the printer."
semaphore,"Task synchronization may be achieved by creating a semaphore with an initial count of zero.  One task waits for the arrival of another task by issuing a rtems_semaphore_obtain directive when it reaches a synchronization point. The other task performs a corresponding rtems_semaphore_release operation when it reaches its synchronization point, thus unblocking the pending task."
semaphore,"Deadlock occurs when a task owning a binary semaphore attempts to acquire that same semaphore and blocks as result.  Since the semaphore is allocated to a task, it cannot be deleted.  Therefore, the task that currently holds the semaphore and is also blocked waiting for that semaphore will never execute again."
semaphore,RTEMS addresses this problem by allowing the task holding the binary semaphore to obtain the same binary semaphore multiple times in a nested manner.  Each rtems_semaphore_obtain must be accompanied with a rtems_semaphore_release.  The semaphore will only be made available for acquisition by other tasks when the outermost rtems_semaphore_obtain is matched with a rtems_semaphore_release.
semaphore,Simple binary semaphores do not allow nested access and so can be used for task synchronization.
semaphore,"RTEMS supports priority inheritance for local, binary semaphores that use the priority task wait queue blocking discipline. In SMP configurations, the O(m) Independence-Preserving Protocol (OMIP) is used instead."
semaphore,"RTEMS supports priority ceiling for local, binary semaphores that use the priority task wait queue blocking discipline."
semaphore,"RTEMS supports the Multiprocessor Resource Sharing Protocol (MrsP) for local, binary semaphores that use the priority task wait queue blocking discipline.  In uniprocessor configurations, the Immediate Ceiling Priority Protocol (ICPP) is used instead."
semaphore,"In general, an attribute set is built by a bitwise OR of the desired attribute components.  The following table lists the set of valid semaphore attributes:"
semaphore,"RTEMS_FIFO tasks wait by FIFO (default) RTEMS_PRIORITY tasks wait by priority RTEMS_BINARY_SEMAPHORE restrict values to 0 and 1 RTEMS_COUNTING_SEMAPHORE no restriction on values (default) RTEMS_SIMPLE_BINARY_SEMAPHORE restrict values to 0 and 1, do not allow nested access, allow deletion of
locked semaphore. RTEMS_NO_INHERIT_PRIORITY do not use priority inheritance (default) RTEMS_INHERIT_PRIORITY use priority inheritance RTEMS_NO_PRIORITY_CEILING do not use priority ceiling (default) RTEMS_PRIORITY_CEILING use priority ceiling RTEMS_NO_MULTIPROCESSOR_RESOURCE_SHARING do not use Multiprocessor Resource Sharing Protocol (default) RTEMS_MULTIPROCESSOR_RESOURCE_SHARING use Multiprocessor Resource Sharing Protocol RTEMS_LOCAL local semaphore (default) RTEMS_GLOBAL global semaphore"
semaphore,RTEMS_FIFO
semaphore,tasks wait by FIFO (default)
semaphore,RTEMS_PRIORITY
semaphore,tasks wait by priority
semaphore,RTEMS_BINARY_SEMAPHORE
semaphore,restrict values to 0 and 1
semaphore,RTEMS_COUNTING_SEMAPHORE
semaphore,no restriction on values (default)
semaphore,RTEMS_SIMPLE_BINARY_SEMAPHORE
semaphore,"restrict values to 0 and 1, do not allow nested access, allow deletion of locked semaphore."
semaphore,RTEMS_NO_INHERIT_PRIORITY
semaphore,do not use priority inheritance (default)
semaphore,RTEMS_INHERIT_PRIORITY
semaphore,use priority inheritance
semaphore,RTEMS_NO_PRIORITY_CEILING
semaphore,do not use priority ceiling (default)
semaphore,RTEMS_PRIORITY_CEILING
semaphore,use priority ceiling
semaphore,RTEMS_NO_MULTIPROCESSOR_RESOURCE_SHARING
semaphore,do not use Multiprocessor Resource Sharing Protocol (default)
semaphore,RTEMS_MULTIPROCESSOR_RESOURCE_SHARING
semaphore,use Multiprocessor Resource Sharing Protocol
semaphore,RTEMS_LOCAL
semaphore,local semaphore (default)
semaphore,RTEMS_GLOBAL
semaphore,global semaphore
semaphore,"Attribute values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each attribute appears exactly once in the component list.  An attribute listed as a default is not required to appear in the attribute list, although it is a good programming practice to specify default attributes.  If all defaults are desired, the attribute RTEMS_DEFAULT_ATTRIBUTES should be specified on this call."
semaphore,"This example demonstrates the attribute_set parameter needed to create a local semaphore with the task priority waiting queue discipline.  The attribute_set parameter passed to the rtems_semaphore_create directive could be either RTEMS_PRIORITY or RTEMS_LOCAL | RTEMS_PRIORITY.  The attribute_set parameter can be set to RTEMS_PRIORITY because RTEMS_LOCAL is the default for all created tasks.  If a similar semaphore were to be known globally, then the attribute_set parameter would be RTEMS_GLOBAL | RTEMS_PRIORITY."
semaphore,"Some combinatinos of these attributes are invalid.  For example, priority ordered blocking discipline must be applied to a binary semaphore in order to use either the priority inheritance or priority ceiling functionality.  The following tree figure illustrates the valid combinations."
semaphore,"In general, an option is built by a bitwise OR of the desired option components.  The set of valid options for the rtems_semaphore_obtain directive are listed in the following table:"
semaphore,RTEMS_WAIT task will wait for semaphore (default) RTEMS_NO_WAIT task should not wait
semaphore,RTEMS_WAIT
semaphore,task will wait for semaphore (default)
semaphore,RTEMS_NO_WAIT
semaphore,task should not wait
semaphore,"Option values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each attribute appears exactly once in the component list.  An option listed as a default is not required to appear in the list, although it is a good programming practice to specify default options.  If all defaults are desired, the option RTEMS_DEFAULT_OPTIONS should be specified on this call."
semaphore,This example demonstrates the option parameter needed to poll for a semaphore. The option parameter passed to the rtems_semaphore_obtain directive should be RTEMS_NO_WAIT.
semaphore,"© Copyright 1988, 2024 RTEMS Project and contributors."
semaphore,The Semaphore Manager utilizes standard Dijkstra counting semaphores to provide synchronization and mutual exclusion capabilities. The directives provided by the Semaphore Manager are:
semaphore,rtems_semaphore_create() - Creates a semaphore. rtems_semaphore_ident() - Identifies a semaphore by the object name. rtems_semaphore_delete() - Deletes the semaphore. rtems_semaphore_obtain() - Obtains the semaphore. rtems_semaphore_release() - Releases the semaphore. rtems_semaphore_flush() - Flushes the semaphore. rtems_semaphore_set_priority() - Sets the priority by scheduler for the semaphore.
semaphore,rtems_semaphore_create() - Creates a semaphore.
semaphore,rtems_semaphore_ident() - Identifies a semaphore by the object name.
semaphore,rtems_semaphore_delete() - Deletes the semaphore.
semaphore,rtems_semaphore_obtain() - Obtains the semaphore.
semaphore,rtems_semaphore_release() - Releases the semaphore.
semaphore,rtems_semaphore_flush() - Flushes the semaphore.
semaphore,rtems_semaphore_set_priority() - Sets the priority by scheduler for the semaphore.
semaphore,"© Copyright 1988, 2024 RTEMS Project and contributors."
semaphore,"The rtems_semaphore_create directive creates a binary or counting semaphore with a user-specified name as well as an initial count.  If a binary semaphore is created with a count of zero (0) to indicate that it has been allocated, then the task creating the semaphore is considered the current holder of the semaphore.  At create time the method for ordering waiting tasks in the semaphore’s task wait queue (by FIFO or task priority) is specified. Additionally, the priority inheritance or priority ceiling algorithm may be selected for local, binary semaphores that use the priority task wait queue blocking discipline.  If the priority ceiling algorithm is selected, then the highest priority of any task which will attempt to obtain this semaphore must be specified.  RTEMS allocates a Semaphore Control Block (SMCB) from the SMCB free list.  This data structure is used by RTEMS to manage the newly created semaphore.  Also, a unique semaphore ID is generated and returned to the calling task."
semaphore,"When a semaphore is created, RTEMS generates a unique semaphore ID and assigns it to the created semaphore until it is deleted.  The semaphore ID may be obtained by either of two methods.  First, as the result of an invocation of the rtems_semaphore_create directive, the semaphore ID is stored in a user provided location.  Second, the semaphore ID may be obtained later using the rtems_semaphore_ident directive.  The semaphore ID is used by other semaphore manager directives to access this semaphore."
semaphore,The rtems_semaphore_obtain directive is used to acquire the specified semaphore.  A simplified version of the rtems_semaphore_obtain directive can be described as follows:
semaphore,If the semaphore’s count is greater than zero then decrement the semaphore’s count else wait for release of semaphore then return SUCCESSFUL.
semaphore,"When the semaphore cannot be immediately acquired, one of the following situations applies:"
semaphore,"By default, the calling task will wait forever to acquire the semaphore. Specifying RTEMS_NO_WAIT forces an immediate return with an error status code. Specifying a timeout limits the interval the task will wait before returning with an error status code."
semaphore,"By default, the calling task will wait forever to acquire the semaphore."
semaphore,Specifying RTEMS_NO_WAIT forces an immediate return with an error status code.
semaphore,Specifying a timeout limits the interval the task will wait before returning with an error status code.
semaphore,"If the task waits to acquire the semaphore, then it is placed in the semaphore’s task wait queue in either FIFO or task priority order.  If the task blocked waiting for a binary semaphore using priority inheritance and the task’s priority is greater than that of the task currently holding the semaphore, then the holding task will inherit the priority of the blocking task.  All tasks waiting on a semaphore are returned an error code when the semaphore is deleted."
semaphore,"When a task successfully obtains a semaphore using priority ceiling and the priority ceiling for this semaphore is greater than that of the holder, then the holder’s priority will be elevated."
semaphore,The rtems_semaphore_release directive is used to release the specified semaphore.  A simplified version of the rtems_semaphore_release directive can be described as follows:
semaphore,If there are no tasks are waiting on this semaphore then increment the semaphore’s count else assign semaphore to a waiting task and return SUCCESSFUL.
semaphore,"If this is the outermost release of a binary semaphore that uses priority inheritance or priority ceiling and the task does not currently hold any other binary semaphores, then the task performing the rtems_semaphore_release will have its priority restored to its normal value."
semaphore,"The rtems_semaphore_delete directive removes a semaphore from the system and frees its control block.  A semaphore can be deleted by any local task that knows the semaphore’s ID.  As a result of this directive, all tasks blocked waiting to acquire the semaphore will be readied and returned a status code which indicates that the semaphore was deleted.  Any subsequent references to the semaphore’s name and ID are invalid."
semaphore,"© Copyright 1988, 2024 RTEMS Project and contributors."
signal,"The signal manager allows a task to optionally define an asynchronous signal routine (ASR).  An ASR is to a task what an ISR is to an application’s set of tasks.  When the processor is interrupted, the execution of an application is also interrupted and an ISR is given control.  Similarly, when a signal is sent to a task, that task’s execution path will be “interrupted” by the ASR. Sending a signal to a task has no effect on the receiving task’s current execution state."
signal,A signal flag is used by a task (or ISR) to inform another task of the occurrence of a significant situation.  Thirty-two signal flags are associated with each task.  A collection of one or more signals is referred to as a signal set.  The data type rtems_signal_set is used to manipulate signal sets.
signal,"A signal set is posted when it is directed (or sent) to a task. A pending signal is a signal that has been sent to a task with a valid ASR, but has not been processed by that task’s ASR."
signal,The format of an ASR is similar to that of an ISR with the following exceptions:
signal,"ISRs are scheduled by the processor hardware.  ASRs are scheduled by RTEMS. ISRs do not execute in the context of a task and may invoke only a subset of directives.  ASRs execute in the context of a task and may execute any directive. When an ISR is invoked, it is passed the vector number as its argument.  When an ASR is invoked, it is passed the signal set as its argument. An ASR has a task mode which can be different from that of the task.  An ISR does not execute as a task and, as a result, does not have a task mode."
signal,ISRs are scheduled by the processor hardware.  ASRs are scheduled by RTEMS.
signal,ISRs do not execute in the context of a task and may invoke only a subset of directives.  ASRs execute in the context of a task and may execute any directive.
signal,"When an ISR is invoked, it is passed the vector number as its argument.  When an ASR is invoked, it is passed the signal set as its argument."
signal,"An ASR has a task mode which can be different from that of the task.  An ISR does not execute as a task and, as a result, does not have a task mode."
signal,"A signal set is built by a bitwise OR of the desired signals.  The set of valid signals is RTEMS_SIGNAL_0 through RTEMS_SIGNAL_31.  If a signal is not explicitly specified in the signal set, then it is not present.  Signal values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each signal appears exactly once in the component list."
signal,"This example demonstrates the signal parameter used when sending the signal set consisting of RTEMS_SIGNAL_6, RTEMS_SIGNAL_15, and RTEMS_SIGNAL_31. The signal parameter provided to the rtems_signal_send directive should be RTEMS_SIGNAL_6 | RTEMS_SIGNAL_15 | RTEMS_SIGNAL_31."
signal,"In general, an ASR’s mode is built by a bitwise OR of the desired mode components.  The set of valid mode components is the same as those allowed with the task_create and task_mode directives.  A complete list of mode options is provided in the following table:"
signal,RTEMS_PREEMPT is masked by RTEMS_PREEMPT_MASK and enables preemption RTEMS_NO_PREEMPT is masked by RTEMS_PREEMPT_MASK and disables preemption RTEMS_NO_TIMESLICE is masked by RTEMS_TIMESLICE_MASK and disables timeslicing RTEMS_TIMESLICE is masked by RTEMS_TIMESLICE_MASK and enables timeslicing RTEMS_ASR is masked by RTEMS_ASR_MASK and enables ASR processing RTEMS_NO_ASR is masked by RTEMS_ASR_MASK and disables ASR processing RTEMS_INTERRUPT_LEVEL(0) is masked by RTEMS_INTERRUPT_MASK and enables all interrupts RTEMS_INTERRUPT_LEVEL(n) is masked by RTEMS_INTERRUPT_MASK and sets interrupts level n
signal,RTEMS_PREEMPT
signal,is masked by RTEMS_PREEMPT_MASK and enables preemption
signal,RTEMS_NO_PREEMPT
signal,is masked by RTEMS_PREEMPT_MASK and disables preemption
signal,RTEMS_NO_TIMESLICE
signal,is masked by RTEMS_TIMESLICE_MASK and disables timeslicing
signal,RTEMS_TIMESLICE
signal,is masked by RTEMS_TIMESLICE_MASK and enables timeslicing
signal,RTEMS_ASR
signal,is masked by RTEMS_ASR_MASK and enables ASR processing
signal,RTEMS_NO_ASR
signal,is masked by RTEMS_ASR_MASK and disables ASR processing
signal,RTEMS_INTERRUPT_LEVEL(0)
signal,is masked by RTEMS_INTERRUPT_MASK and enables all interrupts
signal,RTEMS_INTERRUPT_LEVEL(n)
signal,is masked by RTEMS_INTERRUPT_MASK and sets interrupts level n
signal,"Mode values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each mode appears exactly once in the component list.  A mode component listed as a default is not required to appear in the mode list, although it is a good programming practice to specify default components.  If all defaults are desired, the mode DEFAULT_MODES should be specified on this call."
signal,This example demonstrates the mode parameter used with the rtems_signal_catch to establish an ASR which executes at interrupt level three and is non-preemptible.  The mode should be set to RTEMS_INTERRUPT_LEVEL(3) | RTEMS_NO_PREEMPT to indicate the desired processor mode and interrupt level.
signal,"© Copyright 1988, 2024 RTEMS Project and contributors."
signal,The Signal Manager provides the capabilities required for asynchronous communication. The directives provided by the Signal Manager are:
signal,rtems_signal_catch() - Establishes an asynchronous signal routine (ASR) for the calling task. rtems_signal_send() - Sends the signal set to the task.
signal,rtems_signal_catch() - Establishes an asynchronous signal routine (ASR) for the calling task.
signal,rtems_signal_send() - Sends the signal set to the task.
signal,"© Copyright 1988, 2024 RTEMS Project and contributors."
signal,"The rtems_signal_catch directive establishes an ASR for the calling task. The address of the ASR and its execution mode are specified to this directive. The ASR’s mode is distinct from the task’s mode.  For example, the task may allow preemption, while that task’s ASR may have preemption disabled.  Until a task calls rtems_signal_catch the first time, its ASR is invalid, and no signal sets can be sent to the task."
signal,"A task may invalidate its ASR and discard all pending signals by calling rtems_signal_catch with a value of NULL for the ASR’s address.  When a task’s ASR is invalid, new signal sets sent to this task are discarded."
signal,"A task may disable ASR processing (RTEMS_NO_ASR) via the task_mode directive.  When a task’s ASR is disabled, the signals sent to it are left pending to be processed later when the ASR is enabled."
signal,"Any directive that can be called from a task can also be called from an ASR.  A task is only allowed one active ASR.  Thus, each call to rtems_signal_catch replaces the previous one."
signal,"Normally, signal processing is disabled for the ASR’s execution mode, but if signal processing is enabled for the ASR, the ASR must be reentrant."
signal,"The rtems_signal_send directive allows both tasks and ISRs to send signals to a target task.  The target task and a set of signals are specified to the rtems_signal_send directive.  The sending of a signal to a task has no effect on the execution state of that task.  If the task is not the currently running task, then the signals are left pending and processed by the task’s ASR the next time the task is dispatched to run.  The ASR is executed immediately before the task is dispatched.  If the currently running task sends a signal to itself or is sent a signal from an ISR, its ASR is immediately dispatched to run provided signal processing is enabled."
signal,"If an ASR with signals enabled is preempted by another task or an ISR and a new signal set is sent, then a new copy of the ASR will be invoked, nesting the preempted ASR.  Upon completion of processing the new signal set, control will return to the preempted ASR.  In this situation, the ASR must be reentrant."
signal,"Like events, identical signals sent to a task are not queued.  In other words, sending the same signal multiple times to a task (without any intermediate signal processing occurring for the task), has the same result as sending that signal to that task once."
signal,"Asynchronous signals were designed to provide the capability to generate software interrupts.  The processing of software interrupts parallels that of hardware interrupts.  As a result, the differences between the formats of ASRs and ISRs is limited to the meaning of the single argument passed to an ASR. The ASR should have the following calling sequence and adhere to C calling conventions:"
signal,When the ASR returns to RTEMS the mode and execution path of the interrupted task (or ASR) is restored to the context prior to entering the ASR.
signal,"© Copyright 1988, 2024 RTEMS Project and contributors."
task,"Many definitions of a task have been proposed in computer literature. Unfortunately, none of these definitions encompasses all facets of the concept in a manner which is operating system independent.  Several of the more common definitions are provided to enable each user to select a definition which best matches their own experience and understanding of the task concept:"
task,"a “dispatchable” unit. an entity to which the processor is allocated. an atomic unit of a real-time, multiprocessor system. single threads of execution which concurrently compete for resources. a sequence of closely related computations which can execute concurrently with other computational sequences."
task,a “dispatchable” unit.
task,an entity to which the processor is allocated.
task,"an atomic unit of a real-time, multiprocessor system."
task,single threads of execution which concurrently compete for resources.
task,a sequence of closely related computations which can execute concurrently with other computational sequences.
task,"From RTEMS’ perspective, a task is the smallest thread of execution which can compete on its own for system resources.  A task is manifested by the existence of a task control block (TCB)."
task,"The Task Control Block (TCB) is an RTEMS defined data structure which contains all the information that is pertinent to the execution of a task.  During system initialization, RTEMS reserves a TCB for each task configured.  A TCB is allocated upon creation of the task and is returned to the TCB free list upon deletion of the task."
task,"The TCB’s elements are modified as a result of system calls made by the application in response to external and internal stimuli.  TCBs are the only RTEMS internal data structure that can be accessed by an application via user extension routines.  The TCB contains a task’s name, ID, current priority, current and starting states, execution mode, TCB user extension pointer, scheduling control structures, as well as data required by a blocked task."
task,"A task’s context is stored in the TCB when a task switch occurs.  When the task regains control of the processor, its context is restored from the TCB.  When a task is restarted, the initial state of the task is restored from the starting context area in the task’s TCB."
task,The system uses two separate memory areas to manage a task.  One memory area is the Task Control Block.  The other memory area is allocated from the stack space or provided by the user and contains
task,"the task stack, the thread-local storage (TLS), and an optional architecture-specific floating-point context."
task,"the task stack,"
task,"the thread-local storage (TLS), and"
task,an optional architecture-specific floating-point context.
task,The size of the thread-local storage is determined at link time.  A user-provided task stack must take the size of the thread-local storage into account.
task,"On architectures with a dedicated floating-point context, the application configuration assumes that every task is a floating-point task, but whether or not a task is actually floating-point is determined at runtime during task creation (see Floating Point Considerations).  In highly memory constrained systems this potential overestimate of the task stack space can be mitigated through the CONFIGURE_MINIMUM_TASK_STACK_SIZE configuration option and aligned task stack sizes for the tasks.  A user-provided task stack must take the potential floating-point context into account."
task,"By default, the task name is defined by the task object name given to rtems_task_create().  The task name can be obtained with the pthread_getname_np() function. Optionally, a new task name may be set with the pthread_setname_np() function. The maximum size of a task name is defined by the application configuration option CONFIGURE_MAXIMUM_THREAD_NAME_SIZE."
task,A task may exist in one of the following five states:
task,executing - Currently scheduled to the CPU ready - May be scheduled to the CPU blocked - Unable to be scheduled to the CPU dormant - Created task that is not started non-existent - Uncreated or deleted task
task,executing - Currently scheduled to the CPU
task,ready - May be scheduled to the CPU
task,blocked - Unable to be scheduled to the CPU
task,dormant - Created task that is not started
task,non-existent - Uncreated or deleted task
task,"An active task may occupy the executing, ready, blocked or dormant state, otherwise the task is considered non-existent.  One or more tasks may be active in the system simultaneously.  Multiple tasks communicate, synchronize, and compete for system resources with each other via system calls.  The multiple tasks appear to execute in parallel, but actually each is dispatched to the CPU for periods of time determined by the RTEMS scheduling algorithm.  The scheduling of a task is based on its current state and priority."
task,"A task’s priority determines its importance in relation to the other tasks executing on the processor set owned by a scheduler.  Normally, RTEMS supports 256 levels of priority ranging from 0 to 255.  The priority level 0 represents a special priority reserved for the operating system.  The data type rtems_task_priority is used to store task priorities.  The maximum priority level depends on the configured scheduler, see CONFIGURE_MAXIMUM_PRIORITY, Clustered Scheduler Configuration, and Scheduling Concepts."
task,"Tasks of numerically smaller priority values are more important tasks than tasks of numerically larger priority values.  For example, a task at priority level 5 is of higher privilege than a task at priority level 10.  There is no limit to the number of tasks assigned to the same priority."
task,Each task has a priority associated with it at all times.  The initial value of this priority is assigned at task creation time.  The priority of a task may be changed at any subsequent time.
task,"Priorities are used by the scheduler to determine which ready task will be allowed to execute.  In general, the higher the logical priority of a task, the more likely it is to receive processor execution time."
task,A task’s execution mode is a combination of the following four components:
task,preemption ASR processing timeslicing interrupt level
task,preemption
task,ASR processing
task,timeslicing
task,interrupt level
task,It is used to modify RTEMS’ scheduling process and to alter the execution environment of the task.  The data type rtems_task_mode is used to manage the task execution mode.
task,"The preemption component allows a task to determine when control of the processor is relinquished.  If preemption is disabled (RTEMS_NO_PREEMPT), the task will retain control of the processor as long as it is in the executing state - even if a higher priority task is made ready.  If preemption is enabled (RTEMS_PREEMPT) and a higher priority task is made ready, then the processor will be taken away from the current task immediately and given to the higher priority task."
task,"The timeslicing component is used by the RTEMS scheduler to determine how the processor is allocated to tasks of equal priority.  If timeslicing is enabled (RTEMS_TIMESLICE), then RTEMS will limit the amount of time the task can execute before the processor is allocated to another ready task of equal priority. The length of the timeslice is application dependent and specified in the Configuration Table.  If timeslicing is disabled (RTEMS_NO_TIMESLICE), then the task will be allowed to execute until a task of higher priority is made ready.  If RTEMS_NO_PREEMPT is selected, then the timeslicing component is ignored by the scheduler."
task,"The asynchronous signal processing component is used to determine when received signals are to be processed by the task.  If signal processing is enabled (RTEMS_ASR), then signals sent to the task will be processed the next time the task executes.  If signal processing is disabled (RTEMS_NO_ASR), then all signals received by the task will remain posted until signal processing is enabled.  This component affects only tasks which have established a routine to process asynchronous signals."
task,The interrupt level component is used to determine which interrupts will be enabled when the task is executing. RTEMS_INTERRUPT_LEVEL(n) specifies that the task will execute at interrupt level n.
task,RTEMS_PREEMPT enable preemption (default) RTEMS_NO_PREEMPT disable preemption RTEMS_NO_TIMESLICE disable timeslicing (default) RTEMS_TIMESLICE enable timeslicing RTEMS_ASR enable ASR processing (default) RTEMS_NO_ASR disable ASR processing RTEMS_INTERRUPT_LEVEL(0) enable all interrupts (default) RTEMS_INTERRUPT_LEVEL(n) execute at interrupt level n
task,RTEMS_PREEMPT
task,enable preemption (default)
task,RTEMS_NO_PREEMPT
task,disable preemption
task,RTEMS_NO_TIMESLICE
task,disable timeslicing (default)
task,RTEMS_TIMESLICE
task,enable timeslicing
task,RTEMS_ASR
task,enable ASR processing (default)
task,RTEMS_NO_ASR
task,disable ASR processing
task,RTEMS_INTERRUPT_LEVEL(0)
task,enable all interrupts (default)
task,RTEMS_INTERRUPT_LEVEL(n)
task,execute at interrupt level n
task,The set of default modes may be selected by specifying the RTEMS_DEFAULT_MODES constant.
task,"Independent of the task state with respect to the scheduler, the task life is determined by several orthogonal states:"
task,protected or unprotected deferred life changes or no deferred life changes restarting or not restarting terminating or not terminating detached or not detached
task,protected or unprotected
task,deferred life changes or no deferred life changes
task,restarting or not restarting
task,terminating or not terminating
task,detached or not detached
task,"While the task life is protected, asynchronous task restart and termination requests are blocked.  A task may still restart or terminate itself.  All tasks are created with an unprotected task life.  The task life protection is used by the system to prevent system resources being affected by asynchronous task restart and termination requests.  The task life protection can be enabled (PTHREAD_CANCEL_DISABLE) or disabled (PTHREAD_CANCEL_ENABLE) for the calling task through the pthread_setcancelstate() directive."
task,"While deferred life changes are enabled, asynchronous task restart and termination requests are delayed until the task performs a life change itself or calls pthread_testcancel().  Cancellation points are not implemented in RTEMS.  Deferred task life changes can be enabled (PTHREAD_CANCEL_DEFERRED) or disabled (PTHREAD_CANCEL_ASYNCHRONOUS) for the calling task through the pthread_setcanceltype() directive.  Classic API tasks are created with deferred life changes disabled.  POSIX threads are created with deferred life changes enabled."
task,A task is made restarting by issuing a task restart request through the rtems_task_restart() directive.
task,"A task is made terminating by issuing a task termination request through the rtems_task_exit(), rtems_task_delete(), pthread_exit(), and pthread_cancel() directives."
task,"When a detached task terminates, the termination procedure completes without the need for another task to join with the terminated task.  Classic API tasks are created as not detached.  The detached state of created POSIX threads is determined by the thread attributes.  They are created as not detached by default.  The calling task is made detached through the pthread_detach() directive.  The rtems_task_exit() directive and self deletion though rtems_task_delete() directive make the calling task detached.  In contrast, the pthread_exit() directive does not change the detached state of the calling task."
task,All RTEMS tasks are invoked with a single argument which is specified when they are started or restarted.  The argument is commonly used to communicate startup information to the task.  The simplest manner in which to define a task which accesses it argument is:
task,Application tasks requiring more information may view this single argument as an index into an array of parameter blocks.
task,Please consult the RTEMS CPU Architecture Supplement if this section is relevant on your architecture.  On some architectures the floating-point context is contained in the normal task context and this section does not apply.
task,Creating a task with the RTEMS_FLOATING_POINT attribute flag results in additional memory being allocated for the task to store the state of the numeric coprocessor during task switches.  This additional memory is not allocated for RTEMS_NO_FLOATING_POINT tasks. Saving and restoring the context of a RTEMS_FLOATING_POINT task takes longer than that of a RTEMS_NO_FLOATING_POINT task because of the relatively large amount of time required for the numeric coprocessor to save or restore its computational state.
task,"Since RTEMS was designed specifically for embedded military applications which are floating point intensive, the executive is optimized to avoid unnecessarily saving and restoring the state of the numeric coprocessor.  In uniprocessor configurations, the state of the numeric coprocessor is only saved when a RTEMS_FLOATING_POINT task is dispatched and that task was not the last task to utilize the coprocessor.  In a uniprocessor system with only one RTEMS_FLOATING_POINT task, the state of the numeric coprocessor will never be saved or restored."
task,"Although the overhead imposed by RTEMS_FLOATING_POINT tasks is minimal, some applications may wish to completely avoid the overhead associated with RTEMS_FLOATING_POINT tasks and still utilize a numeric coprocessor.  By preventing a task from being preempted while performing a sequence of floating point operations, a RTEMS_NO_FLOATING_POINT task can utilize the numeric coprocessor without incurring the overhead of a RTEMS_FLOATING_POINT context switch.  This approach also avoids the allocation of a floating point context area.  However, if this approach is taken by the application designer, no tasks should be created as RTEMS_FLOATING_POINT tasks.  Otherwise, the floating point context will not be correctly maintained because RTEMS assumes that the state of the numeric coprocessor will not be altered by RTEMS_NO_FLOATING_POINT tasks.  Some architectures with a dedicated floating-point context raise a processor exception if a task with RTEMS_NO_FLOATING_POINT issues a floating-point instruction, so this approach may not work at all."
task,"If the supported processor type does not have hardware floating capabilities or a standard numeric coprocessor, RTEMS will not provide built-in support for hardware floating point on that processor.  In this case, all tasks are considered RTEMS_NO_FLOATING_POINT whether created as RTEMS_FLOATING_POINT or RTEMS_NO_FLOATING_POINT tasks.  A floating point emulation software library must be utilized for floating point operations."
task,"On some processors, it is possible to disable the floating point unit dynamically.  If this capability is supported by the target processor, then RTEMS will utilize this capability to enable the floating point unit only for tasks which are created with the RTEMS_FLOATING_POINT attribute.  The consequence of a RTEMS_NO_FLOATING_POINT task attempting to access the floating point unit is CPU dependent but will generally result in an exception condition."
task,"In general, an attribute set is built by a bitwise OR of the desired components.  The set of valid task attribute components is listed below:"
task,RTEMS_NO_FLOATING_POINT does not use coprocessor (default) RTEMS_FLOATING_POINT uses numeric coprocessor RTEMS_LOCAL local task (default) RTEMS_GLOBAL global task
task,RTEMS_NO_FLOATING_POINT
task,does not use coprocessor (default)
task,RTEMS_FLOATING_POINT
task,uses numeric coprocessor
task,RTEMS_LOCAL
task,local task (default)
task,RTEMS_GLOBAL
task,global task
task,"Attribute values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each attribute appears exactly once in the component list.  A component listed as a default is not required to appear in the component list, although it is a good programming practice to specify default components.  If all defaults are desired, then RTEMS_DEFAULT_ATTRIBUTES should be used."
task,"This example demonstrates the attribute_set parameter needed to create a local task which utilizes the numeric coprocessor.  The attribute_set parameter could be RTEMS_FLOATING_POINT or RTEMS_LOCAL | RTEMS_FLOATING_POINT.  The attribute_set parameter can be set to RTEMS_FLOATING_POINT because RTEMS_LOCAL is the default for all created tasks.  If the task were global and used the numeric coprocessor, then the attribute_set parameter would be RTEMS_GLOBAL | RTEMS_FLOATING_POINT."
task,"In general, a mode and its corresponding mask is built by a bitwise OR of the desired components.  The set of valid mode constants and each mode’s corresponding mask constant is listed below:"
task,RTEMS_PREEMPT is masked by RTEMS_PREEMPT_MASK and enables preemption RTEMS_NO_PREEMPT is masked by RTEMS_PREEMPT_MASK and disables preemption RTEMS_NO_TIMESLICE is masked by RTEMS_TIMESLICE_MASK and disables timeslicing RTEMS_TIMESLICE is masked by RTEMS_TIMESLICE_MASK and enables timeslicing RTEMS_ASR is masked by RTEMS_ASR_MASK and enables ASR processing RTEMS_NO_ASR is masked by RTEMS_ASR_MASK and disables ASR processing RTEMS_INTERRUPT_LEVEL(0) is masked by RTEMS_INTERRUPT_MASK and enables all interrupts RTEMS_INTERRUPT_LEVEL(n) is masked by RTEMS_INTERRUPT_MASK and sets interrupts level n
task,RTEMS_PREEMPT
task,is masked by RTEMS_PREEMPT_MASK and enables preemption
task,RTEMS_NO_PREEMPT
task,is masked by RTEMS_PREEMPT_MASK and disables preemption
task,RTEMS_NO_TIMESLICE
task,is masked by RTEMS_TIMESLICE_MASK and disables timeslicing
task,RTEMS_TIMESLICE
task,is masked by RTEMS_TIMESLICE_MASK and enables timeslicing
task,RTEMS_ASR
task,is masked by RTEMS_ASR_MASK and enables ASR processing
task,RTEMS_NO_ASR
task,is masked by RTEMS_ASR_MASK and disables ASR processing
task,RTEMS_INTERRUPT_LEVEL(0)
task,is masked by RTEMS_INTERRUPT_MASK and enables all interrupts
task,RTEMS_INTERRUPT_LEVEL(n)
task,is masked by RTEMS_INTERRUPT_MASK and sets interrupts level n
task,"Mode values are specifically designed to be mutually exclusive, therefore bitwise OR and addition operations are equivalent as long as each mode appears exactly once in the component list.  A mode component listed as a default is not required to appear in the mode component list, although it is a good programming practice to specify default components.  If all defaults are desired, the mode RTEMS_DEFAULT_MODES and the mask RTEMS_ALL_MODE_MASKS should be used."
task,"The following example demonstrates the mode and mask parameters used with the rtems_task_mode directive to place a task at interrupt level 3 and make it non-preemptible.  The mode should be set to RTEMS_INTERRUPT_LEVEL(3) | RTEMS_NO_PREEMPT to indicate the desired preemption mode and interrupt level, while the mask parameter should be set to RTEMS_INTERRUPT_MASK | RTEMS_NO_PREEMPT_MASK to indicate that the calling task’s interrupt level and preemption mode are being altered."
task,"© Copyright 1988, 2024 RTEMS Project and contributors."
task,"The Task Manager provides a comprehensive set of directives to create, delete, and administer tasks. The directives provided by the Task Manager are:"
task,rtems_task_create() - Creates a task. rtems_task_construct() - Constructs a task from the specified task configuration. rtems_task_ident() - Identifies a task by the object name. rtems_task_self() - Gets the task identifier of the calling task. rtems_task_start() - Starts the task. rtems_task_restart() - Restarts the task. rtems_task_delete() - Deletes the task. rtems_task_exit() - Deletes the calling task. rtems_task_suspend() - Suspends the task. rtems_task_resume() - Resumes the task. rtems_task_is_suspended() - Checks if the task is suspended. rtems_task_set_priority() - Sets the real priority or gets the current priority of the task. rtems_task_get_priority() - Gets the current priority of the task with respect to the scheduler. rtems_task_mode() - Gets and optionally sets the mode of the calling task. rtems_task_wake_after() - Wakes up after a count of clock ticks have occurred or yields the processor. rtems_task_wake_when() - Wakes up when specified. rtems_task_get_scheduler() - Gets the home scheduler of the task. rtems_task_set_scheduler() - Sets the home scheduler for the task. rtems_task_get_affinity() - Gets the processor affinity of the task. rtems_task_set_affinity() - Sets the processor affinity of the task. rtems_task_iterate() - Iterates over all tasks and invokes the visitor routine for each task. RTEMS_TASK_STORAGE_SIZE() - Gets the recommended task storage area size for the size and task attributes.
task,rtems_task_create() - Creates a task.
task,rtems_task_construct() - Constructs a task from the specified task configuration.
task,rtems_task_ident() - Identifies a task by the object name.
task,rtems_task_self() - Gets the task identifier of the calling task.
task,rtems_task_start() - Starts the task.
task,rtems_task_restart() - Restarts the task.
task,rtems_task_delete() - Deletes the task.
task,rtems_task_exit() - Deletes the calling task.
task,rtems_task_suspend() - Suspends the task.
task,rtems_task_resume() - Resumes the task.
task,rtems_task_is_suspended() - Checks if the task is suspended.
task,rtems_task_set_priority() - Sets the real priority or gets the current priority of the task.
task,rtems_task_get_priority() - Gets the current priority of the task with respect to the scheduler.
task,rtems_task_mode() - Gets and optionally sets the mode of the calling task.
task,rtems_task_wake_after() - Wakes up after a count of clock ticks have occurred or yields the processor.
task,rtems_task_wake_when() - Wakes up when specified.
task,rtems_task_get_scheduler() - Gets the home scheduler of the task.
task,rtems_task_set_scheduler() - Sets the home scheduler for the task.
task,rtems_task_get_affinity() - Gets the processor affinity of the task.
task,rtems_task_set_affinity() - Sets the processor affinity of the task.
task,rtems_task_iterate() - Iterates over all tasks and invokes the visitor routine for each task.
task,RTEMS_TASK_STORAGE_SIZE() - Gets the recommended task storage area size for the size and task attributes.
task,"© Copyright 1988, 2024 RTEMS Project and contributors."
task,"The rtems_task_create directive creates a task by allocating a task control block, assigning the task a user-specified name, allocating it a stack and floating point context area, setting a user-specified initial priority, setting a user-specified initial mode, and assigning it a task ID.  Newly created tasks are initially placed in the dormant state.  All RTEMS tasks execute in the most privileged mode of the processor."
task,"When a task is created, RTEMS generates a unique task ID and assigns it to the created task until it is deleted.  The task ID may be obtained by either of two methods.  First, as the result of an invocation of the rtems_task_create directive, the task ID is stored in a user provided location.  Second, the task ID may be obtained later using the rtems_task_ident directive.  The task ID is used by other directives to manipulate this task."
task,"The rtems_task_start directive is used to place a dormant task in the ready state.  This enables the task to compete, based on its current priority, for the processor and other system resources.  Any actions, such as suspension or change of priority, performed on a task prior to starting it are nullified when the task is started."
task,"With the rtems_task_start directive the user specifies the task’s starting address and argument.  The argument is used to communicate some startup information to the task.  As part of this directive, RTEMS initializes the task’s stack based upon the task’s initial execution mode and start address. The starting argument is passed to the task in accordance with the target processor’s calling convention."
task,"The rtems_task_restart directive restarts a task at its initial starting address with its original priority and execution mode, but with a possibly different argument.  The new argument may be used to distinguish between the original invocation of the task and subsequent invocations.  The task’s stack and control block are modified to reflect their original creation values. Although references to resources that have been requested are cleared, resources allocated by the task are NOT automatically returned to RTEMS.  A task cannot be restarted unless it has previously been started (i.e. dormant tasks cannot be restarted).  All restarted tasks are placed in the ready state."
task,The rtems_task_suspend directive is used to place either the caller or another task into a suspended state.  The task remains suspended until a rtems_task_resume directive is issued.  This implies that a task may be suspended as well as blocked waiting either to acquire a resource or for the expiration of a timer.
task,"The rtems_task_resume directive is used to remove another task from the suspended state. If the task is not also blocked, resuming it will place it in the ready state, allowing it to once again compete for the processor and resources.  If the task was blocked as well as suspended, this directive clears the suspension and leaves the task in the blocked state."
task,Suspending a task which is already suspended or resuming a task which is not suspended is considered an error.  The rtems_task_is_suspended can be used to determine if a task is currently suspended.
task,"The rtems_task_wake_after directive creates a sleep timer which allows a task to go to sleep for a specified count of clock ticks.  The task is blocked until the count of clock ticks has elapsed, at which time the task is unblocked. A task calling the rtems_task_wake_after directive with a delay of RTEMS_YIELD_PROCESSOR ticks will yield the processor to any other ready task of equal or greater priority and remain ready to execute."
task,"The rtems_task_wake_when directive creates a sleep timer which allows a task to go to sleep until a specified date and time.  The calling task is blocked until the specified date and time has occurred, at which time the task is unblocked."
task,"The rtems_task_set_priority directive is used to obtain or change the current priority of either the calling task or another task.  If the new priority requested is RTEMS_CURRENT_PRIORITY or the task’s actual priority, then the current priority will be returned and the task’s priority will remain unchanged.  If the task’s priority is altered, then the task will be scheduled according to its new priority."
task,The rtems_task_restart directive resets the priority of a task to its original value.
task,"The rtems_task_mode directive is used to obtain or change the current execution mode of the calling task.  A task’s execution mode is used to enable preemption, timeslicing, ASR processing, and to set the task’s interrupt level."
task,The rtems_task_restart directive resets the mode of a task to its original value.
task,"RTEMS provides the rtems_task_delete directive to allow a task to delete itself or any other task.  This directive removes all RTEMS references to the task, frees the task’s control block, removes it from resource wait queues, and deallocates its stack as well as the optional floating point context.  The task’s name and ID become inactive at this time, and any subsequent references to either of them is invalid.  In fact, RTEMS may reuse the task ID for another task which is created later in the application.  A specialization of rtems_task_delete is rtems_task_exit which deletes the calling task."
task,"Unexpired delay timers (i.e. those used by rtems_task_wake_after and rtems_task_wake_when) and timeout timers associated with the task are automatically deleted, however, other resources dynamically allocated by the task are NOT automatically returned to RTEMS.  Therefore, before a task is deleted, all of its dynamically allocated resources should be deallocated by the user.  This may be accomplished by instructing the task to delete itself rather than directly deleting the task.  Other tasks may instruct a task to delete itself by sending a “delete self” message, event, or signal, or by restarting the task with special arguments which instruct the task to delete itself."
task,"On some embedded applications targeting SMP systems, it may be beneficial to lock individual tasks to specific processors.  In this way, one can designate a processor for I/O tasks, another for computation, etc..  The following illustrates the code sequence necessary to assign a task an affinity for processor with index processor_index."
task,"It is important to note that the cpuset is not validated until the rtems_task_set_affinity call is made. At that point, it is validated against the current system configuration."
task,Task notepads and the associated directives TASK_GET_NOTE - Get task notepad entry and TASK_SET_NOTE - Set task notepad entry were removed in RTEMS 5.1. These were never thread-safe to access and subject to conflicting use of the notepad index by libraries which were designed independently.
task,"It is recommended that applications be modified to use services which are thread safe and not subject to issues with multiple applications conflicting over the key (e.g. notepad index) selection. For most applications, POSIX Keys should be used. These are available in all RTEMS build configurations. It is also possible that thread-local storage (TLS) is an option for some use cases."
task,"Task notepads and the associated directives TASK_VARIABLE_ADD - Associate per task variable, TASK_VARIABLE_GET - Obtain value of a per task variable and TASK_VARIABLE_DELETE - Remove per task variable were removed in RTEMS 5.1.  Task variables must be replaced by POSIX Keys or thread-local storage (TLS).  POSIX Keys are available in all configurations and support value destructors.  For the TLS support consult the RTEMS CPU Architecture Supplement."
task,"© Copyright 1988, 2024 RTEMS Project and contributors."
timer,A clock tick is required to support the functionality provided by this manager.
timer,A timer is an RTEMS object which allows the application to schedule operations to occur at specific times in the future.  User supplied timer service routines are invoked by either a clock tick directive or a special Timer Server task when the timer fires.  Timer service routines may perform any operations or directives which normally would be performed by the application code which invoked a clock tick directive.
timer,"The timer can be used to implement watchdog routines which only fire to denote that an application error has occurred.  The timer is reset at specific points in the application to ensure that the watchdog does not fire.  Thus, if the application does not reset the watchdog timer, then the timer service routine will fire to indicate that the application has failed to reach a reset point. This use of a timer is sometimes referred to as a “keep alive” or a “deadman” timer."
timer,"The Timer Server task is responsible for executing the timer service routines associated with all task-based timers.  This task executes at a priority specified by rtems_timer_initiate_server() and it may have a priority of zero (the highest priority).  In uniprocessor configurations, it is created non-preemptible."
timer,"By providing a mechanism where timer service routines execute in task rather than interrupt space, the application is allowed a bit more flexibility in what operations a timer service routine can perform.  For example, the Timer Server can be configured to have a floating point context in which case it would be safe to perform floating point operations from a task-based timer.  Most of the time, executing floating point instructions from an interrupt service routine is not considered safe. The timer service routines invoked by the Timer Server may block, however, since this blocks the Timer Server itself, other timer service routines that are already pending do not run until the blocked timer service routine finished its work."
timer,The Timer Server is designed to remain blocked until a task-based timer fires. This reduces the execution overhead of the Timer Server.
timer,The timer service routine should adhere to C calling conventions and have a prototype similar to the following:
timer,Where the timer_id parameter is the RTEMS object ID of the timer which is being fired and user_data is a pointer to user-defined information which may be utilized by the timer service routine.  The argument user_data may be NULL.
timer,"© Copyright 1988, 2024 RTEMS Project and contributors."
timer,The Timer Manager provides support for timer facilities. The directives provided by the Timer Manager are:
timer,rtems_timer_create() - Creates a timer. rtems_timer_ident() - Identifies a timer by the object name. rtems_timer_cancel() - Cancels the timer. rtems_timer_delete() - Deletes the timer. rtems_timer_fire_after() - Fires the timer after the interval. rtems_timer_fire_when() - Fires the timer at the time of day. rtems_timer_initiate_server() - Initiates the Timer Server. rtems_timer_server_fire_after() - Fires the timer after the interval using the Timer Server. rtems_timer_server_fire_when() - Fires the timer at the time of day using the Timer Server. rtems_timer_reset() - Resets the timer. rtems_timer_get_information() - Gets information about the timer.
timer,rtems_timer_create() - Creates a timer.
timer,rtems_timer_ident() - Identifies a timer by the object name.
timer,rtems_timer_cancel() - Cancels the timer.
timer,rtems_timer_delete() - Deletes the timer.
timer,rtems_timer_fire_after() - Fires the timer after the interval.
timer,rtems_timer_fire_when() - Fires the timer at the time of day.
timer,rtems_timer_initiate_server() - Initiates the Timer Server.
timer,rtems_timer_server_fire_after() - Fires the timer after the interval using the Timer Server.
timer,rtems_timer_server_fire_when() - Fires the timer at the time of day using the Timer Server.
timer,rtems_timer_reset() - Resets the timer.
timer,rtems_timer_get_information() - Gets information about the timer.
timer,"© Copyright 1988, 2024 RTEMS Project and contributors."
timer,"The rtems_timer_create directive creates a timer by allocating a Timer Control Block (TMCB), assigning the timer a user-specified name, and assigning it a timer ID.  Newly created timers do not have a timer service routine associated with them and are not active."
timer,"When a timer is created, RTEMS generates a unique timer ID and assigns it to the created timer until it is deleted.  The timer ID may be obtained by either of two methods.  First, as the result of an invocation of the rtems_timer_create directive, the timer ID is stored in a user provided location.  Second, the timer ID may be obtained later using the rtems_timer_ident directive.  The timer ID is used by other directives to manipulate this timer."
timer,"The rtems_timer_fire_after and rtems_timer_server_fire_after directives initiate a timer to fire a user provided timer service routine after the specified number of clock ticks have elapsed.  When the interval has elapsed, the timer service routine will be invoked from a clock tick directive if it was initiated by the rtems_timer_fire_after directive and from the Timer Server task if initiated by the rtems_timer_server_fire_after directive."
timer,"The rtems_timer_fire_when and rtems_timer_server_fire_when directive initiate a timer to fire a user provided timer service routine when the specified time of day has been reached.  When the interval has elapsed, the timer service routine will be invoked from a clock tick directive by the rtems_timer_fire_when directive and from the Timer Server task if initiated by the rtems_timer_server_fire_when directive."
timer,"The rtems_timer_cancel directive is used to halt the specified timer.  Once canceled, the timer service routine will not fire unless the timer is reinitiated.  The timer can be reinitiated using the rtems_timer_reset, rtems_timer_fire_after, and rtems_timer_fire_when directives."
timer,"The rtems_timer_reset directive is used to restore an interval timer initiated by a previous invocation of rtems_timer_fire_after or rtems_timer_server_fire_after to its original interval length.  If the timer has not been used or the last usage of this timer was by the rtems_timer_fire_when or rtems_timer_server_fire_when directive, then an error is returned.  The timer service routine is not changed or fired by this directive."
timer,The rtems_timer_initiate_server directive is used to allocate and start the execution of the Timer Server task.  The application can specify both the stack size and attributes of the Timer Server.  The Timer Server executes at a priority higher than any application task and thus the user can expect to be preempted as the result of executing the rtems_timer_initiate_server directive.
timer,"The rtems_timer_delete directive is used to delete a timer.  If the timer is running and has not expired, the timer is automatically canceled.  The timer’s control block is returned to the TMCB free list when it is deleted.  A timer can be deleted by a task other than the task which created the timer. Any subsequent references to the timer’s name and ID are invalid."
timer,"© Copyright 1988, 2024 RTEMS Project and contributors."
user-extensions,User extensions (call-back functions) are invoked by the system when the following events occur
user-extensions,"thread creation, thread start, thread restart, thread switch, thread begin, thread exitted (return from thread entry function), thread termination, thread deletion, and fatal error detection (system termination)."
user-extensions,"thread creation,"
user-extensions,"thread start,"
user-extensions,"thread restart,"
user-extensions,"thread switch,"
user-extensions,"thread begin,"
user-extensions,"thread exitted (return from thread entry function),"
user-extensions,"thread termination,"
user-extensions,"thread deletion, and"
user-extensions,fatal error detection (system termination).
user-extensions,"The user extensions have event-specific arguments, invocation orders and execution contexts.  Extension sets can be installed at run-time via rtems_extension_create() (dynamic extension sets) or at link-time via the application configuration option CONFIGURE_INITIAL_EXTENSIONS (initial extension sets)."
user-extensions,The execution context of user extensions varies.  Some user extensions are invoked with ownership of the allocator mutex.  The allocator mutex protects dynamic memory allocations and object creation/deletion.  Some user extensions are invoked with thread dispatching disabled.  The fatal error extension is invoked in an arbitrary context.
user-extensions,User extensions are maintained as a set.  All user extensions are optional and may be NULL.  Together a set of these user extensions typically performs a specific functionality such as performance monitoring or debugger support.  The extension set is defined via the following structure.
user-extensions,There is no system-provided storage for the initial extension sets.
user-extensions,The task control block (TCB) contains a pointer for each dynamic extension set. The pointer is initialized to NULL during thread initialization before the thread create extension is invoked.  The pointer may be used by the dynamic extension set to maintain thread-specific data.
user-extensions,The TCB extension is an array of pointers in the TCB. The index into the table can be obtained from the extension identifier returned when the extension object is created:
user-extensions,"The number of pointers in the area is the same as the number of dynamic user extension sets configured.  This allows an application to augment the TCB with user-defined information.  For example, an application could implement task profiling by storing timing statistics in the TCB’s extended memory area.  When a task context switch is being executed, the thread switch extension could read a real-time clock to calculate how long the task being swapped out has run as well as timestamp the starting time for the task being swapped in."
user-extensions,"If used, the extended memory area for the TCB should be allocated and the TCB extension pointer should be set at the time the task is created or started by either the thread create or thread start extension.  The application is responsible for managing this extended memory area for the TCBs.  The memory may be reinitialized by the thread restart extension and should be deallocated by the thread delete extension  when the task is deleted.  Since the TCB extension buffers would most likely be of a fixed size, the RTEMS partition manager could be used to manage the application’s extended memory area.  The application could create a partition of fixed size TCB extension buffers and use the partition manager’s allocation and deallocation directives to obtain and release the extension buffers."
user-extensions,"The user extensions are invoked in either extension forward order or extension reverse order.  By invoking the user extensions in these orders, extensions can be built upon one another.  At the following system events, the user extensions are invoked in forward order"
user-extensions,"thread creation, thread start, thread restart, thread switch, thread begin, thread exitted (return from thread entry function), and fatal error detection."
user-extensions,"thread creation,"
user-extensions,"thread start,"
user-extensions,"thread restart,"
user-extensions,"thread switch,"
user-extensions,"thread begin,"
user-extensions,"thread exitted (return from thread entry function), and"
user-extensions,fatal error detection.
user-extensions,"At the following system events, the user extensions are invoked in reverse order:"
user-extensions,"thread termination, and thread deletion."
user-extensions,"thread termination, and"
user-extensions,thread deletion.
user-extensions,"At these system events, the user extensions are invoked in reverse order to insure that if an extension set is built upon another, the more complicated user extension is invoked before the user extension it is built upon.  An example is use of the thread delete extension by the Standard C Library.  Extension sets which are installed after the Standard C Library will operate correctly even if they utilize the C Library because the C Library’s thread delete extension is invoked after that of the other thread delete extensions."
user-extensions,"The thread create extension is invoked during thread creation, for example via rtems_task_create() or pthread_create(). The thread create extension is defined as follows."
user-extensions,The executing is a pointer to the TCB of the currently executing thread.  The created is a pointer to the TCB of the created thread. The created thread is completely initialized with respect to the operating system.
user-extensions,The executing thread is the owner of the allocator mutex except during creation of the idle threads.  Since the allocator mutex allows nesting the normal memory allocation routines can be used.
user-extensions,"A thread create extension will frequently attempt to allocate resources.  If this allocation fails, then the thread create extension must return false and the entire thread create operation will fail, otherwise it must return true."
user-extensions,The thread create extension is invoked in forward order with thread dispatching enabled (except during system initialization).
user-extensions,"The thread start extension is invoked during a thread start, for example via rtems_task_start() or pthread_create(). The thread start extension is defined as follows."
user-extensions,"The executing is a pointer to the TCB of the currently executing thread.  The started is a pointer to the TCB of the started thread. It is invoked after the environment of the started thread has been loaded and the started thread has been made ready.  So, in SMP configurations, the thread may already run on another processor before the thread start extension is actually invoked.  Thread switch and thread begin extensions may run before or in parallel with the thread start extension in SMP configurations."
user-extensions,The thread start extension is invoked in forward order with thread dispatching disabled.
user-extensions,"The thread restart extension is invoked during a thread restart, for example via rtems_task_restart(). The thread restart extension is defined as follows."
user-extensions,Both executing and restarted are pointers the TCB of the currently executing thread.  It is invoked in the context of the executing thread right before the execution context is reloaded.  The thread stack reflects the previous execution context.
user-extensions,"The thread restart extension is invoked in forward order with thread dispatching enabled (except during system initialization).  The thread life is protected.  Thread restart and delete requests issued by thread restart extensions lead to recursion.  The POSIX cleanup handlers, POSIX key destructors and thread-local object destructors run in this context."
user-extensions,The thread switch extension is defined as follows.
user-extensions,The invocation conditions of the thread switch extension depend on whether RTEMS was configured for uniprocessor or SMP systems.  A user must pay attention to the differences to correctly implement a thread switch extension.
user-extensions,"In uniprocessor configurations, the thread switch extension is invoked before the context switch from the currently executing thread to the heir thread.  The executing is a pointer to the TCB of the currently executing thread. The heir is a pointer to the TCB of the heir thread.  The context switch initiated through the multitasking start is not covered by the thread switch extension."
user-extensions,"In SMP configurations, the thread switch extension is invoked after the context switch to the new executing thread (previous heir thread).  The executing is a pointer to the TCB of the previously executing thread. Despite the name, this is not the currently executing thread.  The heir is a pointer to the TCB of the newly executing thread.  This is the currently executing thread.  The context switches initiated through the multitasking start are covered by the thread switch extension.  The reason for the differences to uniprocessor configurations is that the context switch may update the heir thread of the processor, see Thread Dispatch Details. The thread switch extensions are invoked with disabled interrupts and with ownership of a per-processor SMP lock.  Thread switch extensions may run in parallel on multiple processors.  It is recommended to use thread-local or per-processor data structures for thread switch extensions.  A global SMP lock should be avoided for performance reasons."
user-extensions,The thread switch extension is invoked in forward order with thread dispatching disabled.
user-extensions,The thread begin extension is invoked during a thread begin before the thread entry function is called.  The thread begin extension is defined as follows.
user-extensions,"The executing is a pointer to the TCB of the currently executing thread.  The thread begin extension executes in a normal thread context and may allocate resources for the executing thread.  In particular, it has access to thread-local storage of the executing thread."
user-extensions,The thread begin extension is invoked in forward order with thread dispatching enabled.  The thread switch extension may be called multiple times for this thread before or during the thread begin extension is invoked.
user-extensions,The thread exitted extension is invoked once the thread entry function returns. The thread exitted extension is defined as follows.
user-extensions,The executing is a pointer to the TCB of the currently executing thread.
user-extensions,This extension is invoked in forward order with thread dispatching enabled.
user-extensions,"The thread termination extension is invoked in case a termination request is recognized by the currently executing thread.  Termination requests may result due to calls of rtems_task_delete(), pthread_exit(), or pthread_cancel().  The thread termination extension is defined as follows."
user-extensions,The executing is a pointer to the TCB of the currently executing thread.
user-extensions,"It is invoked in the context of the terminated thread right before the thread dispatch to the heir thread.  The POSIX cleanup handlers, POSIX key destructors and thread-local object destructors run in this context.  Depending on the order, the thread termination extension has access to thread-local storage and thread-specific data of POSIX keys."
user-extensions,The thread terminate extension is invoked in reverse order with thread dispatching enabled.  The thread life is protected.  Thread restart and delete requests issued by thread terminate extensions lead to recursion.
user-extensions,The thread delete extension is invoked in case a zombie thread is killed.  A thread becomes a zombie thread after it terminated.  The thread delete extension is defined as follows.
user-extensions,The executing is a pointer to the TCB of the currently executing thread.  The deleted is a pointer to the TCB of the deleted thread. The executing and deleted pointers are never equal.
user-extensions,The executing thread is the owner of the allocator mutex.  Since the allocator mutex allows nesting the normal memory allocation routines can be used.
user-extensions,The thread delete extension is invoked in reverse order with thread dispatching enabled.
user-extensions,Please note that a thread delete extension is not immediately invoked with a call to rtems_task_delete() or similar.  The thread must first terminate and this may take some time.  The thread delete extension is invoked by rtems_task_create() or similar as a result of a lazy garbage collection of zombie threads.
user-extensions,The fatal error extension is invoked during system termination.  The fatal error extension is defined as follows.
user-extensions,The source parameter is the fatal source indicating the subsystem the fatal condition originated in.  The always_set_to_false parameter is always set to false and provided only for backward compatibility reasons.  The code parameter is the fatal error code.  This value must be interpreted with respect to the source.
user-extensions,The fatal error extension is invoked in forward order.
user-extensions,"It is strongly advised to use initial extension sets to install a fatal error extension.  Usually, the initial extension set of board support package provides a fatal error extension which resets the board.  In this case, the dynamic fatal error extensions are not invoked."
user-extensions,"© Copyright 1988, 2024 RTEMS Project and contributors."
user-extensions,The User Extensions Manager allows the application developer to augment the executive by allowing them to supply extension routines which are invoked at critical system events. The directives provided by the User Extensions Manager are:
user-extensions,rtems_extension_create() - Creates an extension set. rtems_extension_delete() - Deletes the extension set. rtems_extension_ident() - Identifies an extension set by the object name.
user-extensions,rtems_extension_create() - Creates an extension set.
user-extensions,rtems_extension_delete() - Deletes the extension set.
user-extensions,rtems_extension_ident() - Identifies an extension set by the object name.
user-extensions,"© Copyright 1988, 2024 RTEMS Project and contributors."
